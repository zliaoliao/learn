好的，没有问题！下面我将为 **阶段一：框架强化 (Day 1-3)** 中（除单元测试外）的关键知识点提供一些代码片段，帮助你加深理解和记忆。

**注意:** 这些代码片段是为了演示核心概念而简化的，实际项目中会更复杂。

---

**Day 1: Vue 核心基础 & Composition API**

1.  **`ref`, `reactive`, `computed` (Vue 3 Composition API)**

    ```vue
    <script setup>
    import { ref, reactive, computed } from 'vue';

    // 使用 ref 定义基本类型或对象的响应式引用
    const count = ref(0);
    const user = ref({ name: 'Alice' });

    // 使用 reactive 定义对象的深度响应式代理
    const book = reactive({ title: 'Vue Mastery', chapters: ['Intro', 'Core'] });

    // 计算属性：基于响应式数据派生新值，具有缓存
    const doubledCount = computed(() => count.value * 2);

    function increment() {
      count.value++; // 访问/修改 ref 需要 .value
      book.chapters.push('Advanced'); // 直接修改 reactive 对象的属性
      user.value.name = 'Bob'; // 修改 ref 对象的属性也需要 .value
      // 注意：不能直接替换整个 reactive 对象，会失去响应性
      // book = reactive({ title: 'New Book' }); // 错误做法
    }
    </script>

    <template>
      <div>
        <p>Count: {{ count }}</p>
        <p>Doubled Count: {{ doubledCount }}</p>
        <p>User Name: {{ user.name }}</p>
        <p>Book Title: {{ book.title }}</p>
        <p>Chapters: {{ book.chapters.join(', ') }}</p>
        <button @click="increment">Increment</button>
      </div>
    </template>
    ```
    * **理解点:** `ref` 用于单个值或需要替换整个对象的场景，通过 `.value` 访问。`reactive` 用于复杂对象，直接访问属性，但不能直接替换整个对象。`computed` 用于派生值并缓存。

2.  **`watch`, `watchEffect` (Vue 3 Composition API)**

    ```vue
    <script setup>
    import { ref, watch, watchEffect } from 'vue';

    const searchTerm = ref('');
    const results = ref([]);
    const immediateLog = ref('Initial');

    // watch: 监听指定数据源，在变化时执行回调
    watch(searchTerm, async (newValue, oldValue) => {
      console.log(`Search term changed from "${oldValue}" to "${newValue}"`);
      if (newValue) {
        // 模拟异步请求
        results.value = await fakeApiSearch(newValue);
      } else {
        results.value = [];
      }
    });

    // watchEffect: 立即执行一次，并自动追踪依赖，依赖变化时重新执行
    watchEffect(() => {
      // 它会自动追踪 immediateLog 的依赖
      console.log('watchEffect Log:', immediateLog.value);
      // 如果 searchTerm 在这里被访问，searchTerm 变化也会触发此 watchEffect
      // console.log('Search term in watchEffect:', searchTerm.value);
    });

    async function fakeApiSearch(term) {
      console.log(`Searching API for "${term}"...`);
      await new Promise(resolve => setTimeout(resolve, 500)); // 模拟网络延迟
      return [`Result for ${term} 1`, `Result for ${term} 2`];
    }

    // 用于触发 watchEffect
    setTimeout(() => {
      immediateLog.value = 'Updated after timeout';
    }, 2000);
    </script>

    <template>
      <div>
        <input type="text" v-model="searchTerm" placeholder="Search...">
        <ul>
          <li v-for="result in results" :key="result">{{ result }}</li>
        </ul>
      </div>
    </template>
    ```
    * **理解点:** `watch` 精确控制监听源和时机，提供新旧值。`watchEffect` 自动追踪依赖，立即执行，适用于简单副作用。

3.  **Props & Events (父子组件通信)**

    ```vue
    <script setup>
    import { ref } from 'vue';
    import ChildComponent from './ChildComponent.vue';

    const messageToChild = ref('Hello from Parent');
    const receivedMessage = ref('');

    function handleChildMessage(payload) {
      receivedMessage.value = payload;
    }
    </script>

    <template>
      <div>
        <h2>Parent</h2>
        <p>Message received from child: {{ receivedMessage }}</p>
        <ChildComponent :message="messageToChild" @message-from-child="handleChildMessage" />
        </div>
    </template>
    ```

    ```vue
    <script setup>
    import { defineProps, defineEmits } from 'vue';

    // 1. 定义接收的 Props
    const props = defineProps({
      message: {
        type: String,
        required: true,
        default: 'Default Message'
      }
    });

    // 2. 定义可以触发的事件
    const emit = defineEmits(['message-from-child']);

    function sendMessageToParent() {
      // 3. 触发事件，并传递数据
      emit('message-from-child', 'Hi Parent, this is Child!');
    }
    </script>

    <template>
      <div style="border: 1px solid blue; padding: 10px; margin-top: 10px;">
        <h3>Child</h3>
        <p>Message from parent: {{ props.message }}</p>
        <button @click="sendMessageToParent">Send Message to Parent</button>
      </div>
    </template>
    ```
    * **理解点:** 父组件通过 `v-bind` (或 `:`) 传递 Props，通过 `v-on` (或 `@`) 监听事件。子组件通过 `defineProps` 接收，通过 `defineEmits` 和 `emit` 发送事件。

4.  **Slots (具名 & 作用域)**

    ```vue
    <script setup>
    import { ref } from 'vue';
    const user = ref({ name: 'Charlie', id: 1 });
    </script>

    <template>
      <div style="border: 1px solid green; padding: 10px;">
        <header>
          <slot name="header">Default Header</slot>
        </header>
        <main>
          <slot>Default Content</slot>
        </main>
        <footer>
          <slot name="footer" :userData="user" :text="'Footer info'">
            Default Footer - User: {{ user.name }}
          </slot>
        </footer>
      </div>
    </template>
    ```

    ```vue
    <script setup>
    import LayoutComponent from './LayoutComponent.vue';
    </script>

    <template>
      <LayoutComponent>
        <template #header>
          <h1>My Custom Page Title</h1>
        </template>

        <p>This is the main content of the page.</p>

        <template #footer="{ userData, text }">
          <div style="background-color: lightgray; padding: 5px;">
            Custom Footer - Info: {{ text }} | User ID: {{ userData.id }}, Name: {{ userData.name }}
          </div>
        </template>
      </LayoutComponent>
    </template>
    ```
    * **理解点:** Slots 让组件更灵活，用于内容分发。具名插槽区分不同区域，作用域插槽实现子向父模板的数据传递。

5.  **Lifecycle Hooks & Composable**

    ```vue
    <script setup>
    import { ref, onMounted, onUnmounted } from 'vue';
    import { useMousePosition } from './useMousePosition'; // 假设有一个 useMousePosition.js

    const elementRef = ref(null);
    const { x, y } = useMousePosition(); // 使用 Composable

    // 生命周期钩子
    onMounted(() => {
      console.log('Component is mounted!');
      // 可以在这里访问 DOM 元素
      if (elementRef.value) {
        console.log('Element Ref:', elementRef.value.textContent);
      }
    });

    onUnmounted(() => {
      console.log('Component is about to unmount. Cleanup time!');
      // 清理工作，如移除事件监听器 (如果 useMousePosition 内部没有自动清理)
    });
    </script>

    <template>
      <div>
        <p ref="elementRef">Check console for lifecycle logs.</p>
        <p>Mouse Position (from Composable): X={{ x }}, Y={{ y }}</p>
      </div>
    </template>
    ```

    ```javascript
    // useMousePosition.js (简单的 Composable 示例)
    import { ref, onMounted, onUnmounted } from 'vue';

    export function useMousePosition() {
      const x = ref(0);
      const y = ref(0);

      function update(event) {
        x.value = event.pageX;
        y.value = event.pageY;
      }

      onMounted(() => {
        window.addEventListener('mousemove', update);
      });

      onUnmounted(() => {
        // 自动清理事件监听器
        window.removeEventListener('mousemove', update);
      });

      // 返回响应式数据
      return { x, y };
    }
    ```
    * **理解点:** 生命周期钩子在特定时间点执行。Composable 用于封装和复用逻辑，通常会包含自己的生命周期管理。

---

**Day 2: Vue 生态 & 进阶**

1.  **Vue Router (基础配置 & 导航)**

    ```javascript
    // router/index.js (简化版)
    import { createRouter, createWebHistory } from 'vue-router';
    import HomeView from '../views/HomeView.vue';

    // 路由懒加载
    const AboutView = () => import('../views/AboutView.vue');

    const routes = [
      { path: '/', name: 'home', component: HomeView },
      { path: '/about', name: 'about', component: AboutView },
      { path: '/user/:id', name: 'user', component: () => import('../views/UserView.vue'), props: true } // 动态路由 + props
    ];

    const router = createRouter({
      history: createWebHistory(), // 或者 createWebHashHistory()
      routes,
    });

    // 全局前置守卫 (示例)
    router.beforeEach((to, from, next) => {
      console.log(`Navigating from ${from.fullPath} to ${to.fullPath}`);
      // 模拟权限检查
      // if (to.meta.requiresAuth && !isAuthenticated) {
      //   next({ name: 'login' });
      // } else {
           next(); // 必须调用 next()
      // }
    });

    export default router;
    ```

    ```vue
    <template>
      <nav>
        <router-link to="/">Home</router-link> |
        <router-link :to="{ name: 'about' }">About</router-link> |
        <router-link :to="{ name: 'user', params: { id: '123' } }">User 123</router-link>
      </nav>
      <main>
        <router-view v-slot="{ Component }">
          <transition name="fade" mode="out-in">
             <component :is="Component" />
          </transition>
          </router-view>
      </main>
    </template>
    ```
    * **理解点:** Router 配置、不同模式、懒加载、导航方式、导航守卫的作用。`KeepAlive` 用于缓存组件状态。

2.  **Pinia (状态管理)**

    ```javascript
    // stores/counter.js
    import { defineStore } from 'pinia';
    import { ref, computed } from 'vue';

    // 推荐 Composition API 风格的写法
    export const useCounterStore = defineStore('counter', () => {
      // State (等同于 state 属性)
      const count = ref(0);

      // Getters (等同于 getters)
      const doubleCount = computed(() => count.value * 2);

      // Actions (等同于 actions)
      function increment(amount = 1) {
        count.value += amount;
      }
      async function incrementAsync(amount = 1) {
        await new Promise(resolve => setTimeout(resolve, 500));
        count.value += amount;
      }

      return { count, doubleCount, increment, incrementAsync };
    });
    ```

    ```vue
    <script setup>
    import { useCounterStore } from '../stores/counter';

    const counterStore = useCounterStore();

    // 可以直接访问 state 和 getters (它们是响应式的)
    // const count = counterStore.count; // 不要解构 state，会失去响应性
    // const double = counterStore.doubleCount;

    // 调用 actions
    function handleIncrement() {
      counterStore.increment();
    }
    function handleIncrementAsync() {
      counterStore.incrementAsync(5);
    }
    function directModify() {
       // 也可以直接修改 state (虽然推荐通过 actions)
       counterStore.count++;
       // 或者 $patch
       // counterStore.$patch({ count: counterStore.count + 1 });
    }
    </script>

    <template>
      <div>
        <p>Count: {{ counterStore.count }}</p>
        <p>Double Count: {{ counterStore.doubleCount }}</p>
        <button @click="handleIncrement">Increment</button>
        <button @click="handleIncrementAsync">Increment Async (+5)</button>
         <button @click="directModify">Direct Modify State</button>
      </div>
    </template>
    ```
    * **理解点:** Pinia 的 Store 定义（State, Getters, Actions），如何在组件中使用，以及与 Vuex 的主要区别。

---

**Day 3: React 快速回顾 & 对比**

1.  **JSX & List Rendering**

    ```jsx
    // ItemList.jsx
    import React from 'react';

    function ItemList({ items }) {
      const listTitle = "My Item List";

      return (
        <div>
          {/* 嵌入 JS 表达式 */}
          <h2>{listTitle}</h2>
          {items.length > 0 ? (
            <ul>
              {/* 列表渲染，必须提供 key */}
              {items.map((item) => (
                <li key={item.id} className="list-item" style={{ color: item.color }}>
                  {item.name}
                </li>
              ))}
            </ul>
          ) : (
            <p>No items found.</p>
          )}
        </div>
      );
    }

    export default ItemList;
    ```
    * **理解点:** JSX 语法（似 HTML 但嵌入 JS），`className`，`style` 对象，列表渲染用 `map` 且必须有 `key`。

2.  **`useState`, `useEffect`**

    ```jsx
    // DataFetcher.jsx
    import React, { useState, useEffect } from 'react';

    function DataFetcher({ userId }) {
      const [data, setData] = useState(null);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);

      // useEffect 处理副作用 (如数据获取)
      useEffect(() => {
        setLoading(true);
        setError(null);
        let isCancelled = false; // 处理组件卸载时异步操作未完成

        console.log(`Workspaceing data for user ${userId}...`);
        fetch(`https://jsonplaceholder.typicode.com/users/${userId}`) // 模拟 API 请求
          .then(response => {
            if (!response.ok) throw new Error('Network response was not ok');
            return response.json();
          })
          .then(userData => {
            if (!isCancelled) {
              setData(userData);
            }
          })
          .catch(err => {
            if (!isCancelled) {
              setError(err.message);
            }
          })
          .finally(() => {
             if (!isCancelled) {
               setLoading(false);
             }
          });

        // 清理函数：在组件卸载或 effect 重新运行前执行
        return () => {
          console.log('Cleanup function ran.');
          isCancelled = true;
        };
      }, [userId]); // 依赖项数组：仅当 userId 变化时，effect 才重新运行

      if (loading) return <p>Loading...</p>;
      if (error) return <p>Error: {error}</p>;

      return (
        <div>
          <h3>User Data</h3>
          {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>No data</p>}
        </div>
      );
    }
    export default DataFetcher;
    ```
    * **理解点:** `useState` 定义状态及更新函数。`useEffect` 处理副作用，依赖项数组控制执行时机，清理函数用于防止内存泄漏或取消操作。

3.  **`useContext`**

    ```jsx
    // ThemeContext.js
    import React, { createContext, useState, useContext } from 'react';

    // 1. 创建 Context
    const ThemeContext = createContext();

    // 2. 创建 Provider 组件
    export function ThemeProvider({ children }) {
      const [theme, setTheme] = useState('light');
      const toggleTheme = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));

      const value = { theme, toggleTheme }; // 传递的值

      return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
    }

    // 3. 创建自定义 Hook 方便消费 Context
    export function useTheme() {
      return useContext(ThemeContext);
    }
    ```

    ```jsx
    // ThemedButton.jsx
    import React from 'react';
    import { useTheme } from './ThemeContext'; // 使用自定义 Hook

    function ThemedButton() {
      const { theme, toggleTheme } = useTheme(); // 消费 Context

      const styles = {
        light: { background: '#eee', color: '#000' },
        dark: { background: '#333', color: '#fff' },
      };

      return (
        <button onClick={toggleTheme} style={styles[theme]}>
          Switch to {theme === 'light' ? 'dark' : 'light'} theme
        </button>
      );
    }
    export default ThemedButton;

    // 在 App.js 或其他地方使用 Provider 包裹
    // import { ThemeProvider } from './ThemeContext';
    // <ThemeProvider>
    //   <ThemedButton />
    //   {/* ... other components */}
    // </ThemeProvider>
    ```
    * **理解点:** `createContext`, `Provider` (提供 value)，`useContext` (或 `Context.Consumer`) 消费 value，避免 props drilling。

4.  **`useRef`**

    ```jsx
    // FocusInput.jsx
    import React, { useRef, useEffect } from 'react';

    function FocusInput() {
      // 1. 创建 ref
      const inputRef = useRef(null);

      useEffect(() => {
        // 2. 在 DOM 挂载后，通过 ref.current 访问 DOM 元素
        if (inputRef.current) {
          inputRef.current.focus(); // 让输入框自动聚焦
          console.log('Input element:', inputRef.current);
        }
      }, []); // 空依赖数组，仅在挂载时运行一次

      return (
        <div>
          <label htmlFor="myInput">Focus on load:</label>
          {/* 3. 将 ref 附加到 DOM 元素 */}
          <input ref={inputRef} type="text" id="myInput" />
        </div>
      );
    }
    export default FocusInput;
    ```
    * **理解点:** `useRef` 用于获取 DOM 节点的引用，也可以存储不引起重渲染的可变值。通过 `.current` 属性访问。

5.  **`React.memo`, `useCallback`, `useMemo`**

    ```jsx
    // ParentComponentWithOptimization.jsx
    import React, { useState, useCallback, useMemo } from 'react';

    // 1. 使用 React.memo 包裹子组件，只有 props 变化时才重渲染
    const MemoizedChild = React.memo(function ChildComponent({ count, onClick }) {
      console.log('ChildComponent rendered');
      return (
        <button onClick={onClick} style={{ margin: '10px', padding: '10px' }}>
          Child Count: {count} (Click me)
        </button>
      );
    });

    function ParentComponentWithOptimization() {
      const [parentCount, setParentCount] = useState(0);
      const [childCount, setChildCount] = useState(0);

      // 2. 使用 useCallback 缓存事件处理函数
      // 如果不使用 useCallback，每次 Parent 重渲染都会创建新的 handleChildClick 函数
      // 导致传递给 MemoizedChild 的 onClick prop 引用变化，使其无效化 React.memo
      const handleChildClick = useCallback(() => {
        console.log('Child button clicked!');
        // setChildCount(childCount + 1); // 错误：闭包陷阱，childCount 永远是初始值
        setChildCount(c => c + 1); // 使用函数式更新获取最新状态
      }, []); // 空依赖，函数永不改变引用 (除非组件卸载)

      // 3. 使用 useMemo 缓存计算结果
      // 假设这是一个昂贵的计算
      const derivedValue = useMemo(() => {
        console.log('Calculating derived value...');
        let sum = 0;
        for (let i = 0; i < parentCount * 1e6; i++) { // 模拟耗时计算
            sum += i;
        }
        return `Derived based on parent count ${parentCount}: ${sum % 100}`; // 返回计算结果
      }, [parentCount]); // 仅当 parentCount 变化时重新计算

      console.log('ParentComponent rendered');

      return (
        <div>
          <h2>Parent</h2>
          <button onClick={() => setParentCount(c => c + 1)}>Increment Parent Count</button>
          <p>Parent Count: {parentCount}</p>
          <p>{derivedValue}</p>

          {/* 传递 memoized 函数和状态 */}
          <MemoizedChild count={childCount} onClick={handleChildClick} />
        </div>
      );
    }
    export default ParentComponentWithOptimization;
    ```
    * **理解点:** `React.memo` 用于组件级别优化。`useCallback` 缓存函数引用，`useMemo` 缓存计算结果。它们都依赖于依赖项数组来决定何时更新。滥用可能导致性能下降。

希望这些代码片段能帮助你更好地理解和记忆这些 Vue 和 React 的核心概念！
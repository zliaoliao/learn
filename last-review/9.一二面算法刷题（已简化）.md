[toc]


# 时间复杂度

一个操作如果跟样本的数据量没有关系，每次都是固定时间内完成，叫做常数操作；

时间复杂度是一个算法流程中， 常数操作数量的一个指标，写出的算法流程中， 根据发生了多少次常数操作，总结出算法表达式， 在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数， 剩下的部分;（如果为n, 时间复杂度就是O(n)）

如果理论上时间复杂度一样，需要拼常数项了，那就需要用实际跑的方式去检验算法的优劣（因为常数项的操作时间不确定）

# 最容易犯得脑残错误

- 1. 在比较的时候 没有用==， 而用了赋值符=
- 2. 链表比较值相等时， 值应该用val值去比较，而不是node节点
- 3. 数组的push返回的数组长度而不是新数组

# 解题尝试（对于没见过的题）

二叉树： 

- 要求解的结果分两种情况讨论：1. 包含头节点的 2. 不包含头节点的
- 从左往右尝试（常见于初始给的数组结构）
  - 数组如果每一个元素设计到抉择，也可以转化为树结构： 对于每一个元素选与不选，往左与往右
- 在一个范围上尝试
  - 从左往右尝试，和范围尝试能搞定动态规划，至少七成的题目



# 思想总论

0. 面试的时候，在时间有限和紧张的因素下，可能平时能够慢慢想明白得问题，面试时一念之差想错：

易错点
```
1. 给对象属性，用变量去赋值或者取值的时候，要尤其注意用[]， 容易写成了 . 的方式
2. 遍历时，要给变量赋值为值得时候，赋值为了索引； 

```

针对以上不应该犯的错误，有以下面试做题准则：

```
1. 宁愿慢，不要快： 慢审题， 慢思考； 记住一道值题至少有10分钟时间，所以你有2分钟审题，3分钟思考的时间。一共有5分钟思考的时间，有了思路写起来就挺快的。有了大概思路再写。 任何时候你都有2分钟的思考时间。
2. 长回顾： 写的过程中写完一个小逻辑，比如，一个for循环，一个功能函数，要回顾一下，检查有没有变量赋值错，取值错，判断的简单问题，自己写出来的代码是否和自己的逻辑一致。

```

1. 递归类似

如果下一步的执行方式，跟当前步骤类似，并且下一步，需要上一步的结果，可考虑三种方式 
> 1. 循环迭代自己,改变自己的值 val = fn(val) 【由某种方法推出自己的值】， 
>理解迭代： 如果一直脚过河（单脚跳，自己迭代先前），至少得有两个石块（两个变量）轮替；如果两只脚过河（一起走），得有三个石块（三个变量）轮替，才能向前走；也就是说，如果要向前迭代，那么变量的数，要比迭代的值多一个才行；并且倒腾的时候，从后往前倒腾，赋值变量的顺序别搞错了；
> [pre, cur] = [cur, pre+cur]  // 有了es6 结构复制后，两个值的向前迭代，可以考虑两个变量结构赋值方式
> 2. 递归 
> 3. reduce

2. while 循环 与 for循环

while 循环
> 想到用递归去解题的，可以先想想while循环是不是也可以
> 一开始不固定次数的循环， 比如二分查找

for循环
> 在普通i++ 的for循环里，想要下一轮还从本轮的索引i,开始遍历，就可以在本轮 i-- 一下；
> i-- 可以解决遍历中删除一个元素的数组塌陷问题， 也可以达到下一轮还从本轮的索引i开始遍历的目的；

1. 理解递归
 - 1. 第一种理解思路： （这一种思路更适合做题）
  - 1. 思考整颗树与其左右子树的关系，可以把二叉树简化成根节点，左子树，右子树这样三个点，然后去思考答案的原问题(也就是思考如果拿到了左右子树的解，那么最终的解与左右树的关系)；不要想子问题的过程（因为脑子处理不了几层，不要一开始就陷入细节），要想子问题的结果，可以假设已经拿到了子节点的结果;
  - 2. 原问题思考完毕后（原文题就是要求解的问题），思考左子树/右子树对应的子问题（子问题，就是我假设已经拿到结果的问题）; 
  - 3. *将子问题的结果返回给上一级问题， 边界条件的判断是返回叶子结点的结果，正常返回的是 总的结果 也是 中间每一级节点的结果*
  - 4. *写对边界条件的逻辑（base case），写对非边界条件的逻辑(由假设递归获取的下一级结果，推出的当前层级的结果)*，只要边界条件的逻辑和边界条件的逻辑是对了，那么你的代码就自动式对的
    - 为什么这么做（递归）对的呢？可以用数学归纳法来解释：
    - 1. 首先证明在某个起点（或最简单的情况下）时命题成立（能算出结果） 【边界条件的结果 base case】
    - 2. 然后证明从一个值到下一个值的过程有效（如果能拿到xx结果，就能计算出当前结果），那么中间所有的结果都能算出来 【由下一级的结果，推出当前结果】
    - 3. 类似多米洛骨牌， 你只要证明第一张骨牌会倒， 然后证明任意一张骨牌倒了，其下一张骨牌也因此而跟着倒下， 那么就可以算出所有骨牌都会倒
- 2. 第二种理解思路： 用洋葱模型去理解递归似乎可以，执行函数前的部分是进入洋葱的部分，执行函数后的部分是出洋葱的部分，这两部分因为都在一个函数作用域里，出的部分，和进的部分变量值（如果未被改变的话）是相同的；


把上述解题思路简化：

```
1. 边界条件: base case 的结果
if(问题足够简单){
    直接解决
    ps: 这里也可以做结果的收集，如果自己做了结果的收集，下面第3步就不需要再收集结果
} else {

  2. 当前步骤需要做的事

  3. 假设获取了下一层级（左右节点）结果， 这里就是递归过程

  4. 由下一层级的结果，推出当前层级（每一层级）的结果， 这个结果同时也是总的结果
}

```
```

上述第1,2步是难点，关于拆分的思路： 

1. 拆分成1个元素的处理方法，和2个元素情况的处理方法， 然后让他们组合起了，推衍到，3,4...n-1,n

> 要注意的是在递归里，处理过的小组合的问题，后面是可以直接用的，比如处理过2个的情况，那么处理三个的时候，是可以直接用两个的方法的；
> 把三个拆分成1个，和两个，也是常用方法；
> 然后 n 个 ，就可以分为 1 的的情况和 n-1 的情况， n-1 的情况可以继续分下去

```


4. 递归结论：

- 递归结果收集
- 1. 优先用外部变量 + 闭包，收集，这个最简单明了;


- 2. 优先用回溯时收集：在 *每一层定义结果变量* 或者 *直接在return计算* 来收集；如果回溯时需要时收集，结果的收集，就用每一层定义变量来收集；接受每一次递归的结果，做结果组装；

理解回溯： *当前的结果，由下一级的结果而来，假设能拿到下一级的结果* 能用回溯收集，尽量原回溯收集

  - 递归途中有了结果就返回（一旦一条路径符合条件，就中断递归返回）的方法就是return
    - 在递归过程中，*如果中间就拿到了结果，可以用标记法及时返回*，给一个特殊值（比如-1），一层层的返回到上一级，最后在入口处判断就好了；
    - 在return 语句后写递归, 用或(||)连接，这样一个分支路径的结果就是递归最终结果

- 3. 叶子结点收集： 把结果*收集对象*一开始就当参数传进去，在叶子节点收集结果。在叶子结点时，已经拿到这一条路径的全部结果，可以最终的叶子结点收集（也就是递归终止时），不需要回溯时收集； (我习惯这种做法，能不用回溯就不回溯)
  - 叶子结点收集的话，*需要传递收集对象*，如果传递一个给函数普通变量，那么函数内部改这个变量，改的就是值了，跟原来的变量就没有关系了
  - 如果不想每次都传这个结果收集对象，可以*在函数里定义一个全局变量res*，然后再写一个真正解题的函数fn, 在fn里每次更新结果，然后执行fn，返回结果res; 这个可以可以处理上面每次必须传结果收集对象的弊端;



- 递归问题常见思路误区
  - 新手总容易陷入，纠结摸不清递归整个过程全局的变化，实际上这个过程不需要弄清楚（也没人能纯靠脑子弄清楚）
  - 只需要保证
    - 1. 大问题抽象成小问题（缩小范围，缩小规模）
    - 2. 处理base case 和 最小的一步逻辑
  - 只要这两部正确，整个过程就是正确的

通用结论：

1. 处理重复，如何知道已经遍历过
  - 1. hash 存储
  - 2. 做标记： 遍历过的添加属性，或者改值



5. 循环论
  - 1. 处理本轮的值i,j,k，的逻辑
  - 2. 分别迭代：+1，为下一轮做准备



算法其他常用结论：

合并有序： 核心逻辑，循环里，每个位置谁小放谁，然后向前走一步，`A[k] = A1[i] < A2[j]?A1[i++]:A2[j++];`(这段逻辑可以用if else拆开写),  链表和数组同理，一旦一个遍历完成，则另一个剩下的元素都加到位置后面，链表只要有一个到边界就跳出来，把剩下的加到结果里就好；

数组类：

1. 当发现自己的代码里有两层循环时，先反思一下，能不能用空间换时间，利用hash表，把它优化成一层循环，即双 for 使用 hash表优化
2. 几乎所有的求和问题，*都可以转化为求差问题，通过把求和问题转化为求差问题，事情往往会变得更加简单*。（两个数组和为n, 找中间值）
3.  没事别瞎用正则容易出错，除非想不到其他办法
4.  维护一个递减数组（递减栈，不是严格的栈，从那边拿元素随意）的方式就是，新元素比栈顶元素大，就不停地把栈顶元素移除，直到不满足条件，比栈顶元素小，再直接放进去； 放进去的时候可以放元素的索引， 最后可以用新元素的索引，和栈中头，尾元素的位置关系，来求解；
5.  数组判空，用数组长度，禁止用数组值判空；
6.  forEach循环，无法中途跳出循环，break命令或return命令都不能奏效,所以算法中一般使用for循环；
7.  （当前位置+步数-1）%arr.length = 数组循环数组的实际索引
8.  


处理滑动窗口初始化的两种方法：
- 1. 同时处理左右边界，不单独初始化： *left边界不好处理，直接把它给成右边界为0时，对应的左边界负值就好了：-k+1*，可以统一处理;
- 2. 先初始化右边界，到达位置结算一次： 然后进入循环，从right+1初开始，先处理right+1值，然后处理左边界；（等于是移动了一步，先处理右边界，再处理左边界，然后算结果； 然后再迭代）





字符串：

```
正则： 

match() 方法是一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。
如果我们的正则表达式尾部有 g 标志，match()会返回与完整正则表达式匹配的所有结果，但不会返回捕获组。
这里我们没有使用g标志，match()就会返回第一个完整匹配（作为数组的第0项）及其相关的捕获组（作为数组的第1及第1+项）

```

链表：

命题时，数组和字符串的角色往往是“算法思想的载体”，那么链表本身就可以被认为是“命题的目的”。
处理链表的本质，是处理链表结点之间的指针关系,简单说就是处理指针


一些经验：

- 看到'连续'，'子'想到通向双指针，left,right, 每次固定right，移动left做判断
- 看到'重复' 想到hash
- 看到'o(lgn)', '排序数组'， '部分排序数组','搜索',考虑二分


前端算法： 7大排序，3大查找； 栈（数组）， 链表， 树


口诀：针对一类题的思路

小鼠小岛机器人，四方递归标记行。

# 递归

## 递归 easy

### 展平数组 flat

- js原生的flat() 方法创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中。

let ary = [1, [2, [3, [4, 5]]], [6, 7, [8, 9, [11, 12]], 10]];

- 处理深度
- 不改变原数组
- 出此题一般想让你用递归或者迭代做法

解法一：concat,递归

- 面试一般写这个就行，这个好写，而且有深度

```
function flat(arr, depth = 1) {
    return arr.reduce((pre, item) => {
        if (Array.isArray(item) && depth > 0) {
            return pre.concat(flat(item, depth - 1));
        }
        return pre.concat(item);
    }, []);
}

```

解法二：concat, 遍历
- 1. concat 的参数如果是数组，则自然展开，再拼接，如果是值，则直接加在数组后
  - *concat可以接受多个参数， 每个参数都有上述逻辑*
- 2. 易错点：concat返回新数组
  - 每次生成新数组，可以用空数组去拼，否则越拼越长
- 3. 加上Array.isArray 的边界判断能节省不少时间


```
function flat(array, depth = 1) {
    let result = [];
    let stack = [...array];

    while (stack.length) {
        const item = stack.pop();
        if (Array.isArray(item) && depth > 0) {
            stack.push(...item); // 展开当前数组
            depth--; // 减少深度
        } else {
            result.unshift(item); // 添加非数组元素到结果
        }
    }

    return result; // 直接返回结果
}

```


方法三：JSON

let str = JSON.stringify(ary);
ary = str.replace(/(\[|\])/g, '').split(',');

// 对于子元素结构与母元素结构相同的，比如数组类型，一般在遍历元素后，根据数据类型判断是否需要递归处理

### 实现斐波拉契，后一项等于前两项之和

- 从0， 1， 开始， 0， 1， 1， 2, 3
- 有了es6 结构复制后，两个值的向前迭代，可以考虑两个变量结构赋值方式

```
var fib = function(n) {
    if(n<2) return n;
    let pre = 1, cur = 1;
    for(let i=3;i<=n;i++){
        [cur, pre] = [pre+cur, cur] // 有了es6 结构复制后，两个值的向前迭代，可以考虑两个变量结构赋值方式
    }
    return cur;
};


```


```
const fib = (n) => {
  if(n<2) return n;
  if(n>=2){
    return fib(n-1) + fib(n-2);
  }
}

console.log(fib(5), 111)
```



### n 级台阶

一只蚂蚱爬n级楼梯，它可以1次爬1级，2级，....n级楼梯，一共有多少种爬法？

- 动态规划题目可以记一下，暂时不去理解

```
// 太多重复子结构，思考从底部向上构造递归程序, 从最小结构开始;
// 先爬0，1， 2 剩下的一次爬完；


const fib = (n) => {
	if(n<2){ // n 可能为0
		return 1
	}
	let res = 1+1;
	for(let i=2;i<n;i++){
		res += fib(i)
	}
	return res;
}

console.log(fib(5))

```


## 递归 mid

### 步骤决策问题,排列组合

> 决策问题 我习惯传入结果收集参数，在最终叶子节点收集结果，这样回溯时，就不需要收集结果了，这样比较好理解一点

```
function search(state,res, decisions){
    if(所有决策都做完){
        返回结果
    }
    根据当前状态算出所有可能得决策
    递归调用这些决策
    手机递归的结果，返回
}


```


1. 递归与穷举： 求集合{a, b, c} 的所有子集

- 思路： 针对每一节点，有选和不选两种情况
- 易错点： 不需要循环后在递归， 如果是循环肯定就不能每一次arr传原数组，至少走过的节点（就不能在处理了），那还要把走完的过滤出来；所以不需要遍历，一次处理一个深度的节点, 对于每一个节点有两个选择（二叉树）
- 深度等于最后一个索引时，还是要处理的

```
// 1. 是无序的,   2. 对每一有两种情况， 要或者不要（如果是有序的那么还得考虑顺序，肯定就不止两种情况）, 结果是2^n种


const getChild = (arr,res=[], path=[],deepIndex=0) => {
	if(deepIndex===arr.length){
		return res.push(path) 
		//关键点1：  这里代表一条路径的结果，可以有很多路径，结果如何收集呢？
		// 用push, 用类似全局变量的对象，有了最终结果就，加入这个对象，注意这里要使用改变对象的方法，比如数组要用push,而不是concat；
	}
	
	// 选， 一步步深度进去的就不用循环来做，循环是广度的
	getChild(arr, res, path.concat(arr[deepIndex]), deepIndex+1) 
	//关键点2： 注意这里不要用deepIndex++（不生效，先作为参数传入，然后后再加的），++deepIndex(改变了变量的值，会出问题)
	// 不选
	getChild(arr, res, path, deepIndex+1)

	return res;
}

const a =[1,2,3]
console.log(getChild(a))

```


1. 全排列问题: 求字符串abc的全排列

- 针对每一个位置，在剩下可选元素中选


```
1. 在叶子节点收集最终结果（我习惯的方式）

const sortArr = (arr, res=[], path=[]) => {
	if(path.length === arr.length){
		return res.push(path);  // 结果收集与返回
	}
	// 可选数组: 原数组里，出去已经被选过的；  可选的,每一步,每种选择选一个
	const chooseArr = arr.filter(item=> !path.includes(item))
	for(let i=0;i<chooseArr.length;i++){// 这一次，有多少种选择
		// 本次的结果
		sortArr(arr, res, path.concat(chooseArr[i]))
	}
	return res;
}

const a = [1,2,3,4]
console.log(sortArr(a));


2. 在回溯时收集结果


// 第一次n种选择，第二次n-1种, 后面依次出去选中的； 不像子集问题，每步只有两种选择；
const sortArr = (arr, path=[]) => {
	if(path.length === arr.length){
		return [path];  // 关键点1： 收集结果时拼接的是二维数组
	}
	let r = [];  // 为啥每次进来要清空结果? 进来时情况，回溯时收集
	// 可选数组: 原数组里，出去已经被选过的
	const chooseArr = arr.filter(item=> !path.includes(item))
	for(let i=0;i<chooseArr.length;i++){// 这一次，有多少种选择
		// 本次的结果
		const res1 = sortArr(arr, path.concat(chooseArr[i]))
		// 关键点2： 如何收集所有结果
		r = r.concat(res1); 
		// 回溯的时候（穿越洋葱出环的时候，r是没有值的，因为是在这一层定义的），
		// 如果用res的话，res是有值的，因为出洋葱时res是被不停改变的
		// 而我要的结果只是这一条路径的最终结果，已经在最后一层洋葱里收集好了，不需要再改变了， 只需要收集最终每一个叶子节点的路径就行，
	}
	return r;
}

```




1. 组合问题

从集合{a, b, c,d, e, f,g} 中取出2个元素，有多少种组合？程序实现

- 对于每一个节点有两种情况： 选当前元素，剩下的元素剩下的数组里选；不选当前元素，剩下的元素在剩下的数组里选；
- 边界条件： n为0，从数组中选0个
- 易错点: 不需要过滤，每次传的都是没选过的

```

// 组合式无序的
处理无序这个，主要就是一条，一旦选了一个元素，那么这个元素的接下来的路径不能出现这个元素，其他路径也不能出现这个元素
表现就是，每次选第一个，剩下的在其余元素中选完，或者不选第一个，直接在其他元素里选完。

> 我们首先从第一个元素下手，对于第一个元素，我们有两个选择：要 or 不要。如果要了，那么我们需要选择的元素就少了一个了，我们只需要从后面的元素中选出两个就够了。

const getChildren = (arr, n,res=[], path=[], ) => {
  if(n===0){
    return res.push(path);
  }
  if(arr.length<n){
    return res;
  }
  const [first, ...others] = arr;
  getChildren(others, n-1, res, path.concat(first));
  getChildren(others, n, res, path);
  
  return res;
}

console.log(getChildren(arr, 3));

```

4. 类似组合： 给定一个不重复的正整数集合，从中取出n个数字，使得他们和为m, 写一个函数，求这n个数字，如有多个只需返回一个

解法同组合，多了有了结果就返回，中断递归的步骤

- 注意这些参数表示的含义： n还要选多少个，m还差多少， arr还有多少能选
- 易错点： arr 有可能为空，死循环

```
const choose = (arr, n, m,path=[], res=[]) =>{
  if(m === 0){
    return path;
  }
  if(m<0 || arr.length===0){
    return;
  }
  const [first, ...others] = arr;
  // choose(others, n-1, m-first, path.concat(first), res)
  // choose(others, n, m, path, res)
  // 递归途中有了结果就返回（一旦一条路径符合条件，就中断递归返回）的方法就是： 在return 语句后写递归, 用或连接，这样一个分支的结果就是最终结果
  return  choose(others, n-1, m-first, path.concat(first), res) || choose(others, n, m, path, res)
}

console.log(choose([1,2,3,4,5],3, 9, [], []))


```
如果要所有结果

```
const findChildren = (arr, n,m, res=[], path=[]) => {
  if(m === 0 && n=== 0){
    return res.push(path)
  }
  // arr 有可能为空， n也是逐渐变小的
  if(arr.length === 0 || m<0){
    return;
  }
  const [first, ...others] = arr;
  console.log(first, others);
  findChildren(others, n-1, m-first, res, path.concat(first))
  findChildren(others, n, m, res, path)

  return res;
}

console.log(findChildren([1,2,3,4,5],2, 7))


```


## 迷宫问题

- 四叉树
- 如果不能改变原数组可以用一个新树数组去记录走过的位置： 不过一般不需要，一般改变原数组就行了

```

transverse:[]
// 记录走过当前位置, 利用x和y坐标做一个运算
  transverse[x*maze.length + y] = 1;

下次判断走没走就看运算结果是否等于1;



```

比较难，没时间先不看

在一个（棋盘型）迷宫中，有一只老鼠，在左上角位置，规定老鼠想要找到的出口位置在左下， 灰色区域代表墙，白色区域可以行走，每次老鼠走一格，写一个算法，帮助老鼠走出迷宫

```
function backtracking(...){
    if(到达终点){
        返回路径
    }
    找到所有没有走过的路
    
}
利用递归，思考完整的走迷宫，变成了思考一步要做什么

```

> 算法抽象

```
function rat_in_maze(maze, pos=[0,0], path=[], transverse=[]){...}

maze  迷宫矩阵
pos   当前位置
path  路径
transverse  到过的地方记录


```

代码

```

function rat_in_maze(
  maze, pos=[0,0], path=[[...pos]], transverse = []
){
  const [x, y] = pos;
  if(maze[x][y] === 2){  // 终止位置
    return  path;
  }
  // 记录走过当前位置
  transverse[x*maze.length + y] = 1;
  // 找到下一步可能得选择
  const choices = [
    [x+1, y], [x-1, y],
    [x, y+1], [x, y-1],
  ].filter(([x, y])=>{
    return x>=0 && y>=0 && x<maze.length && y<maze[0].length &&
    !transverse[x*maze.length + y] && maze[x][y] !== 1
  })
  // 对每一个选择继续递归， 寻找路径
  for(let [x, y] of choices){
    const p = rat_in_maze(maze, [x,y], path.concat([x, y]), transverse);
    if(p) return p;
  }
}

```


# 其他算法

### 二分查找

一句话描述： 定左右边界,猜中值，对比中值与输入值大小，移动边界 从两边向中间排查

```
    function bsearch(A, x){
        let l = 0; // 左边界
        let r = A.length -1;  // 右边界
        let guess;  // 猜测位置
        while(l<=r){
            guess = Math.floor((l+r)/2);
            
            if(A[guess] ===x) return guess;
            else if(A[guess]>x) r = guess -1;    // 不等于猜测的值，而且比猜的值小，所以让猜的值减1作为右边界
            else l = guess + 1;
        }
        
        return -1;
    }

```

## 排序

- 这些所有的排序，开始都要注意把捣乱的去掉（为空值，或者length<2）,在演示代码中省略没写

理解： 插入和冒泡，都是两个基础排序，思想类似，都是两层循环，冒泡是每次拿出一个元素是和剩余的比，确定位置，插入是每次拿一个元素，和前面排好序的比，换到正确的位置



冒泡

- 双for循环，一次（外层走一步）确定一个最大的位置的元素（大的冒泡到后面），也就是一次确定一个外层索引位
- 第一层循环*确定排序范围*，从尾部遍历到头部,头部第一个不需要排（最后一个自然会变得有序）, i--
- 第二层把比较范围内的最大元素冒泡到最后（范围内）, 也就是每次与当前元素的相邻元素比较，如果当前元素大，就移到右边(也就是交换一次)

```
const bubble = (arr) =>{
  
  // 1. 确定比较范围: 从后向前，因为一次确定一个后面的大的位置，最后一个不用排，所以大于0就行，每次确定的就是i的位置
  for(let i=arr.length-1;i>0;i--){
    // 2. 比较时确定边界: 每次确定的是i的位置，所以小于i就行,这样最后一项j+1正好等于i;
    for(let j=0;j<i;j++){
      if(arr[j]>arr[j+1]){
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
      }
    }
  }
  return arr;
}

```

插入：，

- *默认第一个元素有序， 向有序数组每次插入一个元素，数组仍然保持有序*, 类似于打扑克起牌时，拿到一张牌，就从右到左比较把它插入到合适的位置
- 双for循环
- 第一层循环*确定排序的范围*，从头部遍历到尾部, 头部第一个不需要拍（1个数自然是有序的）,0~i的范围有序（0到0，是第一个元素，已经默认有序），所以从1开始
- 第二层循环表示, 将i位置元素，依次和之前的位置（i-1）比较，如果比之前的小，就交换位置，直到i-1超出边界，或者i比i-1大

```
// for 循环也行

const insert = (arr) => {
  for(let i=1;i<arr.length;i++){
    // 既然j=i,那么边界条件就可以和i保持一致
    for(let j=i;j>0;j--){
      if(arr[j]<arr[j-1]){
        [arr[j], arr[j-1]] = [arr[j-1], arr[j]]
      }else{
        break;
      }
    }
  }
  return arr;
}

```

合并排序 

- 先拆再合，合并两个有序数组, 递归拆，回溯合
- 合并的时候，得有有两个有序数组，需要slice

> 左闭右开区间的好处就是右边减左边正好是元素个数，右边比区间实际结尾元素位置大一
> 所谓合并，先从中间拆开成两半，然后再合并有序数组，递归进行，拆要拆到变成一个元素的数组为止

核心程序： 合并两个有序数组
完整版：

```
const merge = (arr, l, m, r) =>{
  const helpArr = [];
  let i = 0;
  let p1 = l;
  let p2 = m+1;
  // let res=0;
  while(p1<=m && p2<=r){
    // 如果优化方法一时间想不到，那么就写粗暴解法，重复一两步也没关系（小和问题多的步骤）
    // res += arr[p1]<arr[p2] ? (r-p2 + 1)*arr[p1]:0 
    helpArr[i]= arr[p1]<arr[p2]?arr[p1++]: arr[p2++];
    i++;
  }
  // 判断越界的不好处理，那就判断不越界的， 把没越界的剩下的复制过来
  while(p1<=m){
    helpArr[i] = arr[p1++]
    i++;
  }
  while(p2<=r){
    helpArr[i] = arr[p2++];
    i++;
  }
  // 同步右移，旧数组l+i 位置的值等于 新数组i位置的值，也是不错的处理
  for(let i=0;i<helpArr.length;i++){
    arr[l+i]=helpArr[i]
  }
}
const mergeSort = (arr, l, r) => {
  if(l===r){
    return;
  }
  const m = Math.floor((l+r)/2);
  mergeSort(arr, l,m);
  mergeSort(arr, m+1, r);
  merge(arr, l, m, r);
  // return mergeSort(arr, l,m) +
  // mergeSort(arr, m+1, r)+
  // merge(arr, l, m, r)
}

```

快速排序 ： *快排还是有点难度的， 整体是一个左边界left往右扩，遇到小于base的就和left+1交换，left 把这个值吞进来的过程*

- 选好基准值，对撞指针查找，分别和基准值比较，小的排左边，大的排右边
- 从基准值的对面一端（右边）开始移动，基准值拿起来就有一个空位，开始从右向左填这个空位
- 右指针走完会有一个空位，开始处理这个空位，走左指针，从左向右填这个空位
- base的值要记录一下，因为后续base所在的空位会放上别的值
- 等于base的，基本版不用考虑，等于的情况当成大于的考虑就行；一直递归大的在左，小的在右，最后自然就处理好了，等于的情况； 面试写基本版就可以嘞

更好理解的版本：

```

const quickSort = (arr, l, r) => {
  // 相撞或者越界
  if(l>=r){
    return;
  }
  const p = partition(arr, l, r);
  quickSort(arr, l, p-1);
  quickSort(arr, p+1, r);
}

const partition = (arr, l, r) => {
  // 小区的有边界，开始为-1, 整个过程是一个小区右边界不断向右扩充的过程，遇到小的就交换到小区边界加1的地方，
  // 然后扩充边界吃掉，然后继续走；遇到大的就直接继续走，最后把比较和小区边界交换
  let less = l-1; 
  const num = arr[r];
  let i =l;
  while(i<r){
    if(arr[i]<num){
      [arr[less+1], arr[i]]= [arr[i], arr[less+1]]
      less++;
    }
    i++;
  }
  [arr[less+1], arr[r]]= [arr[r], arr[less+1]]
  return less+1;
}



```
上面是快排1.0, 快排3.0的变化就是，选取比较点变成随机的，然后换到右边；其他步骤类似，只不过分成小于区，等于区，大于区三部分， 返回的是等于区的左右边界;面试就写个1.0， 2.0 就行了; 最差的情况，数组有序时，比如 1，2,3,4,5 选取右边的值为基准值，时间复杂度就是n^2，这就是因为基准值打的太偏了，最好的情况就是基准值正好打在中间，要想优化，基准值取值就要随机；

- 快排2.0 ，2.0还是要会做题会用到
- 思路： 和1.0 类似，只不过，把数组分为了小于base,等于base， 大于base，三部分，总体式 左边界left 推着等于区域往右走，右边界不断左扩的过程；
- 步骤： 遍历数组
- 1. [i]<base, [i] 和 left+1(小于区下一个)交换， 小于区右扩， i++
- 2. [i]=== base, 啥也不干，i++
- 3. [i] > base,  [i]和 right-1(大于区前一个)交换， 大于区左扩， i不变

最终版：

```

var sortArray = function(nums) {

    const partition = (nums, l, r) => {
        // 基准值的选取与归位， 此时基准值已经移动到r，比较时要要使用r；
        // 基准值选取时用r - l + 1 是必须得，如果用r-l, 就无法取到r，可能会出现死循环；因为Math.random 生成的随机数： 0<= num < 1;
        const base = l+Math.floor(Math.random()*(r-l+1));
        [nums[base], nums[r]] = [nums[r], nums[base]]

        let left= l-1, 
            right= r, // 比较的右边界从r开始，便于我们处理到数组的末尾；
            i=l;
        // 循环条件是，遇到右边大于区边界停止，不是右边界
        while(i<right){
            if(nums[i]<nums[r]){
                [nums[i], nums[left+1]] = [nums[left+1], nums[i]]
                left++;
                i++;
            }else if(nums[i]=== nums[r]){
                i++
            }else{
                [nums[i], nums[right-1]] = [nums[right-1], nums[i]];
                right--;
            }
        }

        [nums[i], nums[r]] = [nums[r], nums[i]];
        // // 因为left表示左区又边界, 所以这里要left+1，变成等于区第一个元素; 因为right 最后是基准值交换到等于区了，就是等于区的边界，所以不用动；
        // 返回的是等于区的左右边界
        return [left+1, right]
    }


    const quickSort = (nums, l, r) => {
        if(l>=r) return;
        const [left, right] = partition(nums,l, r);
        quickSort(nums, l, left-1);
        quickSort(nums, right+1, r);
    }

    quickSort(nums, 0, nums.length-1)

    return nums;

};



```







快排3.0版目前最快，时间复杂度N*logN, 空间logN,做不到稳定性（相等项相对顺序不变）
归并时间复杂度N*logN, 空间占用O(N), 可以做到稳定;
堆排时间复杂度N*logN， 空间O(1)，做不到稳定性；

想稳定用归并， 想快用快排， 想空间占用少用堆排; 以上说的是大样本量，小样本量的时候，可能n^2算法插入排序更快（比如小于60），工程上可能会把两种算法综合一下；


## mid

### 约瑟夫环

约瑟夫环:已知n个人（以编号1，2，3...n分别表示）围坐在一张圆桌周围。从编号为1的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去

例\:N个人围城一桌（首位相连），约定从1报数，报到数为num的人出局，然后下一位又从1开始报，以此类推。最后留下的人获胜。

ps： 不是很好理解，直接记公式吧： （当前位置+步数-1）%arr.length = 数组循环数组的实际索引
> 也好理解：其实就是，无论你以什么规则去数的，一取余，则又是按照那个规则再一轮所在的位置；

```
const li = ['李一','李二','李三','李四','李五','李六','李七','李八','李九','李十']
const circle = (arr, n) => {
  let count = 0;
  while(arr.length>1){
    const delIndex = (count+n-1)%arr.length; // 需要减一，不然就把索引0跳过了 
    arr.splice(delIndex,1);
    count = delIndex;
  }
  return arr;
}




```
解析queryString
a[name]=fox&a[name[b]]=1&a[company]&b[0]=1&b[1]=2&color=Deep%20Blue

```
简版是有坑的，这个要知道，它不能解析：

> a\[name]=fox\&a\[company]     url标准里这种是要解析成对象的
> a\[0]=1\&a\[1]=2              还可能是数组
> color=Deep%20Blue          空格会被编码，要解码

> 对象和数组最多就一层


const qs = (str) => {
  const res = {};
  const arr = str.split('&');
  
  arr.forEach((s)=>{
    const [key, val] = s.split('=') // 这一步后可以直接赋值，也可以做更深一步的解析
    const [key1, key2] = key.split(/[\[\]]/g).filter(x=>x);
    const newVal = decodeURIComponent(val);
    if(key2){
      if(/\d+/.test(key2)){
        res[key1] = res[key1] || [];
      }else{
        res[key1] = res[key1] || {};
      }
      res[key1][key2] = newVal;
    }else{
      res[key1] = newVal
    }
  })
  return res;
}


```



# 数据结构

## 数组




## 字符串

### 回文字符串

> 利用对称性
> 如何判断自己解决回文类问题的解法是否“高效”？其中一个很重要的标准，就是看你对回文字符串的对称特性利用得是否彻底。
> 关键解法： 对称性 ， 双指针


```
function isPalindrome(str) {
    // 先反转字符串
    const reversedStr = str.split('').reverse().join('')
    // 判断反转前后是否相等
    return reversedStr === str
}

   
function isPalindrome(s, st=0, ed=s.length-1) {
    while(st!=ed) {
        if(s[st] !== s[ed]) {
            return false
        }
        st++
        ed--
    } 
    return true
}

```


2. 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

> 左右指针一起向前推进，比较两轮，第一轮遇到不相等就跳出，分别尝试跳过一次左右指针，看剩下的能不能成为回文字符串


```
const validPalindrome = function(s) {
    // 缓存字符串的长度
    const len = s.length

    // i、j分别为左右指针
    let i=0, j=len-1
    
    // 当左右指针均满足对称时，一起向中间前进
    while(i<j&&s[i]===s[j]) {
        i++ 
        j--
    }
    
    // 尝试判断跳过左指针元素后字符串是否回文
    if(isPalindrome(i+1,j)) {
      return true
    }
    // 尝试判断跳过右指针元素后字符串是否回文
    if(isPalindrome(i,j-1)) {
        return true
    }
    
    // 工具方法，用于判断字符串是否回文
    // st>=ed 就是超出边界了，或者指向同一个字符了，则一定回文
    function isPalindrome(st, ed) {
        while(st<ed) {
            if(s[st] !== s[ed]) {
                return false
            }
            st++
            ed--
        } 
        return true
    }
    
    // 默认返回 false
    return false 
};


```

## 栈

后入先出。栈只有两个操作，push和pop

> 题目中若涉及括号问题，则很有可能和栈相关。
> 栈结构可以帮我们避免重复操作。避免重复操作的秘诀就是及时地将不必要的数据出栈，避免它对我们后续的遍历产生干扰。

- 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。

输入: "([)]"
输出: false
示例 5:
输入: "{[]}"
输出: true

> 我们 push 进去的一定全都是左括号、后期 push 进去的一定全都是右括号，在（头一部分）左括号全部入栈结束时，栈顶的那个左括号，就是第一个需要被配对的左括号

> 此时我们需要判断的是接下来入栈的第一个右括号是否和此时栈顶的左括号配对。如果配对成功，那么这一对括号就是有效的，否则直接 return false。



```
const isValid = function(s) {
  if (!s) {
    return true;
  }
  const leftToRight = {
    "(": ")",
    "[": "]",
    "{": "}"
  };
  const left = ['(', '[', '{']
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    // 缓存单个字符
    const ch = s[i];
    // 判断是否是左括号，这里我为了实现加速，没有用数组的 includes 方法，直接手写判断逻辑
    if (left.includes(ch)) stack.push(leftToRight[ch]);
    // 若不是左括号，则必须是和栈顶的左括号相配对的右括号
    else {
      // 若栈（提前）为空，或栈顶的左括号没有和当前字符匹配上，那么判为无效
      if (!stack.length || stack.pop() !== ch) {
        return false;
      }
    }
  }
  // 若所有的括号都能配对成功，那么最后栈应该是空的
  return !stack.length;
};


```

- 根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

> 一个数组(完整)两层遍历，属于比较少见且高危的操作,可优化
> 尝试去维持一个递减栈， 只要出现了一个数字，它打破了这种单调递减的趋势，也就是说它比前一个温度值高，这时我们就对前后两个温度的索引下标求差，得出前一个温度距离第一次升温的目标差值
> 在这个过程中，我们仅对每一个温度执行最多一次入栈操作、一次出栈操作，整个数组只会被遍历一次，因此时间复杂度就是O(n)。

```
// 入参是温度数组
const dailyTemperatures = function(T) {
    const len = T.length // 缓存数组的长度 
    const stack = [] // 初始化一个栈   
    const res = (new Array(len)).fill(0) //  初始化结果数组，注意数组定长，占位为0, 默认为0别忘了
    for(let i=0;i<len;i++) {
      // 若栈不为0，且存在打破递减趋势的温度值
      while(stack.length && T[i] > T[stack[stack.length-1]]) {
        // 将栈顶温度值对应的索引出栈
        const top = stack.pop()  
        // 计算 当前栈顶温度值与第一个高于它的温度值 的索引差值
        res[top] = i - top 
      }
      // 注意栈里存的不是温度值，而是索引值，这是为了后面方便计算
      stack.push(i)
    }
    // 返回结果数组
    return res 
};

 // 维护从大到小排列的数组，新元素大就开始和栈里元素对比查找，然后再入栈，小就直接入栈。
// 一旦有了异常，新遍历的元素大于栈顶元素，说明能得到（栈里元素对应位置的）至少一个结果，第一个栈顶元素的结果肯定能找到（因为就是以他为判断条件进入的）
// 因为是从小到大排列的，后续栈顶元素的结果，有可能找到， 每次比较栈顶就可以了； 找到结果的就出栈；索引差就是结果；





```


## 队列

先入先出，像排队一样。队列只有两个操作，入队和出队。

在js中需要用到队列的场景需要自己去实现队列，因为队列的入队出队是o(1)的，而数组模仿队列进出push/shift, shift 是o(n)的?

用到队列的地方： 广度优先搜索, 生产者消费者模式, 缓冲区（路由网络，消息等）


- 使用栈实现队列的下列操作

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。

你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。

>  我们用两个栈来做。stack1, stack2, stack2 将stack1中元素翻过来，从stack1进，从stack2出

```

/**
 * 初始化构造函数
 */
const MyQueue = function () {
  // 初始化两个栈
  this.stack1 = [];
  this.stack2 = [];
};

/**
* Push element x to the back of queue.
* @param {number} x
* @return {void}
*/
MyQueue.prototype.push = function (x) {
  // 直接调度数组的 push 方法
  this.stack1.push(x);
};

/**
* Removes the element from in front of queue and returns that element.
* @return {number}
*/
MyQueue.prototype.pop = function () {
  // 关键语句1：  假如 stack2 为空，需要将 stack1 的元素转移进来； stack2 是随时被pop消费的，随时可以会消费完
  if (this.stack2.length <= 0) {
    // 当 stack1 不为空时，出栈
    while (this.stack1.length !== 0) {
      //关键语句2： 将 stack1 出栈的元素推入 stack2； 排队准备出的元素，stack1里就不能再存了； 所以得用pop
      this.stack2.push(this.stack1.pop()); 
    }
  }
  // 为了达到逆序的目的，我们只从 stack2 里出栈元素
  return this.stack2.pop();
};

/**
* Get the front element.
* @return {number}
* 这个方法和 pop 唯一的区别就是没有将定位到的值出栈
*/
MyQueue.prototype.peek = function () {
  if (this.stack2.length <= 0) {
    // 当 stack1 不为空时，出栈
    while (this.stack1.length != 0) {
      // 将 stack1 出栈的元素推入 stack2
      this.stack2.push(this.stack1.pop());
    }
  }
  // 缓存 stack2 的长度
  const stack2Len = this.stack2.length;
  return stack2Len && this.stack2[stack2Len - 1];
};

/**
* Returns whether the queue is empty.
* @return {boolean}
*/
MyQueue.prototype.empty = function () {
  // 若 stack1 和 stack2 均为空，那么队列空
  return !this.stack1.length && !this.stack2.length;
};



```


- 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]

1 [3 -1 -3] 5 3 6 7

1 3 [-1 -3 5] 3 6 7

- 双端队列存储的是数组元素的下标，并且在队列中的元素从队头到队尾是递减的。
- 每次滑动窗口向右移动时：
  - 首先，检查队列队头的元素是否已经超出了滑动窗口的范围，如果超出，则将队头元素出队。
  - 然后，检查新元素是否比队列中已有的元素大，如果是，则将小于新元素的队尾元素出队，保持队列的递减性质。
  - 最后，加入当前元素的下标到队列中。
  - 每次窗口移动后，队列的队头元素就是当前滑动窗口的最大值。

```
var maxSlidingWindow = function(nums, k) {
    const stack = [];  // 递减栈，存储索引
    const res = [];    // 结果数组

    let right = 0;     // 右边界
    let left = -k + 1; // 左边界，初始为负值，统一处理边界

    while (right < nums.length) {
        // 保持栈内索引对应的值递减
        while (nums[right] >= nums[stack[stack.length - 1]]) {
            stack.pop();
        }
        stack.push(right);

        // 当窗口大小达到 k 时，记录最大值
        if (right >= k - 1) {
            res.push(nums[stack[0]]);
        }

        // 移除不在窗口内的元素
        if (left === stack[0]) {
            stack.shift();
        }

        right++;
        left++;
    }
    
    return res;
};


```



## 链表

1.  单向链表

```
1. 表示一个单向链表节点


function  ListNode(key){
    this.key = key;
    this.next =null;
}


创建链表

const node = new ListNode(1)  
node.next = new ListNode(2)

如果要删除node3, 我们直接让它的前驱结点 node1 的 next 指针跳过它、指向 node3 的后继即可, node3 就成为了一个完全不可抵达的结点了，它会被 JS 的垃圾回收器自动回收掉

```

如果要在单项链单向链表中，删除一个节点会比较麻烦，因为要先找到，它的前一个节点，要遍历整个链表去找谁的next指向它，所以通常在链表设计的时候我们通常使用双向链表

2.  双向链表

双向链表节点有两个指针，一个向前（next），一个向后(prev)

```
1. 表示一个双向链表节点

function  ListNode(key){
    this.key = key;
    this.next = null;
    this.prev = null;
}


3. 链表与数组的辨析

链表的访问麻烦

// 记录目标结点的位置
const index = 10  
// 设一个游标指向链表第一个结点，从第一个结点开始遍历
let node = head  
// 反复遍历到第10个结点为止
for(let i=0;i<index&&node;i++) {
    node = node.next
}

链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低


```

## 链表题

- 需要头结点参与处理的链表题，可能需要设一个dummy(虚拟前置头)

### 反转链表

- 直接反转：要把null算进去，开始pre要指向空（null）， 这样反转后最后一个节点才会指向空（也就是说要注意：链表的最后一个结点是指向空,null）
- 从中间开始反转：记录反转前的前置节点p0， 与翻转头节点leftHead， 反转后， pre指向反转这一段的末尾, cur指向反转这一段后续的下一个节点
- 每k个一组反转： 进入循环后，翻转k次，在翻转之后，把前置节点p0更新成下一段要翻转的链表的上一个节点（也就是要更新前置节点p0）, 翻转头节点lefHead也要相应更新
- 无论怎么反转，反转时都要： pre从null开始， cur是当前要反转的节点， 每次进入循环先记录next，然后迭代


1.   反转链表 

```
1. 使用循环， 三指针迭代

// 迭代更新值的顺序是有要求的:先更新不会作为值的元素，然后更新可能作为值的元素


// 这种写法比较正统, 可以像公式一样记住，任何翻转链表都需要这个基础公式

const reverseNode = (node) => {
	let cur = node;
  // 链表的最后一个节点指向null,所以pre为null， pre是个null, 很重要，而不是个node;
	let pre = null; 
  // 已知当前节点为头节点，和前一个节点null；找到下一个节点后，改变当前节点指向，然后继续迭代;
	while(cur){
		let next = cur.next; // 把下一个值记录下来
		cur.next = pre; 
		pre = cur;
		cur = next;
	}
	return pre;
}

```


92. 反转链表 II

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
 

示例 1：


输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
示例 2：

输入：head = [5], left = 1, right = 1
输出：[5]
 

提示：

链表中节点数目为 n
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n

分析：
- 头结点可能发生改变，并且要返回链表，所以需要设置虚拟辅助头节点
- 先找到反转区的前缀节点和后缀节点，然后切断链接，再反转，最后拼接
- 看题解索引从1开始, 

```
var reverseBetween = function(head, left, right) {
  const dummy = new ListNode(-1);
  dummy.next = head;

  let pre = dummy; // 前缀位
  // 看题索引从1开始的，走left-1步，走到前缀位;
  for(let i=1;i<=left-1;i++){
      pre = pre.next;
  }

  let rightNode = pre;
  for(let i=left;i<=right;i++){
      rightNode = rightNode.next;
  }

  const reverseHead = pre.next;
  const suffix = rightNode.next; // 后缀位

  pre.next = null;
  rightNode.next = null;

  const newHead = reverse(reverseHead);

  pre.next = newHead;
  reverseHead.next = suffix;

  return dummy.next;
};


```

1.  判断回文链表

```

var isPalindrome = function(head) {
  // 快慢指针找到中点，反转， 对比， 反转恢复 
  let slow = head;
  let fast = head;
  while(fast.next !== null && fast.next.next !== null){
      slow = slow.next;
      fast = fast.next.next;
  }
  // 从mid下一个开始反转，对比的时候碰到null,就说明对比完成
  const mid = slow;
  const rightHead = reverse(mid.next)
  let res = true;
  let p1 = head;
  let p2 = rightHead;
  while(p1 && p2){
      if(p1.val !== p2.val){
          res = false;
          break;
      }
      p1 = p1.next;
      p2 = p2.next;
  }
  // 这一句赋值要不要都行，因为没有改变mid.next的指针，始终指向后半部分的第一个节点
  // mid.next = reverse(rightHead)
  reverse(rightHead)

  return res;

};


```

25. K 个一组翻转链表

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。


示例 1：


输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
示例 2：



输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
 

提示：
链表中的节点数目为 n
1 <= k <= n <= 5000
0 <= Node.val <= 1000
 

进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？


```
var reverseKGroup = function(head, k) {
    const dummy = new ListNode(-1);
    dummy.next = head;
    let pre = dummy; // 前缀

    let cur = head;
    while(cur){
        // const reverseHead = cur;
        // 为什么外部迭代和内部迭代，用两个不相关的节点表示？1. 内外两个变量容易混淆，反转，链接都用外层变量cur 2. 内存变量tail只用来看够不够k个，以及寻找后缀，切断链接
        let tail = pre; // k个一组翻转，从0开始就是从前置节点开始
        // 在走k步的过程中，如果遇到跌代的inner为空，说明没有inner了，不够k个
        for(let i=0;i<k;i++){
            tail =tail.next;
            if(!tail){
                // 剩余部分不够k个，就无需再继续处理直接返回结果
                return dummy.next
            }
        }
       const suf = tail.next; // 后缀

       // 切断链接
       pre.next = null;
       tail.next = null; 

       const newHead =  reverse(cur) // 反转的头尾， 链接和迭代用翻转的头尾
    
       // 把反转后的链表链接回去
       pre.next =newHead;
       cur.next = suf; 

       // 前缀,与翻转头部指针移动[这一步容易和错用为tail], 这两pre就是翻转后的尾，这个尾用cur表示不够语义化, 而下一个要遍历的就是pre的下一个了
       pre = cur; 
       cur = pre.next;
    }
    
    return dummy.next;
};


```

### 合并有序链表

```
var mergeTwoLists = function(l1, l2) {
    // 声明一个头结点，因为要返回
    const head = new ListNode();
    let cur = head;
    while(l1 && l2){
       if(l1.val<l2.val){
        cur.next = l1;
        l1 = l1.next;
       }else{
        cur.next = l2;
        l2 = l2.next;
       }
       cur = cur.next;
    }
    // 因为是链表, 没有合并完的只需要改一次指针就行了
    if(l1){
        cur.next = l1;
    }

    if(l2){
        cur.next = l2;
    }
    return head.next;
};

```


### 链表快慢指针

876. 链表的中间结点

给你单链表的头结点 head ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 

示例 1：


输入：head = [1,2,3,4,5]
输出：[3,4,5]
解释：链表只有一个中间结点，值为 3 。
示例 2：


输入：head = [1,2,3,4,5,6]
输出：[4,5,6]
解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。
 

提示：

链表的结点数范围是 [1, 100]
1 <= Node.val <= 100


分析：

- 从0（dummy）开始走，无论链表节点是奇数个还是偶数个，当快节点踏空时，slow节点，正好是中间节点

```
var middleNode = function(head) {
    // 不知道快指针具体快多少，但是因为从中间分割，快慢指针正好是2倍的关系，可以慢指针走一步，快指针走两步
    let dummy = new ListNode();
    dummy.next = head;
    let slow = dummy;
    let fast = dummy; // 从零开始上述才成立
    while(fast){
        slow = slow.next;
        fast = fast.next?.next;
    }
    return slow;
};


```


- 给定一个链表，判断链表中是否有环。
> 一个环形链表的基本修养，是能够让遍历它的游标回到原点(环的出发点)
> 我们按照这个思路, 我们可以给节点打flag，也可以使用map缓存 (这个思路比较容易)
> 还有一个公认的比较经典的思路，就是用快慢指针来做,定义慢指针 slow，快指针 fast。两者齐头并进， slow 一次走一步、fast 一次 走两步,这样如果它们是在一个有环的链表里移动，一定有相遇的时刻(快走两圈时，慢走一圈)

```
const hasCycle = function(head) {
    // 只要结点存在，那么就继续遍历
    while(head){
        // 如果 flag 已经立过了，那么说明环存在
        if(head.flag){
            return true;
        }else{
            // 如果 flag 没立过，就立一个 flag 再往
            下走
            head.flag = true;
            head = head.next;
        }
    }
    return false;
};

```

- 给定一个链表，返回链表开始入环的第一个结点。 如果链表无环，则返回 null。(定位环的起点)
> 如果一个结点是环形链表成环的起点，那么它一定是第一个被发现 flag 标志已存在的结点(已经走过的)

```
const detectCycle = function(head) {
    while(head){
        if(head.flag){
            return head;
        }else{
            head.flag = true;
            head = head.next;
        }
    }
    return null;
};


```

143. 重排链表
中等
1.2K
相关企业
给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

示例 1：



输入：head = [1,2,3,4]
输出：[1,4,2,3]
示例 2：



输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
 

提示：

链表的长度范围为 [1, 5 * 104]
1 <= node.val <= 1000


分析： 

- 找中点， 切断， 反转 ， 拼接
- 找中点是从第一个点开始，不是第0个点
- 交错合并不好想，得多练练


```
var reorderList = function(head) {
    // 找中点， 切断， 反转 ， 拼接
    const dummy = new ListNode();
    dummy.next = head;

    // 找中点，开始节点是第一个节点，而不是第0个
    let slow = head;
    let fast = head;
    while(fast.next && fast.next.next){
        slow = slow.next;
        fast = fast.next.next;
    }
    const mid = slow;
    const reverseStart = mid.next;

    mid.next = null;
    const newHead = reverse(reverseStart);

    let left = dummy.next;
    let right = newHead;
    while(right && left){
            // 先记录下一个
           left_next = left.next;
           right_next = right.next;

           // 让左边右边链接起来，要走两步，让其点回到left部分，才好开始下一轮循环
           left.next = right;
           right.next = left_next;

            // 左右各自向前走一步
           left = left_next;
           right = right_next;
    }

    return dummy.next;
};

```

### 链表删除


237. 删除链表中的节点
中等
1.3K
相关企业
有一个单链表的 head，我们想删除它其中的一个节点 node。

给你一个需要删除的节点 node 。你将 无法访问 第一个节点  head。

链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。

删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：

给定节点的值不应该存在于链表中。
链表中的节点数应该减少 1。
node 前面的所有值顺序相同。
node 后面的所有值顺序相同。
自定义测试：

对于输入，你应该提供整个链表 head 和要给出的节点 node。node 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。
我们将构建链表，并将节点传递给你的函数。
输出将是调用你函数后的整个链表。
 

示例 1：


输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9
示例 2：


输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9
 

提示：

链表中节点的数目范围是 [2, 1000]
-1000 <= Node.val <= 1000
链表中每个节点的值都是 唯一 的
需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点


分析：

- 难点： 不让访问head是啥意思？意思是我只能访问到node

```
var deleteNode = function(node) {
    // 难点： 不让访问head是啥意思？意思是我只能访问到node
    // copy 下一个节点的值到node，然后将下一个节点删除
    node.val = node.next.val;
    node.next = node.next.next;
};


```


- 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。


```
const mergeTwoLists = function(l1, l2) {
  // 定义头结点，确保链表可以被访问到
  let head = new ListNode() // 关键语句: 如何表明新链表，新位置
  // cur 这里就是咱们那根“针”
  let cur = head
  // “针”开始在 l1 和 l2 间穿梭了
  while(l1 && l2) { // 关键语句终止条件，l1, 或者l2 有一个到边界就终止，跳出来，让剩下的内容等于未终止的那个链表
      // 如果 l1 的结点值较小
      if(l1.val<=l2.val) {
          // 先串起 l1 的结点
          cur.next = l1
          l1 = l1.next
      } else {
          // l2 较小时，串起 l2 结点
          cur.next = l2
          l2 = l2.next
      }
      
      // “针”在串起一个结点后，也会往前一步
      cur = cur.next 

  }
  
  // 处理链表不等长的情况
  cur.next = l1!==null?l1:l2
  // 关键语句：返回起始结点, 注意起始节点是 head.next
  return head.next;   
};


```

83. 删除排序链表中的重复元素
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

  - 分析：删除后，后面的值仍然与当前cur向等，还需要比较，所以是，如果删除了相等的，就停留在cur；如果不相等就走一步；

```
var deleteDuplicates = function(head) {
    let cur = head;
    while(cur){
        if(cur.val === cur.next?.val){
            cur.next = cur.next?.next;
        }else{
            cur = cur.next;
        }
        // 这里不能直接走,需要判断，有可能删除后，后面的值仍然与当前cur向等，还需要比较，所以是，如果删除了相等的就停留；如果不相等就走；
        // cur = cur.next;
    }
    return head;
};


```

- 给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
> 巧妙地把两个指针之间的差值保持在了“n”上
> 倒数的数和最后一个相差的是 n-1步; 让他们相差n步，那么快的走末尾时，慢的恰好走到 目标节点 的前一个；

```
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode();
    dummy.next = head;
    let slow = dummy;
    let fast = dummy;
    // 倒数的数和最后一个相差的是 n-1步; 让他们相差n步，那么快的走末尾时，慢的恰好走到 目标节点的前一个(倒数第n+1个节点)；
    for(let i=0;i<n;i++){
        fast = fast.next;
    }
    while(fast.next){
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return dummy.next;
};

```





- 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

> 用两个指针分别指向奇数节点和偶数节点, 两指针交替前进即可
> 无论奇数还是偶数改的都是自己的指针，不影响彼此


var oddEvenList = function(head) {
    if (head === null) {
        return head;
    }
    let evenHead = head.next;
    let odd = head, even = evenHead;
    while (even !== null && even.next !== null) { // 关键语句： 判断条件，如果不加Ocur.next， 基数会向前走一步，走到undefined， 后续的连接就失败了
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
};


## 树

“度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。（有几个子节点）

“叶子结点”：叶子结点就是度为0的结点。（没有子节点的）

结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。

树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。




### 二叉树

它可以没有根结点，作为一棵空树存在； 

如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

> 二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的

#### 二叉搜索树

1. 搜索时间和树的高度成比例
2. 任何一个节点，值从小到大为：左子节点，自己， 右子节点

#### 遍历的序

数的遍历有两种方式，深度遍历（深度遍历里有前，中，后三种类型），广度遍历


dfs深度遍历： 用递归; 还可以用迭代；dnf的序，有先中后之分, 用递归简单，用迭代微微有点麻烦。
bfs广度优先遍历： 用队列

```
// 广度遍历
const bfs = (root) => {
  const arr = [root];
  const res = [];
  while(arr.length){
    const cur = arr.shift();
    res.push(cur.val);
    cur.left && arr.push(cur.left)
    cur.right && arr.push(cur.right)
  }
  return res;
}

```




深度遍历：

1. 先序： 自己，左，右
2. 中序： 左，自己， 右
3. 后序： 左，右， 自己

> 先，中， 后之说，总是在说自己的位置，其余位置总是先左，后右

```
// 先序
function preorder(root) {
  if(!root) {
      return 
  }
  console.log('当前遍历的结点值是：', root.val)  
  preorder(root.left)  
  preorder(root.right)
}

// 中序
function preorder(root) {
  if(!root) {
      return 
  }
  
  preorder(root.left)  
  console.log('当前遍历的结点值是：', root.val)  
  preorder(root.right)
}

// 后序
function preorder(root) {
  if(!root) {
      return 
  }
  preorder(root.left)  
  preorder(root.right)
  console.log('当前遍历的结点值是：', root.val)  
}


```

> 用先序来举例： 1. 处理当前节点；2. 搜索当前节点的左子树； 3. 左子树搜索完毕后搜索当前节点的右子树；
> 递归调用无非就是函数帧入栈出栈的过程，因此我们可以直接使用栈来模拟这个过程，只不过栈中保存的不是函数而是树节点。

结论：迭代序用栈实现，后进先出

迭代实现先中后：

统一用栈来处理，就是通过合理地安排入栈和出栈的时机、使栈的出栈序列符合二叉树的前序遍历规则。
跟bfs有点像，只不过bfs是固定的队列解法。
遍历顺序就是结果数组的顺序


先序： 先序先入结果数组，后处理栈里的值，栈里的值先入右，后入左
>将根结点入栈
>取出栈顶结点，将结点值 push 进结果数组
>若栈顶结点有右孩子，则将右孩子入栈
>若栈顶结点有左孩子，则将左孩子入栈

```
const preorderTraversal = function(root) {
  // 定义结果数组
  const res = []  
  // 处理边界条件
  if(!root) {
      return res
  }
  // 初始化栈结构
  const stack = [] 
  // 首先将根结点入栈
  stack.push(root)  
  // 若栈不为空，则重复出栈、入栈操作
  while(stack.length) {
      // 将栈顶结点记为当前结点
      const cur = stack.pop() 
      // 当前结点就是当前子树的根结点，把这个结点放在结果数组的尾部
      res.push(cur.val)
      // 若当前子树根结点有右孩子，则将右孩子入栈
      if(cur.right) {
          stack.push(cur.right)
      }
      // 若当前子树根结点有左孩子，则将左孩子入栈
      if(cur.left) {
          stack.push(cur.left)
      }
  }
  // 返回结果数组
  return res
};
```

后序(逻辑和先序类似)：

后序跟先序类似，有两点不同：1. 进入结果数组的方向相反（用unshift）,确定自己在结果数组最后。
2. 入栈的时候，左右的顺序相反就好了(因为入栈的顺序是反的，进入结果的顺序也是反的，负负得正，能得到从做到右的结果)

```
const postorderTraversal = function(root) {
  // 定义结果数组
  const res = []  
  // 处理边界条件
  if(!root) {
      return res
  }
  // 初始化栈结构
  const stack = [] 
  // 首先将根结点入栈
  stack.push(root)  
  // 若栈不为空，则重复出栈、入栈操作
  while(stack.length) {
      // 将栈顶结点记为当前结点
      const cur = stack.pop() 
      // 当前结点就是当前子树的根结点，把这个结点放在结果数组的头部
      res.unshift(cur.val)
      // 若当前子树根结点有左孩子，则将左孩子入栈
      if(cur.left) {
        stack.push(cur.left)
      }  
      // 若当前子树根结点有右孩子，则将右孩子入栈
      if(cur.right) {
        stack.push(cur.right)
      }
  }
  // 返回结果数组
  return res
};


```

中序： 

- 中序跟前后序不同，在于root节点在循序里入栈
- 理解： 在循环里
  - 1. 左边界入栈： 如果当前节点cur存在，则让当前节点入栈， 并让当前节点等于其左节点
  - 2. 出栈时记录结果，并让出栈元素的右节点等于当前节点cur

```
const inorderTraversal = function(root) {
  // 定义结果数组
  const res = []  
  // 初始化栈结构
  const stack = []   
  // 用一个 cur 结点充当游标
  let cur = root  
  // 当 cur 不为空、或者 stack 不为空时，重复以下逻辑
  while(cur || stack.length) {
      // 这个 while 的作用是把寻找最左叶子结点的过程中，途径的所有结点都记录下来 
      while(cur) { // 关键步骤：1.人字形遍历，边遍历边记录
          // 将途径的结点入栈
          stack.push(cur)  
          // 继续搜索当前结点的左孩子
          cur = cur.left  
      }
      // 取出栈顶元素
      cur = stack.pop()  
      // 既是处理自己,也相当于处理左边
      res.push(cur.val)  
      // 关键步骤： 2. 处理右边，把右边当成根节点进行一次新的处理，如果cur没有就不会走收集步骤，也就不会重复处理;而是处理栈里之前记录的节点; 这里记录的节点，因为总是向左边找，所以既是左节点，又是自己， 按照 左，自己， 那么处理记录的节点其实就是在处理，左，和自己，然后再处理右就行了。
      cur = cur.right
  }
  // 返回结果数组
  return res
};


```


分层遍历: 

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

> bfs 的延升，只不过每次进入循环,只管清空之前的队列，只不过一遍清一遍放，所以要清固定的次数，别清理超出边界了
> 相当于bfs广度遍历，只不过一次处理一定长度的数据（每次进入while循环,记住数组长度len），而不是一次处理一个数据

```
const levelOrder = (root) => {
  const queue = [root];
  const res = [];
  while(queue.length){
    const temp = [];
    const len = queue.length;  // 关键步骤，每次进入while循环,记住数组长度len，然后依次拿出来处理
    let cur;
    
    for(let i=0;i<len;i++){
      cur = queue.shift();
      temp.push(cur.val)
      cur.left && queue.push(cur.left);
      cur.right && queue.push(cur.right);
    }
    res.push(temp);
  }
  return res;
}

```


## 树类题


求一个二叉树从左侧看的轮廓，如图，返回\[1,5, 4,8]?如果求每行的最大值，返回\[1, 9, 7, 8]该如何做？

> 深度遍历树, 对于每一层，我们取第一个找到的值就是左侧看的轮廓

```

const maxAndLeft = (node, leftArr=[], maxArr=[], depth=0) => {
  if(!node) return;
  leftArr[depth] = leftArr[depth] ?? node.value;
  maxArr[depth] > node.value? null: maxArr[depth] = node.value;
  maxAndLeft(node.left, leftArr, maxArr, depth+1);
  maxAndLeft(node.right, leftArr, maxArr, depth+1);
  return {leftArr, maxArr}
}

```

## 求二叉树的最大宽度

```
var widthOfBinaryTree = function(root) {
    if(!root) return 0;

    let queue = [{node: root, index: 0}];
    let max = 0;

    while(queue.length) {
        let level_length = queue.length;
        let min_index = queue[0].index;
        for(let i = 0; i < level_length; i++){
            let {node, index} = queue.shift();
            if(node.left){
                queue.push({node: node.left, index: 2*index});
            }
            if(node.right){
                queue.push({node: node.right, index: 2*index+1});
            }
            if(i === level_length-1) {
                max = Math.max(max, index - min_index + 1);
            }
        }
        // 每一层结束后重新计算索引，做相应偏移
        for(let element of queue){
            element.index -= min_index * 2;
        }
    }
    return max;
}


```

- 找二叉树的后继节点（中序遍历的后一个节点）
  - 亮点在于用pre记录前值

```
var inorderSuccessor = function(root, p) {
    
    let pre = null;
    let res = null;
    const dfs = (root) => {
        if(!root) return;
        if(res) return;
        dfs(root.left);
        if(pre === p){
            res = root;
            // 如果在这里直接返回，就不能改变pre的值了，pre就会不变,导致后面依然能给res 赋值，所以剪枝可以在，base里做，有了res结果就返回就好了； 不能在这里返回
        }
        pre = root;
        dfs(root.right);
    }
    dfs(root);
    return res;
};



```



## 2023， 算法错题集


数组排序与找：

二分查找, 应该用while循环比较好；

冒泡排序第一层的i，与第二层的j的关系，j比i大1，也就是说第一层元素与每一个他后面的元素去比（在它前面的肯定比他小，每次比较都冒到后面去了，一轮正向的排， 每次找出一个最小的值）

插入排序也是两层循环，要处理的位置和值搞清楚, 大了就往后挪一个；

合并排序，所谓合并，先从中间拆开成两半，然后再合并有序数组，递归进行，拆要拆到变成一个元素的数组为止；
关键要注意，传递边界时，left, right, 用左开右闭区间；


快速排序： 一个填空位的游戏， 选好基准值，对撞指针查找，分别和基准值比较，小的排左边，大的排右边
两个指针对撞，从基准值的对面一端（右边）开始移动指针，基准值拿起来就有一个空位;
1. 开始处理这个空位，大于基准值的不动，否则，则填到左边空位上;
2. 右指针走完会有一个空位，开始处理这个空位，走左指针，小于基准值不动，否则，填到右边空位上

错 2次

约瑟夫环： 虚拟索引/arr.length = 数组循环数的实际索引

两数之和： 

三数之和：本质是用遍历，然后对每一个元素，用两数之和的思路，要求数组有序，时间复杂度 o(n2)
1. 每一轮循环，重置j和k 这两个对撞查找指针
2. 得到一个结果后，左右指针，j和k一起前进， 因为当前位置已经记录好了；



链表： 

反转链表：看起来简单，一不注意就错
思路： 三个指针， pre, cur, next, 保存三个值，调转cur的指针，然后继续下一步向前迭代；
关键语句1： 最开始pre要为null, 不能指向head； 这样才能保证反转后，最后一个节点指向的是null, 而不是和倒数第二个节点循环指
关键语句2： 每次都是处理cur的指针， 判断cur是否存在，最终返回上一个节点pre就好了 ; 
错 3次

局部反转： 注意pre  将会是反转后的第一个节点，因为cur还会继续向前迭代； 若是按照索引，则都按索引，若是按照从1开始则都按从1开始； 错1次

奇偶排列： 关键语句： 判断条件要同时判断偶数和偶数的下一个存在，如果不判断偶数的下一个， 基数会向前走一步，走到undefined， 后续的连接就失败了   错 1次

排序链表，删除所有重复的元素： 区分两种情况，重复就删除（删除也相当于向前走了一步），不重复就向前走

两个有序链表合并为一个新的有序链表并返回: 关键语句 1. 如何表明新链表，新位置, new ListNode() 2. 注意返回的起始节点是 dummy.next， 因为是从dummy.next 开始赋值的


树的遍历：

层序遍历：相当于bfs广度遍历，只不过一次处理一定长度的数据（每次进入while循环,记住数组长度len），而不是一次处理一个数据； 错2次


# 基础算法 刷题 源码

### 同向双指针 滑动窗口

典型的滑动窗口思路，窗口扩展时寻找可行解，窗口收缩时优化可行解。

1. 长度最小的子数组


209. 长度最小的子数组（mid）
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：

输入：target = 4, nums = [1,4,4]
输出：1

示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 
 

进阶：

如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。

思路： 1. 遍历到结果满足条件时，固定right,逐步增大left，缩小数组长度,看是否还满足条件（建立一个单调递减的趋势），同时更新结果

```
const minLen = (arr, target) => {
  let minLen = arr.length + 1; //这里如果给成arr.length， 就无法区分出 整个数组长度正好是答案 的情况了
  let s = 0;
  let left = 0;
  for(let right=0;right<arr.length;right++){
    s+= arr[right];
    while(s>=target){
      minLen = Math.min(right-left+1, minLen); // 满足条件直接更新结果，然后逐步尝试减去左节点
      s-=arr[left];
      left++;
    }
  }

  return minLen < arr.length ? minLen : 0;
}


todo: 遗留疑问，为什么套了一个while循环，时间复杂度还是o(n)

```


总结： 双指针的应用场景

- 对于本题而言，在left移动时，子数组的和实在不断变小的，while条件就 从满足要求 不断向 不满足要求 变化，这就是单调性
- 只有满足了单调性，我们才可以使用双指针


1.   乘积小于 K 的子数组
给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。
 

示例 1：

输入：nums = [10,5,2,6], k = 100
输出：8
解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。
示例 2：

输入：nums = [1,2,3], k = 0
输出：0
 
 提示: 

1 <= nums.length <= 3 * 104
1 <= nums[i] <= 1000
0 <= k <= 106



分析： 固定右端点，如果 l 到 r满足条件，那么 l+1,l+2 ... 到r都满足条件（也就是中间的都满足条件），是一个递减的趋势

```

// 推理：固定右端点，如果 l 到 r满足条件，那么 l+1,l+2 ... 到r都满足条件（也就是中间的都满足条件），是一个递减的趋势
const childArrNum = (arr, k) => {
  let s = 1;
  let res = 0;
  let left = 0;
  if(k<=1){
    return 0;
  }
  for(let right=0;right<arr.length;right++){
    s*=arr[right];
    while(s>=k){ // 不满足要求
      s/= arr[left];
      left++;
    }
    res += right - left +1;
  }
  return res;
}

console.log(childArrNum([10,5,2,6], 100));
console.log(childArrNum([1,2,3], 0));


```


3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。


示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
 

提示：

0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成


分析：hash计数，双指针
- hash计数，遍历发现有重复，则开始一次计数，及重置left位置（左边重复项的位置+1）;
  - 固定right, 从left开始逐个排除，直到right不重复，更新结果继续
- 容易错想成遇到重复的就重新计数；因为两个重复元素之间的字符可能有用，所以不能这样搞, 在找到cur重复项及之前的left都要减掉;
  - 关键步骤： 在找到cur重复项及之前的left都要减掉，因为后续又是新的子串，重新计数了

```

const maxLen = (str) => {
  let left = 0;
  let res = 0;
  const hash ={}; // 看到重复想到hash
  for(let right =0;right<str.length;right++){
    const cur = str[right];
    hash[cur]= hash[cur]? hash[cur]+=1:1; // 注意这里是不能用hash[cur]++的, hash[cur]++是没有返回值的
    while(hash[cur]>1){ // 当前元素的重复项计数大于1
      hash[str[left]]--; // 关键步骤： 在找到cur重复项及之前的left都要减掉，因为后续又是新的子串，重新计数了
      left++; // 先处理计数,再移动位置
    }
    res = Math.max(right - left +1, res);
  }
  return  res;
}

console.log(maxLen("abcabcbb"));
console.log(maxLen("bbbbb"));
console.log(maxLen("pwwkew"));


```

### 相向双指针 两数只和，三数之和

1. 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

```

两数之和一般写这个版本就行了，简单，而且和三数只和思路一致：

相比于暴力求解两个for循环： 这里可以用获取多少信息量来衡量一个算法的效率，暴力做法是找两个数加起来和9（target）比一比,那他花费o(1)的时间只得到0(1)的信息； 而优化后的做法，是把当前剩下的最小的数和最大的数加起来和9比一比，比完，之后我就知道其中一个数和其他任何一个数相加都是小于9或者大于9的，这样就花费了0(1)的时间，知道了o(n)的信息，这也就是为什么能从o(n2)优化到o(n)

const sumTwo = (nums,n) => {
  const arr = nums.sort((a,b)=>a-b)
  let i = 0, j = nums.length-1;
  const res = [];
  while(i<j){
    if(arr[i]+arr[j]>n){
      j--
    }else if(arr[i]+arr[j]<n){
      i++
    }else{
      res.push([arr[i],arr[j]])
      i++;
      j--;
    }
  }
  return res;
}


// 另外一个版本，理解起来麻烦点
// 因为是两个数，就算前面没有找到另一半，先记下来，后面也会找到； 所以极致优化，遍历一遍就可以了

const twoSum = function(nums, target) {
  // 这里我用对象来模拟 map 的能力
  const obj = {}
  const res = []
  // 遍历数组
  for(let i=0;i<nums.length;i++) {
      // 判断当前值对应的 target 差值是否存在（是否已遍历过）
      if(obj[target-nums[i]]!== undefined) {
          // 若有对应差值，那么答案get！
          res.push([obj[target - nums[i]], nums[i]])
      }
      // 若没有对应差值，则记录当前值 （关键步骤： 先检查，后记录）
      obj[nums[i]]=nums[i]
  }
  return res;
};

console.log(twoSum([2,3,4,5,6], 9));

```

2. 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

> 双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义
> 大于结果指针王左移，小于结果指针往右移

```
var threeSum = function (nums) {
  const res = []
  nums.sort((a, b) => a - b);
  // 遍历到减3的位置，后面还留两个位置
  for (let i = 0; i <= nums.length - 3; i++) {
    let left = i + 1;
    let right = nums.length - 1;
    // i 不是从第一就开始检查，所以要大于0；保证把第一次遇到的符合条件的值放入结果
    if (i > 0 && nums[i] == nums[i - 1]) {
      continue;
    }
    while (left < right) {
      const tempRes = nums[left] + nums[right] + nums[i]
      if (tempRes < 0) {
        left++;
      } else if (tempRes > 0) {
        right--;
      } else {
        res.push([nums[i], nums[left], nums[right]])
        left++;
        right--;
        // 等于之后才开始检查，保证把第一次遇到的符合条件的值放入结果
        while (left < right && nums[left] === nums[left - 1]) {
          left++;
          continue;
        }
        while (left < right && nums[right] === nums[right + 1]) {
          right--;
          continue;
        }
      }
    }
  }
  return res;
};

```



1.  盛最多水的容器
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

 

示例 1：

详见： https://leetcode.cn/problems/container-with-most-water/

输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例 2：

输入：height = [1,1]
输出：1
 

提示：

n == height.length
2 <= n <= 105
0 <= height[i] <= 104


分析： 

- 分类讨论一下，随便选两条线，高的为A, 矮的为B，它们所能承接的水高度是由矮的B决定的，以矮线B做参照，如果矮线B和A,B间 任意比B更矮的线组合，那么高度缩小，宽度缩小，明显容量更新，如果选比矮B更高的线，那么高度不变（高度依然矮线决定），宽度变小，那么容量依然会缩小；于是，可以得出结论， 任意两条线之间的最大容量=宽度*矮线高度， 也就是说中间的任何线都无法和矮线构成一个容量更大的容器了，如果想要容量更大，肯定不包括矮线，因此可以直接去掉矮线（移动指针），向中间找，缩小范围
- 初始化两个指针，指向l=0, r=len-1, 记录容积，谁小，就移动谁，直至重合


```
var maxArea = function(height) {
    let l = 0;
    let r = height.length -1;
    let res = 0;
    while(l<r){
        const cur = (r-l)*Math.min(height[r], height[l]);
        res = Math.max(res, cur)
        if(height[r]<height[l]){
            r--;
        }else if(height[r]>height[l]){
            l++;
        }else{
            r--;
            l++;
        }
    }
    return res;
};


```


42. 接雨水(困难)

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

示例 1：



输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
示例 2：

输入：height = [4,2,0,3,2,5]
输出：9
 

提示：

n == height.length
1 <= n <= 2 * 104
0 <= height[i] <= 105



分析：

- 可以把没一个格（每一个x坐标点）看做一个桶，桶的水面高，由桶左边的最高板，与右边的最高板共同决定
- 从左遍历，记录每个坐标对应的左板最高；从右遍历记录每个坐标对应的右板最高；
- 遍历数组，每个坐标位置，左板高度与右板高度比较矮的那个，减去坐标位置的高度，就是水实际高度，将其加起来就是了 

```
var trap = function(height) {
 let pre=[];
 let preMax = 0;
 for(let i=0;i<height.length;i++){
     preMax = Math.max(preMax, height[i])
     pre[i] = preMax;
 }

 let suf = [];
 let sufMax = 0;
 for(let j=height.length-1;j>=0;j--){
     sufMax =  Math.max(sufMax, height[j])
     suf[j] = sufMax;
 }

 let res =0;
 for(let k=0;k<height.length;k++){
     const h = Math.min(suf[k], pre[k]);
     res += h-height[k];
 }
 return res;
};


```

这个算法，时间复杂度是o(n)，已经优化到极致了，空间复杂度是o(n)还可以再优化一下：

- 定义l, r指针， 对于任意个x坐标的位置，如果它的蓄水高度是由 左右板 矮的那个决定的，那么一旦知道了那边板矮，那个这个位置的水高气势就出来了
- 矮板那边的水高出来，继续移动矮板那边，直到重合


```
var trap = function(height) {
 let l = 0;
 let r = height.length -1;
 let preMax = 0;
 let sufMax = 0;
 let res = 0;
 while(l<=r){
    preMax = Math.max(preMax, height[l]);
    sufMax = Math.max(sufMax, height[r]);
    if(preMax<sufMax){ // 左边小时，左边的能算出来
        res += preMax - height[l++];
    }else{
        res += sufMax - height[r--];
    }
 }
 return res;
};

```

### 数学表达式

224. 基本计算器(困难)
     
给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。

 

示例 1：

输入：s = "1 + 1"
输出：2
示例 2：

输入：s = " 2-1 + 2 "
输出：3
示例 3：

输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23
 

提示：

1 <= s.length <= 3 * 105
s 由数字、'+'、'-'、'('、')'、和 ' ' 组成
s 表示一个有效的表达式
'+' 不能用作一元运算(例如， "+1" 和 "+(2 + 3)" 无效)
'-' 可以用作一元运算(即 "-1" 和 "-(2 + 3)" 是有效的)
输入中不存在两个连续的操作符
每个数字和运行的计算将适合于一个有符号的 32位 整数


分析： 
- 关键点在下面第2步，解析如下：

sign = ops[ops.length - 1] ==> 1*ops[ops.length - 1]
sign = - ops[ops.length - 1] ===> -1*  ops[ops.length - 1]

- 1. 用栈记录括号外的那个符号，遇到"(", 开始入栈，记符号
- 2. 当前符号(+ 或者 -) 与 括号外的符号（ops[ops.length - 1]）相乘，此时得到真正的符号， 无论此符号是否在括号里面；（有点乘法分配律的意思）
- 3. 获取到当前数字，添加符号，然后和之前的结果相加


```

var calculate = function(s) {
  const ops = [1]; // 栈
  let sign = 1; // 当前符号放在栈顶，sign 包括，'+', '-', 也就是要记录每一个数字前的符号，默认为 '+' 正，也就是1；

  let ret = 0;
  const n = s.length;
  let i=0;
  while(i<n){
      if(s[i]===' '){ // 遇到空格，不做操作继续走
          i++;
      } else if(s[i] === '+'){ // 遇到加号，通过栈顶元素获取当前符号
          sign = ops[ops.length - 1];   // 关键语句， 想象 ops[ops.length - 1 的含义是，括号外那一层的符号， 就是 1*ops[ops.length - 1]
          i++;
      } else if(s[i] === '-'){ // 遇到减号，遇到减号 通过将栈顶元素 - 一下获取当前符
          sign = - ops[ops.length - 1]; // 关键语句， -1*  ops[ops.length - 1]， 当前符号与括号外的符号相乘等到，无论是否有括号的真正的符号结果
          i++;
      } else if(s[i] === '('){ // 遇到左括号, 把上一个记录的sign（正负号） 放到ops栈里
          ops.push(sign); 
          i++
      } else if(s[i]===')'){ // 遇到了右括号, 则取出一个记录的sign,并且')'不入栈
          ops.pop();
          i++;
      } else { // 遇到数字开始计算，给数字添加正负： （正负号） * 数字,然后和之前的结果相加
          let num = 0;
          // 当前项是数字， 处理多位数字， 每多一个位就乘以10，然后加当然数
          // 因为不允许使用将eval
          while(i<n && !(isNaN(Number(s[i]))) && s[i] !== ' '){
              num = num * 10 + Number(s[i]);
              i++;
          }
          ret += sign * num;
      }
  }
  return ret;
};

```

150. 逆波兰表达式求值
给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

注意：

有效的算符为 '+'、'-'、'*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示。
 

示例 1：

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
 

提示：

1 <= tokens.length <= 104
tokens[i] 是一个算符（"+"、"-"、"*" 或 "/"），或是在范围 [-200, 200] 内的一个整数


分析： 
- 1. 如果遇到符号就从从栈里取出两个数和符号运算，将计算结果入栈
- 2. 如果遇到数字，就入栈


```
var evalRPN = function(tokens) {
    let i = 0;
    let cur = tokens[i];
    const stack = []
    let num1, num2,res;
    while(cur){
        if(!isNaN(Number(cur))){
            stack.push(Number(cur))
        }else{
            num1 = stack.pop();
            num2 = stack.pop();
            //  难点语句： 
            // 1. 如果是除， 有可能大于0，还有可能小于0 （因为要求向0截断，也就是只保留整数部分，所以得分情况处理）
            // 2. eval处理不了,2--3这种带负号的，所以不能用eval, 每个运算符得单独处理
            if(cur==='+'){
                res = num2 + num1;
            }else if(cur === '-'){
                res = num2 - num1;
            }else if(cur === '*'){
                res = num2 * num1;
            } else if(cur === '/'){
                res = num2/num1;
                res = res > 0? Math.floor(res): Math.ceil(res);
            }
            stack.push(res);
        }
        cur = tokens[++i];
    }
    return stack[0];
};


```


### 二分查找

- 二分查找的精髓在于一次排除（丢弃）一半数据，大幅缩小答案所在的范围
- 一般二分循环结束后，左边界就是答案（结束时，左右要么相等，要么有边界比左边界小）

34. 在排序数组中查找元素的第一个和最后一个位置
中等
2.4K
相关企业
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

 

示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
示例 3：

输入：nums = [], target = 0
输出：[-1,-1]
 

提示：

0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums 是一个非递减数组
-109 <= target <= 109


分析：


- 两遍二分就好,一遍找最大的，一遍找最小的; 找到了就更新结果;
- 找小的，找到后，继续尝试往左找; 找到后，继续尝试往右找

```
var searchRange = function(nums, target) {
    // 两遍二分就好,一遍找最大的，一遍找最小的; 找到了就更新结果;
    let start = -1;
    let end = -1;
    const lower = (arr, tar, isLower) => {
        let l = 0;
        let r = arr.length -1;
        let mid;
        while(l<=r){
            mid = Math.floor((l+r)/2);
            if(arr[mid]>tar){
                r = mid-1;
            }else if(arr[mid] === tar){
                // 找小的，继续尝试往左找; 找大的，继续尝试往右找
                if(isLower){
                    start = mid;
                    r = mid - 1
                }else{
                    end = mid;
                    l = mid + 1
                }
            }else{
               l = mid + 1; 
            }
        }
        return isLower? start : end;
    }

    start = lower(nums, target, true);
    end = lower(nums, target, false);
    return [start, end]
};


```

162. 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

 

示例 1：

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
示例 2：

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。


提示：

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
对于所有有效的 i 都有 nums[i] != nums[i + 1]


分析： 
- 注意题目中保证了， 相邻两个元素不相等了
- 判断条件结束条件时，l和r能不能相等,因为是和mid和mid+1比，所以不能相等
- 结束时l会和r相等，不是峰值的都被排除掉


```

var findPeakElement = function(nums) {
    let l = 0;
    let r = nums.length -1;
    let mid;
    // 因为假设两边是负无穷的，所以峰值，要么在最左边（递减），要么在最右边（递增），要么在数组中
    // 难点在于：1. l和r能不能相等,因为是和mid和mid+1比，所以不能相等 2. 怎么返回结果，结束时l会和r相等，不是峰值的都被排除掉了
    while(l<r){
        mid = Math.floor((l+r)/2);
        // 注意题目中保证了，相邻两个元素不相等了
        if(nums[mid]<nums[mid+1]){ // 说明右边有峰值
            l = mid +1
        }else{
            r = mid;
        }
    }

    return l;
};


```

153. 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

 

示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
示例 2：

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
示例 3：

输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
 

提示：

n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
nums 中的所有整数 互不相同
nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转


分析:

- 旋转后,变成两段升序数组，且第一个数大于最后一个数
- 需要一个方式，判断nums[mid]是在最小值的左边，还是右边; 可以用nums[mid]和最后一个数（n-1）比较大小
- 关键点： 开始查找， 情况一： 如果nums[mid]小于最后一个数， 那么有两种情况： 1. 它在一段递增数组中 2. 它在第二段递增数组中，无论是哪种情况，这个元素要么是最小值， 要么在最小值右侧（染色法标记为蓝色）； 情况二： nums[mid]大于最后一个数，那么它只可能在二段递增数组的第一段，那么最小值一定在递增数组的第二段；


```
var findMin = function(nums) {
    let l = 0;
    let r = nums.length-1; // 最后一个数，要么是最小值，要么在最小值右侧，蓝色;
    let mid;
    // 每一次，mid和每一个区间的最后一个数比，因为都是相同的结构
    // 因为是递增的，一旦nums[mid]等于nums[r]，说明mid，l, r三个值相等了，也就跳出了
    while(l<r){ 
       mid = Math.floor((l+r)/2);
       if(nums[mid]>nums[r]){ // nums[mid]在二段递增数组，第一段， 最小值在mid右侧，蓝色
            l = mid +1;
       }else{ // 如果是一段递增数组里，最小值在mid位置，或者左侧，如果是二段递增数组，mid在第二段，最小值在第二段的mid位置，或者mid左侧，红色
            r = mid;
       }
    }
    // 最后l和r相等会跳出循环
    return nums[l];
};


```

33. 搜索旋转排序数组
    
整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

 

示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1
 

提示：

1 <= nums.length <= 5000
-104 <= nums[i] <= 104
nums 中的每个值都 独一无二
题目数据保证 nums 在预先未知的某个下标上进行了旋转
-104 <= target <= 104


分析：

- 判断一mid为分界点，左右数组那边有序(利用数组，旋转后有两个升序片段这个特性去思考判断，与右端点比较就好了)
- 里有有序区间判断target是在有序区间，还是在无序区间，缩小范围；然后进行下一轮


```
var search = function(nums, target) {
    let l = 0;// 左闭右闭
    let r = nums.length -1;
    let mid;
    // 旋转后， 把数组从mid分分割开就会一段有序，一段无序
    while(l<=r){ 
        mid = Math.floor((l+r)/2);
        if(nums[mid]===target) return mid;
        // 1. 判断mid做一下边数组属性，是有序还是无序， 只有知道了那边有序，才能确定target范围
        if(nums[mid]>nums[r]){ // l到mid有序； nums[mid] 大于等于0， mid只能在两个升序片段的第一段(或者一段升序里)， 并且以mid为分割点，左边有序，右边无序
           // 2. 根据有序区间确定target范围，不在有序区间，就在无序区间
           if(target>=nums[l] && target<nums[mid]){ // 在有序区间
                r = mid -1;
           }else{ // 在无序区间
                l = mid+1;
           }
        }else{ // mid+1 到 r有序；
            if(target>nums[mid] && target<=nums[r]){ // 在有序区间
                l = mid +1;
            }else{ // 在无序区间
                r = mid -1;
            }
        }
    }
    return -1;
};


```

### 递归

- 解法思路了看，最开始递归理解

104. 二叉树的最大深度
简单
1.6K
相关企业
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。

```
var maxDepth = function(root) {
    // 原问题： 树的深度，等于子树的结果深度+1，子问题类似
    // 边界条件，没有节点了就返回路径最后一层的结果
    if(!root){
        return 0;
    }
    const leftDept = 1 + maxDepth(root.left);
    const rightDept = 1 + maxDepth(root.right);

    return Math.max(leftDept, rightDept)
};


```

10.01. 合并排序的数组

给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 m 和 n。

示例:

输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
说明:

A.length == n + m

```
var merge = function(A, m, B, n) {
   const res = [];
   let a = 0;
   let b = 0;
   let k = 0;
   while(a<m || b<n){ // 关键要判断数组A和B,超出长度的做法，也就是a===m, 或者 b===n时要单独处理一下，然后再套公式；
       if(a===m){
           res[k++] = B[b++];
       }else if(b===n){
           res[k++] = A[a++];
       }else{
           res[k++] = A[a]<B[b] ? A[a++]: B[b++];
       }
   }

   for(let i=0;i<res.length;i++){
       A[i] = res[i]
   }
    
    return A;
}


```

### 二维表格遍历

dfs的核心点： 1. 终止条件  2. 访问相邻节点

表格的遍历多了一点：避免重复

通用思路： 遍历所有格子（节点），开始遇到1（岛）则计算（遇水则过），而后开始沿着四个方向递归寻找，遇到岛则标记为2，表示遍历过，直到边界。


二维表格遍历，岛屿类问题，类似于二叉树的遍历：
- 解题思路是遇到1（岛屿）就开始计算
- 有上下左右四个方向（相邻节点）
- 避免重复的方法是做标记，走过的岛屿陆地标记为2


200. 岛屿数量（中等）
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
示例 2：

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3



```
var numIslands = function(grid) {
    count = 0;
    // 遍历每个格子
    for(let r=0;r<grid.length;r++){
        for(let c=0;c<grid[0].length;c++){
            if(grid[r][c] == 1){
                count++;
                dfs(grid, r,c)
            }
        }
    }
    return count
   
};

var dfs = (grid, r=0, c=0) => {
    // 终止条件：出了格子， 或者遇到不是 1（岛屿的都返回）
    if(r<0 || r>=grid.length || c>=grid[0].length || c<0 || grid?.[r]?.[c] != 1){
        return;
    }
    // 走过的岛屿陆地标记为2，避免重复走
    grid[r][c] = 2
    // 从上下左右四个方向（相邻节点）继续找
    dfs(grid, r+1, c);
    dfs(grid, r-1, c);
    dfs(grid, r, c+1);
    dfs(grid, r, c-1);
}


```

类似的岛屿的题核心解题思路相同，还有：

岛屿最大面积：每次进入dfs处理后，可以加1，更新max
岛屿周长: 其实就是求岛屿的边界， 每次遇到边界（出格子，或者遇到水就加1）
最大人工岛（造一格岛连接能形成的最大面积）: 先遍历一遍求出所有的岛屿面积，用序号做上标记，并且用一个对象记录对应序号（岛屿）的面积；然后再遍历一遍，求出填充每一格水所能形成的最大面积


- 463.   岛屿周长

 有个回溯注意一下： 上一个结果，等于下一个结果加起来

```
var islandPerimeter = function(grid) {
    let count = 0;
    for(let r=0;r<grid.length;r++){
        for(let c=0;c<grid[0].length;c++){
            if(grid[r][c] === 1){
                count = dfs(grid, r, c)
            }
        }
    }
    return count;
};

var dfs = (grid, r, c) =>{
    if(r<0 || r>=grid.length || c<0 || c>=grid[0].length || grid[r][c]===0 ){
        return 1
    }
    if(grid[r][c] === 2){
        return 0;
    }
    if(grid[r][c] === 1){
        grid[r][c] = 2
    }

    // 回溯： 当前结果，等于下一个结果加起来
    return dfs(grid, r+1, c) 
    + dfs(grid, r-1, c) 
    + dfs(grid, r, c+1) 
    + dfs(grid, r, c-1)
}



```

- 695. 岛屿的最大面积

难点在于结果的收集： 把中途操作计数改成，下一层的结果计数(下一层结果返回)，这样就能用结果收集

```
var maxAreaOfIsland = function(grid) {
    let res = 0
    for(let r=0;r<grid.length;r++){
        for(let c=0;c<grid[0].length;c++){
            if(grid[r][c] === 1){
                const count = dfs(grid, r, c)
                res = Math.max(count,res)
            }
        }
    }
    return res;
};

// 如果传递一个给函数普通变量，那么函数内部改这个变量改的就是值了，跟原来的变量就没有关系了
// 把中途操作计数改成，下一层的结果计数(下一层结果返回)，这样就能用结果收集
var dfs = (grid, r, c) => {
    if(r<0 || r>=grid.length || c<0 || c>=grid[r].length || grid[r][c]!==1){
        return 0;
    }
    grid[r][c] =2

    return 1+ dfs(grid, r+1, c)
    + dfs(grid, r-1, c)
    + dfs(grid, r, c+1)
    + dfs(grid, r, c-1)
}


```


1991. 找到数组的中间位置
提示
简单
71
相关企业
给你一个下标从 0 开始的整数数组 nums ，请你找到 最左边 的中间位置 middleIndex （也就是所有可能中间位置下标最小的一个）。

中间位置 middleIndex 是满足 nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1] 的数组下标。

如果 middleIndex == 0 ，左边部分的和定义为 0 。类似的，如果 middleIndex == nums.length - 1 ，右边部分的和定义为 0 。

请你返回满足上述条件 最左边 的 middleIndex ，如果不存在这样的中间位置，请你返回 -1 。


- 求和转求差


```
//   把求和转换为求差问题会变的简单一点
// 每遍历一项就表示，它为中间值的时候
var findMiddleIndex = function(nums) {
    const sum = nums.reduce((pre, cur)=>pre+cur,0);
    let left = 0;
    for(let i=0;i<nums.length;i++){
        if(i===0){ //  i为0的时候，左边之前的和为0，i就是中间值
           left = 0;
        }else{
           left = nums[i-1] + left;
        }
        right = sum - left - nums[i];
        if(left === right){
            return i
        }
    }
    return -1;
};



```


51. N皇后
    
```

var solveNQueens = function(n) {
    const res = [];
    const colObj = {};
    const d1 = {};
    const d2 = {};

    const check = (row, col, colObj, d1, d2) =>{
        if(colObj[col] || d1[row-col] || d2[row+col]){
                return false
            }
        return true;
    }

    const dfs = (row,  colObj, d1, d2, path) =>{
        if(row>=n) return res.push([...path]);

        for(let col=0;col<n;col++){
            if(check(row, col, colObj, d1, d2)){
                colObj[col] = true;
                d1[row-col] = true;
                d2[row+col] = true;
                path.push(col)
                dfs(row+1,  colObj, d1, d2, path)
                path.pop();
                colObj[col] = false;
                d1[row-col] = false;
                d2[row+col] = false;
                
            }
        }

    }
    dfs(0,  colObj, d1, d2, [])

    const strRes = res.map(col=>{
        return col.map(item=>{
            return '.'.repeat(item) + 'Q' + '.'.repeat(n-item-1)
        })
    })

    return strRes;
};



```

- 22. 括号生成

```
var generateParenthesis = function(n) {
    const res = [];
    
    const backtrack = (left, right, path) => {
        // 当左右括号都用完时，添加路径到结果集
        if (left === n && right === n) {
            res.push(path);
            return;
        }

        // 如果左括号未用完，可以放置左括号
        if (left < n) {
            backtrack(left + 1, right, path + '(');
        }
        
        // 如果右括号数量小于左括号数量，可以放置右括号
        if (right < left) {
            backtrack(left, right + 1, path + ')');
        }
    };
    
    // 从初始状态开始
    backtrack(0, 0, '');
    
    return res;
};


```


- 437. 路径总和 III

```

const dfsRoot = (root, targetSum) => {
    if(!root) return 0;
    let temp = 0
    // 虽然找到一个，但是不能保证后续相加没有符合条件的答案，比如后续和为0
    if(root.val === targetSum){
        temp = 1;
    }
    return temp+ dfsRoot(root.left, targetSum-root.val) + dfsRoot(root.right, targetSum-root.val)
}


var pathSum = function(root, targetSum) {
     if(!root) return null;
    let res = 0;
    // dfs计算每个节点的路径
    res += dfsRoot(root, targetSum)
    // path 遍历每一个节点
    res += pathSum(root.left, targetSum);
    res += pathSum(root.right, targetSum)
    return res;
};



```

```

var pathSum = function(root, targetSum) {
    const map ={0: 1};
    let count = 0;

    const dfs = (root, targetSum, res=0) =>{
        if(!root) return null;
        const key = res + root.val - targetSum;
        if(map[key]>0){
            count += map[key];
        }
        const sumKey = res + root.val;
        map[sumKey] = (map[sumKey] || 0) + 1;
        dfs(root.left, targetSum, sumKey);
        dfs(root.right, targetSum, sumKey);

        map[sumKey] -= 1;
    }
    dfs(root, targetSum, 0);
    return count;
};



```

- 79. 单词搜索

  给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。


```

var exist = function(board, word) {

    const dfs = (i,j, index) =>{
        // 说明找到了最后，单词的所有字母已经找完，没有被提前终止
        if(index === word.length) return true;
        // 超过边界，说明这一个分支就不行
        // 当前四个方向节点判断是不是和单词的当前字母相等不好判断，但是在下一轮递归里，判断当前节点和单词字母是不是相等就很好判断；所以说在递归里，一次只需要处理一个节点
        if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j] !== word[index] ) return false;

        // 染色，避免重复遍历
        const temp = board[i][j];
        board[i][j] = '#'


        const found =  dfs(i, j-1, index+1) || 
        dfs(i, j+1, index+1) ||
        dfs(i+1, j, index+1) || 
        dfs(i-1, j, index+1)

        board[i][j] = temp;

        return found;
    }


    for(let i=0;i<board.length;i++){
        for(let j=0;j<board[0].length;j++){
            // 从索引0开始找
            if(board[i][j]=== word[0] && dfs(i,j, 0)){
                return true;
            }
        }
    }
    return false;

};



```

1.   分割回文串



```
var partition = function(s) {
    const res =[];

    const isValid = (str) => {
        let i=0, j= str.length-1;
        let is = true;
        while(i<=j){
            if(str[i]!== str[j]){
                is = false;
            }
            i++;
            j--;
        }
        return is;
    }


    const dfs = (startIndex, path) =>{
        if(startIndex === s.length) return res.push(path);

        for(let i = startIndex; i<s.length;i++){
            const pathStr = s.slice(startIndex, i+1);
            if(isValid(pathStr)){
               // 注意下一次递归的起始，是当前的截止位置+1,也就是i+1, 不是startIndex+1
               dfs(i+1, path.concat(pathStr))
            }else{
                continue;
            }
        } 
    }
    dfs(0, []);

    return res;
};


```


- 153. 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```

var findMin = function(nums) {
    let left = 0, right = nums.length -1;
    while(left<right){
        const mid = Math.floor((left+right)/2);
        if(nums[mid]>nums[right]){
            left = mid+1;
        }else{// mid <= right 的情况
            right = mid;
        }
    }
    return nums[right];
};



```


- 215. 数组中的第K个最大元素

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。


```
var findKthLargest = function(nums, k) {

    const partition = (nums, l, r) => {
        // 基准值的选取与归位， 此时基准值已经移动到r，比较时要要使用r；
        // 基准值选取时用r - l + 1 是必须的；如果用r-l, 就无法取到r，可能会出现死循环；因为Math.random 生成的随机数： 0<= num < 1;
        const base = l+Math.floor(Math.random()*(r-l+1));
        [nums[base], nums[r]] = [nums[r], nums[base]]

        let left= l-1, 
            right= r, // 比较的右边界从r开始，便于我们处理到数组的末尾；
            i=l;
        // 循环条件是，遇到右边大于区边界停止，不是右边界
        while(i<right){
            if(nums[i]>nums[r]){
                [nums[i], nums[left+1]] = [nums[left+1], nums[i]]
                left++;
                i++;
            }else if(nums[i]=== nums[r]){
                i++
            }else{
                [nums[i], nums[right-1]] = [nums[right-1], nums[i]];
                right--;
            }
        }

        [nums[i], nums[r]] = [nums[r], nums[i]];
        // 要注意这里返回的是等于区的左右边界
        return [left+1, right]
    }


    const quickSort = (nums, l, r, k) => {
        if(l===r) return  nums[l];
        if(l>r) return nums[r];
        const [left, right] = partition(nums,l, r, k);

        // 最关键的一句，卡了大半天， 因为返回的是等于区的左右边界，所以必须 k >=  <=, 关键的= 不能漏掉了；
        if(k>= left && k <= right ){
            return nums[k]
        }else if(k<left){
            return quickSort(nums, l, left-1, k);
        }else {
            return quickSort(nums, right+1, r, k);
        }
    }
    // 把k的第几大，转换为索引 k-1
    return quickSort(nums, 0, nums.length-1, k-1)
};



```



- 347.   前 K 个高频元素

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。


```

var topKFrequent = function(nums, k) {
   const map = {};
   nums.forEach(item => {
       map[item] = (map[item] || 0) + 1;
   });

   // [num, count]
   const arr = Object.entries(map);

   const partition = (arr, l, r) => {
       const base = arr[r][1];
       let left = l - 1;

       for (let i = l; i < r; i++) { //1. 易错点1： 只遍历 l 到 r-1 的元素
           if (arr[i][1] > base) {
               left++;
               [arr[i], arr[left]] = [arr[left], arr[i]];
           }
       }
       [arr[r], arr[left + 1]] = [arr[left + 1], arr[r]];
       return left + 1;
   };

   const quickSelect = (arr, k, l, r) => {
       // l<r 才有必要继续排序，否则本次排序完成，因为要求的最终结果是比 某一个值大的一部分 数据，直接在数组上处理了，所以并不需要返回
       if (l < r) {
           const pivotIndex = partition(arr, l, r);

           if (k === pivotIndex) {
               return;
           } else if (k < pivotIndex) {
               quickSelect(arr, k, l, pivotIndex - 1);
           } else {
               quickSelect(arr, k, pivotIndex + 1, r);
           }
       }
   };

   // 2. 易错点2， 注意初始传递的是处理后的数组arr， 不是nums； 不熟悉的时候，写着写着就容易懵
   quickSelect(arr, k, 0, arr.length - 1);

   return arr.slice(0, k).map(item => item[0]);
};


```

- 31. 下一个排列

```
var nextPermutation = function(nums) {
    let start = -1;
    const n = nums.length;

    // 找升序起始点；
    for (let i = n - 1; i > 0; i--) {
        if (nums[i - 1] < nums[i]) {
            start = i - 1;
            // 易错点1： 找到及时跳出
            break;
        }
    }

    // 易错点2： 有start才需要找, 找大区里最小的
    if (start >= 0) {
        
        let end = n - 1;
        for (let j = n - 1; j > start; j--) {
            if (nums[j] > nums[start]) {
                end = j;
                break;
            }
        }
        [nums[start], nums[end]] = [nums[end], nums[start]];
    }

    // start 后逆序
    let left = start + 1;
    let right = n - 1;
    while (left < right) {
        [nums[left], nums[right]] = [nums[right], nums[left]];
        left++;
        right--;
    }

    return nums;
};



```

- 287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

```
var findDuplicate = function(nums) {
    let low = 1, high = nums.length-1; // 数据搜索范围
    while(low<high){
        const mid = Math.floor((low+high)/2);
        let count = 0;
        for(let i=0;i<nums.length;i++){
            if(nums[i]<=mid){
                count++;
            }
        }
        // 小于等于mid的个数，如果大于mid
        if(count > mid){
            high = mid;
        }else{
            low = mid+1;
        }
    }
    return low;
};


```


- 198. 打家劫舍

```
var rob = function(nums) {
    if (nums.length === 0) return 0;
    if (nums.length === 1) return nums[0];
    
    let prev2 = nums[0]; // dp[i-2]
    let prev1 = Math.max(nums[0], nums[1]); // dp[i-1]

    for (let i = 2; i < nums.length; i++) {
        let curr = Math.max(prev1, prev2 + nums[i]); // dp[i]
        prev2 = prev1; // 更新 dp[i-2]
        prev1 = curr; // 更新 dp[i-1]
    }

    return prev1;
};

```

- 322. 零钱兑换

```
var coinChange = function(coins, amount) {
   // 初始化表, 因为有值为0的，位置所以需要+1
   const dp = new Array(amount+1).fill(Infinity);

   dp[0] = 0;
   for(let i=1;i<=amount;i++){
    for(let j=0;j<coins.length;j++){
        // i - coins[j] 可能为负啊， 怎么处理呢， 也就是dp表里可能没有；并且硬币可以重复拿，这个又该怎么表示呢?
        // 所以要加一个判断条件，不为负，才需要计算，dp[i]位置才可能有值
        if(i-coins[j]>=0){
            dp[i] = Math.min(dp[i], dp[i-coins[j]]+1)
        }
        
    }
   }
   return dp[amount] === Infinity ? -1: dp[amount]
};


```
- 279. 完全平方数

```
var numSquares = function(n) {
    const dp = new Array(n + 1).fill(Infinity);
    dp[0] = 0; // 初始化，凑成0需要0个数

    for (let i = 1; i <= n; i++) {
        // 难点：面值的限制条件是j*j<=i;
        for (let j = 1; j * j <= i; j++) {
            // 难点2： 递推公式： dp[i - j * j] + 1， 必须和 dp[i], 比较一下，因为dp[i - j * j] 这个值可能会被多次更新，
            // 比如对于12， 第一次更新 8+4, 后续还可能更新 11 + 1, 要保证最优性；
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }
    return dp[n];
};


```


- 139. 单词拆分

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```
var wordBreak = function(s, wordDict) {
   const dp = new Array(s.length + 1).fill(false);
   dp[0] = true;  // 空字符串可以被视为已经成功匹配

   for (let i = 1; i <= s.length; i++) {
       for (let j = 0; j < i; j++) {
           const sub = s.slice(j, i);
           if (dp[j] && wordDict.includes(sub)) {
               dp[i] = true;
               break;  // 一旦找到一个匹配的组合，立即停止当前循环
           }
       }
   }

   return dp[s.length];
};


```

- 300. 最长递增子序列
  
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的
子序列
。



```
var lengthOfLIS = function(nums) {
    const dp = new Array(nums.length).fill(1);
    let max = 1;
    
    for (let i = 1; i < nums.length; i++) {
        let maxLength = 1;
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                maxLength = Math.max(maxLength, dp[j] + 1);
            }
        }
        dp[i] = maxLength;
        max = Math.max(max, dp[i]);
    }
    
    return max;
};


```
- 152. 乘积最大子数组

```

var maxProduct = function(nums) {
    const dp_min = [nums[0]], dp_max = [nums[0]];
    let max = nums[0];

    for(let i=1;i<nums.length;i++){
        dp_min[i] = Math.min(nums[i], nums[i]*dp_min[i-1], nums[i]*dp_max[i-1]);
        dp_max[i] = Math.max(nums[i], nums[i]*dp_min[i-1], nums[i]*dp_max[i-1]);
        max = Math.max(dp_max[i],max)
    }

    return max;
};


```

- 416. 分割等和子集
  

```
  
  var canPartition = function(nums) {
    const sum = nums.reduce((pre,cur)=> pre +cur, 0);
    if(sum%2 !== 0) {
        return false;
    }
    const target = sum/2;
    const dp = new Array(target+1).fill(false);
    dp[0] = true;
    for(let num of nums){
        // 因为num，本身肯定可以生成num，填上num位置的dp表格，所以不能先填num,否则2倍的num, 3倍的num都能一次生成的，会多次重复使用num， 所以要从后往前填；
        for(let i= target;i>=num;i--){
            dp[i] = dp[i-num] || dp[i];
        }
    }

    return dp[target]
};

```


- 32. 最长有效括号

```

var longestValidParentheses = function(s) {
    let left = 0, right = 0, maxLen = 0;
    
    // 从左到右扫描
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            left++;
        } else {
            right++;
        }
        
        if (left === right) {
            maxLen = Math.max(maxLen, 2 * right);
        } else if (right > left) {
            left = right = 0;
        }
    }
    
    // 从右到左扫描
    left = right = 0;
    for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] === '(') {
            left++;
        } else {
            right++;
        }
        
        if (left === right) {
            maxLen = Math.max(maxLen, 2 * left);
        } else if (left > right) {
            left = right = 0;
        }
    }
    
    return maxLen;
};




```
- 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的 
回文
 
子串
。

```

var longestPalindrome = function(s) {

    if(s.length<2) return s;
    let max = 1;

    const check = (i, j) => {
        while(s[i] === s[j] && i>=0 && j<s.length){
            i--;
            j++;
        }
        const len = (j-1) - (i+1) +1;
        return len
    }

    let start=0, end=0;
    for(let k=0;k<s.length;k++){
        const len1 = check(k,k);
        const len2 = check(k, k+1);

        const maxLen = Math.max(len1, len2)
        if(maxLen > max){
            start = k- Math.floor((maxLen-1)/2);
            end = start + maxLen -1;
            max  = maxLen;
        }
    }
    return s.slice(start, end+1)
};



```

- 1143. 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

```
var longestCommonSubsequence = function(text1, text2) {
    // dp表格多一个空字符的初始化， 而字符串正常处理
    const dp = new Array(text1.length+1).fill(0).map(()=>new Array(text2.length+1).fill(0));

    for(let i=1;i<dp.length;i++){
        for(let j=1;j<dp[0].length;j++){
            if(text1[i-1] === text2[j-1]){
                dp[i][j] = dp[i-1][j-1] + 1;
            }else{
                dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j])
            }
        }
    }
    return dp[text1.length][text2.length]
};



```


- 72. 编辑距离

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

```

var minDistance = function(word1, word2) {
    const dp = new Array(word1.length+1).fill(0).map(() => new Array(word2.length+1).fill(0));

    // 初始化 dp 表格第一列
    for (let i = 0; i < dp.length; i++) {
        dp[i][0] = i; // 从 word1 的前 i 个字符转换为一个空字符串需要 i 次删除操作
    }

    // 初始化 dp 表格第一行
    for (let j = 0; j < dp[0].length; j++) {
        dp[0][j] = j; // 从空字符串转换为 word2 的前 j 个字符需要 j 次插入操作
    }

    // 填充 dp 表格
    for (let i = 1; i < dp.length; i++) {
        for (let j = 1; j < dp[0].length; j++) {
            if (word1[i-1] === word2[j-1]) {
                dp[i][j] = dp[i-1][j-1]; // 字符相同，无需额外操作
            } else {
                dp[i][j] = Math.min(
                    dp[i][j-1] + 1,   // 插入操作
                    dp[i-1][j] + 1,   // 删除操作
                    dp[i-1][j-1] + 1  // 替换操作
                );
            }
        }
    }

    return dp[word1.length][word2.length];
};





```

- 114. 二叉树展开为链表

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

```
var flatten = function(root) {
    if (!root) return;

    // 递归展开左子树和右子树
    flatten(root.left);
    flatten(root.right);

    // 将左子树移到右子树的位置
    let left = root.left;
    let right = root.right;
    root.left = null;
    root.right = left;

    // 找到右子树的新位置
    let current = root;
    while (current.right !== null) {
        current = current.right;
    }

    // 将原右子树接到右子树的最右边节点后面
    current.right = right;
};


```

- 105. 从前序与中序遍历序列构造二叉树

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

```
 // 开始：初始值先序和中序的数组都是同一个，是一样的
var buildTree = function(preorder, inorder, preorder_l=0, preorder_r=preorder.length-1, inorder_l=0, inorder_r=inorder.length-1) {
    console.log(preorder_l, preorder_r)
    if((preorder_l > preorder_r)) return null;

    const root = new TreeNode(preorder[preorder_l]);

    const rootIndex = inorder.findIndex(item=>item==root.val);
    if(rootIndex<0) return null;
    // 左树节点个数： 中序索引 - 中序左边界
    const leftSize = rootIndex - inorder_l;
    
    
    // 左树
    root.left = buildTree(preorder, inorder, preorder_l+1, preorder_l+leftSize, inorder_l, rootIndex-1)
    // 右树
    root.right = buildTree(preorder, inorder, preorder_l+leftSize+1, preorder_r, rootIndex+1, inorder_r)
    return root;
};


```

437. 路径总和 III


给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

```

var pathSum = function(root, targetSum) {
    const map = {0: 1}; // 初始化哈希表，表示从根节点到当前节点的路径和为0的次数为1
    let count = 0; // 记录满足条件的路径数量

    const dfs = (node, targetSum, currentSum) => {
        if (!node) return; // 基本情况：如果节点为空，返回

        currentSum += node.val; // 更新当前路径和
        // 检查当前路径和减去目标和是否在哈希表中出现
        count += map[currentSum - targetSum] || 0;

        // 将当前路径和加入哈希表
        map[currentSum] = (map[currentSum] || 0) + 1;
        
        // 递归遍历左右子树
        dfs(node.left, targetSum, currentSum);
        dfs(node.right, targetSum, currentSum);

        // 回溯：将当前路径和从哈希表中移除，确保不会影响其他路径
        map[currentSum] -= 1;
    }

    dfs(root, targetSum, 0); // 从根节点开始DFS遍历
    return count;
};




```

- 160. 相交链表

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：注意，函数返回结果后，链表必须 保持其原始结构 。

```

var getIntersectionNode = function(headA, headB) {
    if (!headA || !headB) return null;

    let pA = headA;
    let pB = headB;

    while (pA !== pB) {
        pA = pA ? pA.next : headB; // 当 pA 到达链表末尾时，跳到 headB
        pB = pB ? pB.next : headA; // 当 pB 到达链表末尾时，跳到 headA
    }

    return pA; // pA 或 pB 会指向相交节点，或最终都为 null
};



```
- 76. 最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。



```

var minWindow = function(s, t) {
    let left = 0, right = 0, curLeft=0, curRight=0,min=Infinity;
    let valid = 0;  // 找满字符的次数
    const tMap = {};
    for(let i=0;i<t.length;i++){
        const item = t[i];
        tMap[item] = tMap[item]? tMap[item]+1 : 1;
    }

    
    const window = {}
    // 右边界右移，扩大窗口
    while(right<s.length){
        const cur = s[right];
        window[cur] = window[cur] ? window[cur]+1 : 1;
        if (window[cur] === tMap[cur]) valid++;
        // 字符找满，并且不越界
        while(valid===Object.keys(tMap).length && left<=right){
            const temp = right - left +1;

            // 更新最小值
            if(temp<min){
                min = temp;
                curLeft = left;
                curRight = right;
            }

            // 左边界向右移动，缩小窗口
            if (window[s[left]] === tMap[s[left]]) valid--;
            window[s[left]]--;
            left++;
        }
        right++;
    }
    return min === Infinity ? "" : s.slice(curLeft, curRight+1);
};



```

- 3. 无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长 
子串
 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。


```

var lengthOfLongestSubstring = function(s) {
    let left = 0, right = 0;
    let window = new Set(); // 存储窗口内的字符
    let bestResult = 0;

    while (right < s.length) {
        // 尝试扩大窗口
        if (!window.has(s[right])) {
            window.add(s[right]);
            bestResult = Math.max(bestResult, right - left + 1);
            right++;
        } else {
            // 缩小窗口直到没有重复字符
            window.delete(s[left]);
            left++;
        }
    }

    return bestResult;
};


```
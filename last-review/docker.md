# docker

docker解决的问题：

在运维部署过程中出现部署环境和开发环境（版本，配置）不一致的问题。

docker理解：
- 解决了*运行环境和配置问题*的的*软件容器*，方便做持续集成并助力于整体发布的的容器化虚拟技术
  - docker依赖于宿主内核,制造出一个隔离的文件环境，因此它的运行效率几乎等同于主机
- Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。

容器与虚拟机的区别：
- 虚拟机技术是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上再运行所需的应用程序
- 容器内的应用进程*直接运行于宿主的内核*，容器内没有自己的内核*且也没有进行硬件虚拟*，因此容器要比虚拟机技术更为轻便
- 每个容器之间相互隔离，每个容器有自己的文件系统，容器之间的进程不会相互影响， 去区分计算资源


docker 理解：
  - 搭建、发送、运行
  - 搭建一次，到处能用
    - 系统平滑移植，容器虚拟化技术
    - 将应用打包成镜像，通过镜像成为运行在docker容器上面的实例，而docker容器在任何操作系统上都是一致的，这就实现了跨平台，跨服务器，只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。

Docker技术的三大核心概念：
- docker: 容器运行载体，容器管理引擎
- *镜像（image）*： 把应用程序和配置依赖打包好形成一个可以交付的运行环境，这个打包好的运行环境就是image镜像文件。image可以看成是容器的模版。
- *容器(container)*：通过镜像来生成docker容器实例(仅包含业务运行所需的runtime环境，也就是最核心的系统内核文件和业务环境文件，不需要的不加载)
- 仓库(repository)： 存储docker 镜像的， 我们可以把镜像发布到仓库中，需要的时候再从仓库中拉取就好了


如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。于是K8S出现了；
  
K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。

一个K8S系统，通常称为一个K8S集群（Cluster）。
- 一个Master节点（主节点）
- 一群Node节点（计算节点）


## 镜像，容器

通过镜像，创建docker 容器；

镜像：Docker 镜像可以被看作是轻量级的、可执行的独立软件包，它包含运行某个软件所需要的所有内容，包括代码、运行时环境、库、环境变量和配置文件等


docker 容器可以看做是一个简易版的linux 环境；

> 虽然 Docker 容器在设计时是基于 Linux 内核的，但是通过特定的工具，比如 Docker Desktop for Mac，它也可以在 Mac 上运行。Docker Desktop for Mac 使用的是一个轻量级的虚拟机（HyperKit），在这个虚拟机中运行着 Docker Engine 和 Linux 内核。因此，你在 Mac 上运行的 Docker 容器实际上是运行在这个虚拟机中的.虽然 Docker 容器本身是共享宿主机内核的，但是在这种情况下，"宿主机"实际上指的是运行 Docker Engine 和 Linux 的这个轻量级虚拟机，而不是 Mac 本身。


## 镜像的原理

  镜像加载原理:
  - Docker 镜像的加载（也就是运行镜像创建容器的过程）是基于联合文件系统（UnionFS）的层叠和写时复制（Copy-On-Write）原理的。
  - 在运行 Docker 镜像时，Docker 会按照镜像的层级顺序，从底层到上层依次加载每一层镜像。这些镜像层会叠加在一起，形成一个统一的文件系统。
  - 当所有的镜像层全部加载完毕后，Docker 会在最顶层添加一个可写层，这个可写层也就是容器层。容器层是唯一一个可以进行写操作的层级，它上面的所有改变（例如修改已存在的文件或创建新的文件等）都在这一层完成。这就是写时复制（Copy-On-Write）策略的体现，只有当需要修改文件时，才会将文件从底层复制到容器层进行修改，而底层的镜像文件始终保持不变。




  - 镜像的分层: 简单理解： 通过支持扩展现有镜像，创建新的镜像。类似一种继承关系，继承一个基础类，扩展自己的功能，新镜像就是从基础镜像一层一层叠加生成的。每安装一个软件就在现有镜像的基础上增加一层。
    - Docker 镜像的分层是 Docker 架构的核心特征之一
      - 镜像分层最大的好处就是： 共享资源， 方便复制迁移， 就是为了复用。
        - 比如说多个镜像都从相同的base镜像构建而来， 那么docker host 只需要在磁盘上保存一份base镜像。同时内存中也加载一份base镜像
      - 每一层都是只读的：一旦文件层被创建，就不能修改它
      - 镜像层的堆叠： 当你运行一个 Docker 镜像（即启动 Docker 容器）时，Docker 会堆叠镜像的所有分层，并在最顶部添加一个可读写的层，也就是容器层
      - 层的重用： 同一台 Docker 主机上的多个容器可以共享同一个原始镜像的层
    - 当你修改镜像（例如更新代码或安装新的软件包）时，Docker 不需要复制整个镜像，而只是添加或更新那些更改了的层，这让构建、推送和拉取镜像更加快速和高效
  - 联合文件系统
    - UnionFS 的主要特点是能将多个不同位置、不同物理设备的目录挂载（mount）到同一个虚拟文件系统上
## 镜像仓库

官方是docker hub, 不过因为墙的关系，国内一般用阿里云的镜像仓库


## docker 的工作原理

docker 是一个client-server 结构的系统， docker 守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令，并管理运行在主机上的容器；容器，是一个运行时环境。

## 为什么docker 比虚拟机快

- 1. docker 有着比虚拟机更少的抽象层
  - docker 不需要像虚拟机那样实现硬件资源虚拟化，docker 直接用的就是物理机的硬件资源
- 2. docker 利用宿主机的内核，不需要加载操作系统os内核


## 环境配置

按官网操作就行，在linux平台安装docker 引擎；（现在新版已经不需要再去换源搞东搞西, 也可能是开了魔法的原因）


## docker run 做了什么

docker 在本机中寻找该镜像：
  - 1. 如果找到，就以该镜像为模版生产容器实例运行；
  - 2. 如果找不到就去Docker hub上去查找该镜像， 下载该镜像到本地， 然后一该镜像为模版生产容器实例运行
    - 如果找不到返回失败错误；

## docker 常用命令

- docker run [options] 镜像
  - -it:启动交互式容器：前台有伪终端，等待交互
  - --name: 给容器命名
  - -p: 指定端口映射,小写p
    - -p hostPort:containerPort   主机端口映射:容器内端口映射
  - -P: 随机端口映射，大写P
  - -d: 后台运行容器，并返回容器id
  - 端口映射 (-p) 等配置*只能在 docker run 命令时*进行设置。这些配置不能在容器已经创建之后再更改；如果需要更改需要把当前容器存为镜像，再重新run;

- 重要说明： Docker 容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命令（比如：top, tail），就是会自动退出的； 也就是说有些镜像最好就用-it运行容器，否则启动后会直接退出的；一般项redis，mysql这种才让它后台启动；
  - 这是docker机制的问题， 
  - 解决方案就是启动交互式容器，表示后续还有交互操作


- docker ps
  - -a 所有的容器，包括已经停止的
  - -n + 数字，显示几个容器
  - -q 只显示容器id

- 进入容器：
  - docker exec -it 容器id /bash/bin
    - exec 是在容器中打开新的终端， 并且可以启动新的进程， 用exit 退出，不会导致容器停止
    - 一般就用这个进入
  - docker attach 容器id
    - attach 直接进入容器启动命令的终端， 不会启动新的进程，用exit 退出，会导致容器停止

- 退出容器
  - exit: run进入容器，exit退出容器, 并停止容器
  - ctrl + p + q : run进入容器,ctrl + p + q 退出， 容器不会停止

- docker start  容器id或者容器名: 启动已经停止的容器

- docker rm 容器id或者容器名: 删除已经停止的容器
  


举例： 

```
docker run -it centos:7 /bin/bash


/bin/bash: 放在镜像后的是命令，这里我们希望有一个交互式的shell, 因此用的是/bin/bash
```


- docker logs 容器id
  - 查看容器日志


- 镜像：

  - docker images: 查看本地镜像

  - docker pull: 拉取镜像

  - docker search: 查询远程仓库是否有某个镜像

  - docker system df: 插件镜像，容器，数据卷所占空间

  - docker rmi xx : 删除镜像


- 文档：

  - docker 命令 --help


- docker top  容器id
  - 命令用于实时显示系统中各个进程的资源占用状况，如 CPU 占用率，内存使用量等


- 备份容器里的内容：docker cp 容器id:容器内路径 目标主机路径
  - 把容器里的主要内容复制一份到主机备份

- 容器备份

- docker export 容器id>文件名.tar
  - export 导出容器内容作为一个tar归档文件
- cat 文件名.tar | docker import - 镜像用户/镜像名：镜像版本号
  - import 从tar包中的内容创建一个新的文件系统再导入为镜像

  - >
    - 在 Linux 命令中，">" 符号被用作重定向操作符，它的功能是将命令的输出（例如，某个命令打印在终端的结果）重定向到文件中
    - 如果 filelist.txt 文件在操作前已经存在，那么这个操作会直接覆盖原有内容。如果你希望保留文件原有内容，只是在末尾追加新的输出结果，你可以使用 ">>" 符号
  - |
    - 在 Linux 中，"|" 符号被称为管道（pipe），它被用来将一个命令的输出作为下一个命令的输入。
  - '-'
    - "-" 符号可以表示标准输入或输出, 上面例子里："-" 符号表示 docker import 命令应该从标准输入(stdin)读取内容


- docker commit -m="提交的描述信息" -a="作者" 容器id 要创建的目标镜像名:标签名
  - 提交容器副本将其变成新的镜像(直接把容器变成镜像)


## 虚悬镜像

- 仓库名，标签名都是 none 的镜像， dangling image
  - 这种镜像建议删除， 是一个失去了与本地镜像列表的关联并变得无用的镜像
  - 这通常发生在你构建了一个新的镜像，而新的镜像使用的是和旧镜像相同的标签（比如使用相同的名字和版本号），这时旧的镜像就会变成虚悬镜像。



## 仓库

- 1. 可以推到阿里云的镜像仓库
- 2. 可以建一个私有仓库
  - 1. 下载镜像docker registry
  - 2. 运行私有库registry, 相当于本地有个私有docker hub
  - 3. curl 验证私服库上有什么镜像
    - curl -XGET http://192.168.124.10:5000/v2/_catalog
  - 4. 案例演示： 创建一个新镜像， ubuntu 安装ifconfig命令； 将新镜像ubuntu:1.2修改符合私服规范的tag
    - docker tag ifubuntu:1.2 192.168.124.10:5000/ifubuntu:1.2 【把镜像克隆一份并改个名】
  - 5. 修改配置文件使之支持http
  - 6. push推送到私服库
  - 7. curl 验证私服库上有什么镜像
  - 8. pull到本地并运行


docker run -d -p 5000:5000 -v ~/myregistry/:/tmp/registry --privileged=true registry



## Docker Compose 


Docker Compose 是一个用于在单个主机上定义和运行多容器 Docker 应用程序的工具.它使用 YAML 文件来配置应用程序的服务，然后使用一个命令就可以将所有这些服务创建并启动起来。


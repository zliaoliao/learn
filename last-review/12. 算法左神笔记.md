# 左神的讲解笔记

做一个备忘，参考，一般不用看；


- 2. 递归时间复杂度计算，master公式，合并排序（又叫外排序，需要用到额外数组），快排(小区边界是l-1)
- 快排
  - 小区边界是l-1
  - 默认快排的算法复杂度与数据情况有关，可能达到n^2, 所以对比数据必须是数组处理范围内随机出来的：Math.random()*(r-l+1)+l，然后换到右边的
  - 如果没有规定排序算法，可以考虑就用归并排序
- 合并排序极其变体
  - 合并排序
    - 易错点：因为中点取了floor左边的，已经取小了，左边范围已经小了，所以在求解的时候就让左边范围尽量大一些，才能平衡，*l~mid, mid+1~r*, 才合理; 而不能写成左边是 l~mid-1;
    - `sort(nums, l, mid);sort(nums, mid+1, r); ` 
  - 变体
   - 1. 求小和问题（无序数组，求每一个比右边的数小的数的和）
     - 转换为算对于每一项，有多少个右边的数比他大，每有一个数比这一项大，这一项就要加一次
     - 整体与合并排序步骤相同，唯一不同的，是限制左边必须小于右边才能计算并放入外部数组，等于的时候得放入右边的(计算小和与放入外部数组可以分成两步来做)
     - 因为左右数组都是排好序的，对于左边的每一项来说，只要放入外部数组，就说明，右边数组里的剩余项都比他大
  - 2. 求逆序对，求数组中每一个右边的数大的数，并成对打印他们； 解法逻辑同上;

## 链表

- 3. 链表（链表一般是根据数据结构，纯coding,很少涉及到算法）:
  - 规律：
    - 额外的数据结构记录（栈，队列，数组）;快慢指针; 
    - *除了基本的翻转链表，其他能设虚拟节点的先设虚拟节点*，能省很多麻烦
      - 如果链表需要返回(或者头结点可能发生改变),则需要声明一个头节点head做辅助，最后返回头节点的next, head.next
      - 从虚拟节点,开始走 left-1步，走到前缀位, 也就是i=1; i<=left;
    - 从头节点开始，慢走一步，快走两步，出循环时，慢正好在中点位置，也要记住
  - 1. 反转链表 【6】
    - 已知当前点，上一个点;当前点找到下一个节点后，调整当前next的方向,然后向前迭代,当前点为空时跳出）
    - 迭代更新值的顺序是有要求的，先更新不会作为值的元素，然后更新可能作为值的元素
  - 2. 打印两个有序链表的公共部分，合并有序链表 【5】
    - 类似有序数组的merge, 需要声明一个头节点, 因为是链表，遍历完一个直接改指针即可，无需继续遍历）
  - 3. 回文链表  【5】
    - （需要找到中点，用快慢指针 + 栈存贮，快指针一次走两步，慢指针一次一步，快指针走完，慢指针刚好走一半，然后后半部分入栈; 进阶空间o(1)的解法, 遍历两边，一遍找到中点反转后一半链表，一遍对比同时，恢复原状）
    - 1. 注意判断条件，要保证fast指针不踏空, 快指针走两步,所以为条件为fast.next !== null && fast.next.next !== null; 此时慢指针正好在奇数中点，或者偶数的前一个点（也当成中点）；
    - 2. 在中点的下一个点开始反转，把反转链表提出去封装一下，因为要用两次
    - 3. 对比的时候碰到null,就说明对比完成
    - 4. 因为中点的next指针始终没变，所以后面直接传入右边头结点反转即可，无需再次赋值（当然赋值也行）
  - 4. 指定区域反转  【2】
    - 1. 设置虚拟头节点
    - 2. 反转前切断前后链接
  - 5. k 个一组翻转链表
    - 为什么外部迭代和内部迭代，用两个不相关的变量表示？1. 内外用一个变量容易混淆，反转，链接都用外层变量cur 2. 内存变量tail只用来看够不够k个，以及寻找后缀，切断链接
    - 迭代， 看够不够k个， 不够就返回; 够就 记录后缀, 切断前后链接，然后翻转，再链接
      - 在走k步的过程中，如果遇到跌代的tail为空，说明没有tail了，不够k个,直接返回
    - 前缀，后缀， 反转头，反转尾
  - 6. 重排链表
    - 合并时：记录下一个节点；让左边右边链接起来，要走两步，让其点回到left部分，才好开始下一轮循环； 然后左右各自向
    - 合并一般两种方法： 1. 两只脚交替往前走，你连我，我连你, 然后各自向前走，出循环就连好了  2. 有一个变量穿针引线
    - 前走一步
    - 从头节点开始，慢走一步，快走两步，出循环时，慢正好在中点位置，也要记住
  - 7. 删除节点node，却不给head
    - 调换指针和val: 直接把node后一个节点值拷贝过来，然后改next; 
  - 8. 删除重复节点
    - 如果和下一个相同，next就跨过下一个
    - 和下一个相同时， cur指针不能移动，因为后面可能继续相同

## 递归,二叉树

二叉树规律：
- 1. 递归序: 
  - 任何一个节点都能触达自己三次： 分别是，第一次进入函数，左树返回，右树返回
  - 递归序将代码 以  f(left) 和 f(right) 两个分隔点（左右树），分成三块区域: 分别代表触达当前节点的三次机会
- 2. 递归套路：能解决一切面试中树形动态规划类问题，也是面试中二叉树最难的一类题目（遇到二叉树不会的，就用这个套路，面试很好用）
  - 当在求解一个二叉树问题的时候： 我去列可能性的时候，怎么列可能性？
    - 假设我可以向我的左树要信息，可以向我的右树要信息，怎么把这道题解决（用黑盒拿到想要的信息，加工成最终信息）
    - 根据左右信息，罗列满足题目要求的可能性 （这个可能性不一定好想，是这个套路最难的部分）
      - 左右得满足什么条件
      - 左右得关系是怎样的
  - 写代码： 
    - base case
    - 左树返回什么信息（假设的黑盒）
    - 右树返回什么信息 (假设黑盒)
    - 节点自己返回什么信息 （拆黑盒：处理黑盒里的逻辑）
      - 因为是递归，处理逻辑得一样（左右需要的信息，都给出来，也就是求并集）



二叉树题型：

- 1. 遍历 

  - 递归序与二叉树的先，中， 后序遍历紧密相关
    - 先序（头左右）：先序遍历也是二叉树的深度优先遍历。 递归：第一次触发节点就打印
      - 迭代实现：
        - 一上来，先把根节点入栈，然后走固定流程
          - 1. 每次在栈中弹出一个节点记为cur
          - 2. 打印（处理）cur
          - 3. 先右后左入栈（如果有) 【因为先要遍历左右，所以左边后入栈】
          - 4. 只要栈不空，继续循环
    - 中序（左头右）： 递归： 第二次触达节点打印
      - 迭代：
      - 建一个空栈，然后走固定流程（中序，和先后序不一样，初始化栈时root不能放到栈里）
        - 1. 遇到一个子树，先把整个子树左边界全压到栈里（顺着left指针往下走的路径叫左边界， 自己也是左边界，所以自己也要入栈）
        - 2. 在弹出每一个节点的过程中：
          -  打印 
          -  然后对它的右树，做同样动作: left赋值为右树（右树左边界入栈, 没有右树就意味着没有压栈操作，只有在每一轮循环中的弹出）
        - 3. 只要栈不空或left有值，继续循环
      - 中序迭代原理： 任何二叉树，都可被左边界分解掉(也就是左边界的路径，能够依次遍历到所有节点),只不过把右树的左边界处理顺序放后面； 叶子节点左边界就是他自己;
    - 后序（左右头）： 递归： 第三次触发节点打印
      - 迭代： 
      - 参考先序: 头左右，调整入栈顺序，变为:头右左，处理的时候放到push辅助数组，最后统一反过来打印就是了
      - 一上来，先把根节点入栈，然后走固定流程（变形）
      - 1. 栈里弹出cur
      - 2. 把cur放入辅助数组
      - 3. 先左后右入栈 （和先序入栈顺序反过来）
      - 4. 栈不为空继续循环
- 广度优先遍历
  - 广度优先用队列
  - 一上来先把根节点放入队列，然后走固定流程
    -  一个弹出来时打印cur
    -  （将弹出节点的左右孩子）先左后右入队（出的时候就也是先左后右了）
    -  只要队列不空，继续循环


- 分层遍历
  - 本质是广度优先遍历
  - 每次进入循环，队列里都是要处理的当前层，根据个数将当前层清空
  - 清空时，每弹出一个，就把它的左右节点放入栈里
  - 只要队列不空，继续循环
- 求二叉树节点个数最多的一层，及个数（有的叫宽度）
  - 宽度（广度）优先遍历的变形
  - 因为宽度优先是一层一层走的，所以可以记录层数与每层节点个数
    -  入队时记录节点所在层数
    -  弹出时开始记录当前统计层的节点个数
    - 当前层不等于统计层（初始为1），说明进入了下一层，可以结算节点个数，随着遍历更新最大值
- 求二叉树最大宽度（结构类似满二叉树，但是中间会有空值）
  - 满二叉树： 当根节点的索引从1算起，层序遍历，那么树中任何一个节点的为x的话，其左孩子索引为2x, 其右孩子索引为2x+1
  - 这个题有个针对对js的难点: 考虑到节点过多，数值可能会溢出，超出js能表达的范围，索引加入数组的，索引减去数组中的最小索引，让索引在一行内保持相对位置不变（或加入数组后统一处理）
  - 同一个位置存值和索引，可以考虑用map，而不是用两个数组，代码会简明一些
  - 层序遍历个过程中:
    - 把对应节点的索引加入到辅助数组
    - 遍历完一层计算宽度：每一层宽度，终点索引-起点索引+1，即为宽度
    - 更新最大宽度


- 2. 二叉树相关概念及判断
  - 判断是否是搜索二叉树
    - 概念： 搜索二叉树的每节点，都比他左孩子大，比右孩子小
    - 用中序遍历，遍历的结果升序的:
      - 记录之前的值
      - 每一次遍历的值，都要比之前的值大，更新之前的值； 如果比之前小就不是;
      - 递归的代码处理逻辑（处理比较和记录值），放到中序原本应该打印的区域
  - 判断是否是完全二叉树
    - 概念： 1. 叶子节点只可能出现在最下面两层中 2. 最底层叶子节点都依次排列在该层最左边的位置上
    - 广度优先遍历
    - 1. 遇到任何一个节点，有右无左，即不是
    - 2. 在违反1的情况下，如果第一次遇到了左右孩子不双全的情况，那么接下来遇到的所有节点，都应该是叶子节点（无孩子）才是，否则就不是
  - 判断是否是满二叉树
    - 概念： 每一层都是满的，叶子节点全部在最底层; 高度k, 节点个数等于： (2^k)-1 
  - 判断是否是平衡二叉树
    - 概念： 每一个节点，左子树和右子树的高度不超过1
    - 列可能性
      - 左树，和右树都是平衡树
      - 左右树高度相差不超过1


- 两个节点n1,n2的最近公共祖先
  - 容易理解的版本（代码多点，但是好理解）
    - 每个节点的父节点用map记录, n1,n2 节点必然也会在这个map里
    - 迭代遍历n1 的父节点， 放入set（n1自己也要放进去）
    - 迭代遍历n2 的父节点， 在set里找， 找到的就是公共节点
  - 优化后的代码（抽象一点，可以用套路）: 当找到含有指定节点的左右子树后都回溯当前节点，那么当前节点就是要找的节点
    - base case: cur 为n1 或 n2，则返回cur, 否则返回 null
    - 在第三次触达当前节点时（回溯），收集左右树的信息: 左右都不为空返回cur, 左右有一个空则返回有值的那个结果
      - 有一个子树返回为空，则说明在同一颗子树上

- 找后继节点， 在每个节点都有指向父节点的指针时，能不能让找后继节点的速度快一些
  - 中序遍历的顺序，一个节点的后一个节点，就是后继节点
  - 分两种情况讨论：（这个还是挺难理解的，很抽象）
    - 1. cur 有右树的时候， cur的后继就是其右子树的最左节点
    - 2. cur 无右树的时候， cur的后继就是，往上走，依次判断当前节点是不是其父亲的左孩子，不是继续往上，直到是，那么找到的父节点Y，就是cur的后继节点 （此时cur是Y节点的左子树最右节点）
- 找中序遍历的后继节点
  - 中序遍历，不需要存所有，只需存，前一个遍历的节点，和当前节点即可;

- 二叉树的序列化和反序列化
  - 序列化，内存里的二叉树变成字符串形式（存到硬盘）
    - 本质是遍历： 可以用先中后，各种序
    - 用先序吧，比较简单
    - null用#表示
    - 值结束用_表示
    - 收集字符串结果时：
      - 先序：必须在进入时拼接（收集），也就是在1区拼接： base case 情况和当前值情况
      - 要么在回溯时拼接，左右，也就是在2,3区拼接, 不过，因为是先序的，所以必须在1区拼接
      - 不能既在1区拼接，又在2，3区拼接，这样就会出现重复拼接了
  - 反序列化， 字符串变二叉树
    - 如果是用先序序列化的，那么就用先序反序列化，递归思路跟先序相同
    - 把字符串用分隔符变成数组，消费序列
    - 先建头节点
    - 再建左子树
    - 再建右子树
    - length 为0 ，以及 值为 '#',都返回null（默认最后一个节点的字节点是null）, 就行，保证返回的都是节点， 最后一个节点加两个null结束



 - 前缀树
 - 前缀树node节点
   - *根节点表示空字符串*
   - pass: 有多少个节点以这个字符串为前缀（经过这个字符）
   - end: 有多少个字符串结尾(加入过这个字符串几次)
   - next: *一个对象，内部有0到25的key*, 表示当前节点有没有去下一个字符的路；（表示下一步所有可能的路）
     - 算当前cur的key: cur.charCodeAt() - 'a'.charCodeAt();
     - 如果所有可能性的路太多（不止a到z,26个字符），表示路的方式可以换成hash表
 - 有多少个字符串以当前字符串为前缀



- 6. 图的相关题型： 重要的是先要设计好数据结构
  - 点：
    - 入度in： 有几个指向它的边
    - 出度out： 有几个从它出发的边
    - nexts: 和它直接相邻的点


- 7. 拓扑排序： 在事情可能有前置依赖的情况下，如何决定做事的顺序
- 思路：
  - 1. 先找到入度为0的点A排在前面， 然后把A点极其影响（也就是它的指向边）擦掉， 也就是把它指向的nexts点的入度减1；
  - 2. 找下一个入度为0的点
- 详细步骤：
  - 1. 遍历节点，hashMap记录所有点的入度，并把所有入度为0的点加入列表zeroArr；
  - 2. 遍历zeroArr, 加入到结果里去，并在hashMap里把对应入度减小，如果入度为0，进入到zeroArr列表；


- 8.贪心算法 （贪心策略的题目，一般面试很少考，因为这类题的只要有解题思路，实现很简单，无法考coding，也没有区分度，只有0和1的区别）【贪心不做，无区分度，只有解题思路】
  - 按照一定条件排序，找出最优的排序标准（依据）
  - 解法： 
    - 找排序标准，靠根据自己的常识，经验蒙 （能举出反例就说明排序标准不对）
    - 用暴力的解法（全排列），找出正确答案，和贪心算法的答案，对比，答案一样就说明是正确的
    - 贪心策略的证明很难，设计到较深的数学领域，而且每道题的证明方法不一样
  

- 9.经典回溯： n皇后： hot100 的困难题型（实际理解了思路，就并不难）: n*n的棋盘，放n的皇后，皇后不能共行，不能共列，不能共斜线
- 思路：
  - 每行只能放一个;
  - 每一行遍历所有的列，寻找一个合法位置（检查和之前皇后的位置关系），放置皇后; 将解法结果累加到 总结果上;
  - 然后进入下一行
  - 走出边界，说明当前是一种合法放法 ，返回1（如果无效就在是否合法的位置给拦截了，走不动最后）,还要排除
  - *难点：由于收集一种解法的record 始终指向一个地址，所以收集完结果，回溯时要改回原状； 这个比较难想要记着*;
- 检查位置是否合法：因为是按行遍历的，所以只需要检查列，以斜线
  - 检查是否共斜线： 当前点与之前每一个点对比，横坐标差值，与纵坐标差值的绝对值相等的，说明是正方形(45度)，就共斜线了;
- 参数：
  - i来到第几行
  - record: 一个单数组记录之前每一行皇后所在列， 索引表示行数， 值表示列数
  - n 行数


- 9. 补充: 暴力递归
- 难点在于如何尝试（所有可能性）： 这个与天赋与经验有关，经典问题记住解法就行
-  一个字符串全部子序列（子集问题）
   -  每一个字符有：要 和不要两种可能
- 一个字符串的全排列，不能重复
  - n个位置，选字符，每个的可能性有多少种
  - 去重： 
    - 在str之前已经字符已经固定的情况下，接下来，同一个位置，如果试过相同的字符，那么这个字符就不需要尝试了，跳过
      - 这个也就是剪枝（提前杀死分支，分支限界），在时间复杂度上，常数项上有优化
    - 也可以得到结果后去重，这个好理解一些

- 递归逆序一个栈，但是不能申请额外的数据结构
  - 利用递归本身就是一种栈
  - 创建一个能移除栈底元素并返回的函数f
  - 递归调用f, 直到栈空，开始把得到的数据压栈


1.  与哈希有关的结构（这个不在热题100范围，与后端相关性更大，大数据相关,实用性较强,暂时不看）
    - 哈希函数特点：
      - 输入范围，没有限制（无穷大）；输出范围，有限制
      - 同样的输入，对应同样的输出
      - 即便是不同数输入，有可能会出现相同的输入（哈希碰撞，碰撞几率极低）
      - 离散性和均匀性： 均匀的分布（几乎等概率）在输出范围上（即便输入非常相似）; 这个性质越好，哈希函数也就越优秀
        - 意味着输出结果，如果在0~n上均为分布，那么如果%m， 也能保证在0到m-1上均匀分布；
    - 布隆过滤器 【略过】
    - 设计 Random pool【略过】

2.  岛问题： 一个矩阵里，只有0和1,1表示岛，求矩阵里有多少个岛（多少片1）
    - 一行行遍历（广度优先）, 发现1计数，并且调用该染过程，否则跳过
      - 广度： 从左往右，再从上往下
    - 改染过程：把连成一片的1找到，并且改成2; 染色避免死循环;
      - 在没越界，并且为1的前提下
      - 从上下左右四个方向，开始寻找，可以继续染色的（行+1， 行-1, 列+1, 列-1）
    - 注意点： 按索引遍历，边界也按索引处理
    - 进阶设计并行算法解决这个问题 【略过】

3.  kmp算法： str1是否包含str2, 如果包含，返回str2在str1中的开始位置 
    - kmp 一些题目的基础
    - 经典解法：
      - 拿一个开头，可以配出字符串str2; 从左往右依次考察，str1
    - kmp加速（加速解法比较麻烦，暂时不看，有机会再补）

4.  Manacher算法（马拉车）: 字符串，中最长回文子串的长度
    - manacher 一些题目的基础
    - 经典解法：
      - 遍历，每一个位置向左右两边扩（但是这样对于偶数个数的回文就找不到了）
        - 头尾加上辅助符，每个字符之间加上辅助符#: #1#2#3#3#2#1#,   #1#2#1#
        - 这样找到的结果除以2，向下取整，就是结果了
    - manacher 算法加速（加速解法比较麻烦，暂时不看，有机会再补）

 
12.1 滑动窗口：窗口内最大值与最小值的更新结构：时间 O(n)
  - 窗口的运动原则：
    - 左右边界，l与r都可以往右动;(可以不一起动)
    - l不能超过r;  
  - 数据结构： 双端队列(左为头)： 维持着，窗口里l往右动时（依次过期时），依次的最大值信息（大值的优先级）
    - 放索引： 同样一个数能存更多信息，能根据索引找到值
    - 最小值更新结构: 由小到大，保证严格的单调性; 最大值直接从队列头部取；其他见下面，和最大值更新类似
    - 最大值更新结构：在队列里的顺序，由大到小，保证严格的单调性; 最大值直接从队列头部取
      - r往右动时：保证单调性
        - 新进的数据，和队列尾部比较，比尾部小，直接放入; 比尾部大(或者相等)，则移除掉尾部数据，再继续比较
          - 新的有效期更长，还大，旧的再也没有机会成为最大值了，所以没用了，可以移除
    - l往右动时：判断头部数据是否过期
      - l每动一次，都会有一个数据过期（跑到窗口外）;
      - 判断过期数据是不是队列头部数据，如果是则移除，否则不管;
  - 简化版问题： 固定长度窗口长度的，滑动窗口最大值
    - l与r同时动，然后按窗口问题思路解

题目关键词： 满足xx条件 最长/最短 子串/子数组/子序列

- 1. 寻找最长
  - 如果窗口满足条件，r向右滑动扩大窗口，更新最大值
  - 如果窗口不满足条件， l向右缩小窗口
- 2. 寻找最短
  - 如果窗口满足条件，l向右滑动缩小窗口， 并更新最优结果
  - 如果窗口不满足条件， r向右扩大窗口



12.2 单调栈：一个数组，我想知道每一个数，左边离它最近的，比它大的，和右边离它最近的，比它大的是谁；代价要低 时间o(n);
  单调栈顺序：
  - 求比自己大的： 从栈底到栈顶，值由大到小; 栈里放索引;
    - 入栈时： 遇到与栈顶元素比较，比栈顶元素小则入栈；比栈顶元素小，在降栈顶元素弹出；继续比较;
      - 只要栈顶元素开始弹出，则弹出的栈顶元素的信息就开始生成： 左边最近比它大的就是它下面压着的数，右边最近的比它大的就是在与其比较的，即将入栈的当前数
    - 清算阶段： 遍历完数据后，如果栈里还有数据，依次弹出，并记录信息: 每一个元素下面压着的，就是左边最近比它大的；右边无；
    - 如果有重复值： 栈里就不能放索引了，因为可能有两个索引要放入同一个位置，可以放小链表(或者放数组也行)，值为元素索引，next为元素值; 要弹出时，依次处理链表里记录的索引;
  - 单调栈为什么是对的: 
    - 比如要放入a, 弹出b, b压着c; 
    - ab之间如果有比b大的，那么b一定已经被弹出过了，a就是右边最近大值是对的;
    - c，b之间如果有比b大的，那么那么一定在栈里体现出来了（没人弹它肯定会留下来），没有就说明不存在这样的值，所以左边逻辑也是对的，压着的就是左边最近大值；
  - 求比自己小的： 从栈底到栈顶，值由小到大;栈里放索引;
    - 参考上方思路
  - 每一个元素只进栈一次，出栈一次，所以时间复杂度：o(n)
  - 题举例：数组中累加和与数组中最小值的乘积为指标A，求数组中连续子数组，指标A最大值
    - 抽象： 以每一个元素为最小值，往左右扩，能扩的最大范围，就是以当前元素为最小值的，最优解解
    - 转化单调栈： 求每一个元素左右最近的，比它小的值，就是它能扩的范围


1.  树形dp: 可能性分类是最重要的
    - 树形dp解法思路步骤:
    - 1. 以某个节点x为头节点的子树中， 分析答案有哪些可能性， 并且这种分析是以x的左子树，x的右子树，和x整颗树的角度去分析的
      - 常见可能性分类方向（尝试方向）
        - 要求解的结果分两种情况讨论：1. 包含头节点的 2. 不包含头节点的
        - 从左往右尝试
      - 如何评价尝试的好坏：
        - 1. 每一个可变参数自己的维度：
          - 维度越低越好：比如一个点，单一的值（1,2,3,4....）就是一维的,最好就是一个整数，面试基本上，不会有突破0维的，所以一定也不好突破0维；一个数组[1,2]就是二维的；
        - 2. 参数的个数：个数越少越好（意味着改动态规划时，表的维度少）
    - 2. 根据第一步的可能性分析，列出所有需要的信息
    - 3. 合并第二步的信息， 要求左右树返回同样的信息，并写出信息结构
    - 4. 设计递归：递归函数是以处理以x为头节点的情况下的答案
      - 包括设计base case, 默认得到左右树的所有信息， 以及把可能性做整合，并且返回第三步的信息结构
    - 二叉树结点间最大距离问题
      - 可能性分类：
        - 1. 头节点不参与：最大距离来自于左树节点或者右树节点
        - 2. 头节点参与： 最大距离来自于左右树节点
          - 最大距离：左树高 + 右树高 + 1
      - 根据可能性分类: 头节点向左右子树要的信息是: 1. 子树树高  2. 子树最大距离
      - 解法： 最大距离 = Max((左树高 + 右树高 + 1), 左树最大距离, 右树最大距离)
      - 步骤：
        - 1. base case 【推演出最底层的最大距离，根据base case一般能退出叶子节点的解，在拆黑盒时这里容易犯迷糊 】
        - 2. 左树黑盒返回信息
        - 3. 右树黑盒返回信息
        - 4. 拆解自己的黑盒：根据左右树信息，推算自己的信息，并返回
          - 当前节点最大距离：左树最大距离，右树最大距离， 左树高+ 右树高 + 1， 三者取最大值
          - 当前节点树高度：左右树高大的那个 + 1

13.1 Morris 遍历: 遍历二叉树，通过利用原树中大量空闲指针的方式，达到节省空间的目的。时间o(n), 空间o(1)
  - 比较高级，但是也比较麻烦，面试能加分，但是容易出错（先不看吧）

- 14.  （13.2） 大数据相关（实用性较强，与后端大数据强相关，先不看）
  - 位图解决某一范围上数字出现的情况，并可以节省大量空间
  - 利用分段统计思想，并进一步节省大量空间
  - 利用堆，外排序，来处理多个单元的结果合并

- 15 .  暴力递归到动态规划：
    - 无后效性： 之前的绝对，不影响之后每个步骤得到的结果;
    - 无后效性的递归都能改成动态规划
    - 面试中遇到的规划基本都能改成无后效性的尝试：考察的是有没有动态规划能力
    - 题型： 一个数组，从任意一个元素start 出发，可以随意想右或者想左走，必须走7步到达end位置，一共有几种走法
      - 是否包括头节点模型
      - 优化路径：
        - 1. 暴力递归
        - 2. 记忆化搜索:暴力递归有时会重复计算很多步骤，浪费时间，这些步骤的结果其实可以存起来，后面用直接拿
          - 递归里，用一个二维数组，在得到结果时把结果存起来
          - 进入递归时，先查缓存，缓存有直接返回，缓存没有才继续走
        - 3. 严格表结构： 有了一个二维表（二维数组），就可以根据二维表找规律了; 有了严格表结构，就有可能退出更加优雅的优化版本
          - 确定边界条件（base case）,叶子结点的答案，看看他们依赖那些位置
          - 确定中间状态的答案，看看他们依赖那些位置
          - 步骤：
          - 1. 分析可变参数的变化范围:
            - 一个可变参数，一维表;两个可变参数，二维表;三个可变参数，三维表;
          - 2. 标出计算的终止位置
          - 3. 根据base case 标出不用计算直接出答案的位置
          - 4. 找规律，推算常规位置是如何依赖其他位置的
          - 5. 确定计算的顺序
          - 到了严格表结构这一步，就是就跟原始题目业务完全没有关系了，纯粹是数学找规律，不过一定是要画图才能找到规律的（这也决定了，笔试，容易出，面试相对少）
            - 这也就是我们所说的动态转移方程(之前老师说的做动态规划先最重要的是动态转移方程，有点误人子弟了，它只是一个关键性结果步骤，是推出来的，是尝试的结果，硬想是很难想出来的，最重要是先要熟悉尝试)
            
    - 题型： 一个数组，里面每一个元素表示一枚硬笔，值表示面值，请问最少几枚硬笔能凑成面值n
      - 从左往右模型
      - 每一元素有选或者不选两种情况
    - 题型： A,B玩一组纸牌，只能从两边拿，每次一张，比最终结果大小
      - 定义先手，后手函数，及纸牌数组l, r
      - 先手： 从左拿，那么后手范围就是l+1到r, 从右拿，那么后手范围l到r-1; 取两种可能性的大值
        - 如果当前拿牌是先手，那么下一次拿牌就是后手了
      - 后手:  从左拿，那么先手范围就是l+1到r,从右拿，那么先手范围就是l到r-1; 因为是在后面函数里，调用此函数，所以会拿到不利的数据，也就是取两种可能性最小值
        - 如果当前是后手，那么下一次拿牌就是先手了
      - 改动态规划
        - 记忆搜索版本
        - db表
          - 依次从左右边界一个范围里尝试，可以改成一张二维表
            - 因为有左右两个变量，两个维度，所以是一张二维表
          - 范围内题目一般左边界不能大于右边界，所以一般左下半区都没用
          - 一个递归函数就表示一张二维表

- 16.  动态规划：
    - 三维动态规划：略（先不看，后面有时间再研究）
      - 题型： 10*9 的格子， 下象棋， 马在start（0,0）, 一定要跳k步，走到end位置, 有多少种方法
    - 完全背包问题，零钱兑换，组成面值（1:19分）（需要时再过来看吧）

- 17. 有序表：略（后面有时间再看），操作时间复杂度logN, 把一组数字，组成树;
  - 红黑树，avl树, sb树，跳表，都能实现有序表(都差不多，对于有序表，熟悉一种就行，sb比较容易一点)
  - 树的左旋，右旋
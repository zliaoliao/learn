# hot100

这个版本一般面试不需要看，只是做题时做的个记录，做个记录

## hash

- 1. 两数之和
  - 先配对，后存储
  - 一遍遍历即可， 先看这个值能不能配对， 然后做map映射存储；（先做映射，就会受到当前值的影响，并且还有可能遇到重复值，先做会把key覆盖掉， 因为是两个数只和，并且求一组结果，所以后做映射存储，覆盖掉也没有关系）

- 2. 字母异位词分组
  - 排完序的单词就是相同的，用排完序的单词做key存入hash表

- 3. 最长连序列
  - 相右尝试：逐次加1向后尝试
  - 用Set集合存
  - 如果没有val-1, 说明到val是不连续的，从val开始计算一次

## 双指针

- 4. 将数组中的零移动末尾，不改变其他元素的相对顺序
  - 用快排思想
  - 不等于0的，全部移到左边

- 5. 盛最多水的容器
  - 两边相中间找，移动矮的那边；
  - 容量 = 两个指针指向的数字中较小值∗指针之间的距离， 移动高的那边显然是不行的，移动矮的才有希望；
  - 这种题很难证明，需要用到数学知识，做题只能是凭借感知和和经验

- 6. 三数之和
  - n^2, 不是每一道题都能用n的算法解出来的
  - 先固定第一个数a，然后b、c只能从两边向中间靠
  - i遍历到<=n-3的位置,后面正好留两个位置
  - 去重处理： 保证把第一次遇到的符合条件的值放入结果
    - i遍历遇到重复的跳过，从1开始校验，第0个就不用检验。
    - 后面的j,k，与i对应的值，他们的和等于0的时候才开始去重。这样才能做到，把第一组先放进数组，后面有重复的再跳过。

- 7. 接雨水
  - 左右指针向中间走，用更高的版更新左右板的最大值，取左右板最大值的小值为标准，比标准小的就可以盛上水，就可以记录累加值；
  - 移动矮的指针，相等时移动一边就好了，不能同时移动， 同时移动就相当于一次走了两步，很可能指针撞到一起就漏掉了一个元素；
  - 要确定每个循环里做了什么事， 假设上一轮循环已经把该做的事都做好了，初始值就是上一轮循环应该给出的值；

## 滑动窗口

- 滑动窗口，就是窗口内的信息都是处理过的，都是有价值的，可以利用的
- 滑动窗口怎么移动时进入窗口是关键： 一般是要从零开始全部进入窗口的，所以右边界一遍从-1开始;
  - 右边界移动： 先判断符合条件，然后入队，如果需要+1判断，那么就从-1开始;
  

- 8. 无重复字符的最长子串
  - 窗口内能保证是不重复的，那么就可以移动更新最大长度（只要遍历过久不需要再重复检查）
  - 用Set集合判重
  - 本质是是遍历每一个，然后向右尝试，只不过用窗口内不重复，减少了对比次数

- 9. 找到字符串中所有字母异位词
  - 当窗口中每种字母的数量与字符串 ppp 中每种字母的数量相同时，则说明当前窗口为字符串 ppp 的异位词
    - 同时遍历他们，用数组计数
  - 数组计数： 用数组每个字符出现的次数，索引表示字符code(与a的字符编码charAtCode相减)
  - 移动固定窗口： 固定窗口初始位置，第一次的结算好；然后每一次循环，左右各移动一步，left++, right++, 同时对应字符计数也做变化
  - 初始化数组时，用new Array(), new Array() 才能传length; Array.from() 只能传字符串，或者可迭代对象；






## 子串

- 10. 和为 K 的子数组（子数组是数组中元素的连续非空序列）
  - 如果暴力向左尝试，则为n^2可能超时；
  - 算前缀和： 每一个位置都有一个当前元素与前面所有元素累加的和，就是前缀和；如果两个前缀和相减为k，那说明这两个前缀和之间的(包后不包前)数就是和为k的子序列;
  - hash存储：求任意两个前缀和的差值也不好算，可以转变一下： 两个前缀和之差，即：当前元素的前缀和 - k, 这个前缀和是否存在的问题，存在就可以算; hash中存的是当前位置之前的前缀和，所以要先结算，后把当前位置放入hash, 尤其是k=0的时候，提前就肯定从 -0肯定有，因为已经放入了;
    - 因为不需要计算具体位置，只需要计算次数，所以，找到一个加一次就行
  - 因为当一个元素正好等于k的时候，减k为0，所以初始化时，让0默认出现一次；（可以理解为累加和是从0开始的，而不是第一个元素开始的）
  - 连续子串就是尝试每一个元素前面的部分，一次遍历中就可以计算出上面的内容，所以只需要一次遍历即可；




## 数组

- 53. 最大子序和
  - 从左向右尝试，可以算出之前的和，如果之前的和小于0，则不要(丢弃之前的数列)，因为加入就会减少总和；
    - 之前值为正，则加上当前值记为pre， 否则当前值就是pre
  - 如果大于零，则和当前数累加，与之间记录的最大值比较
  - *前后缀*

- 56. 合并区间
  - 先排序，再合并
  - 注意解决数组坍塌，用while循环,删除了的就不需要i++

- 189. 轮转数组
  - 轮转后， (index + k步)/ 数组长度，就是轮转后的新索引

- 238. 除自身以外数组的乘积
  - 算每个位置的前缀积和后缀积，三次遍历，一次算前缀，一次算后缀，一次算结果
  - 如果想极致优化节省空间，可以两次遍历，一次算前缀，第二次同时算后缀和结果，就不一个right数据来存后缀结果了
  - *前后缀*

- 41. 缺失的第一个正数
  - 用hash表出现的值都存一遍，再从1开始地增查找，遇到hash表里没有的就是结果
  - *hash表*
  - 优化写法：用数组模拟hash， 把每个元素放在他应该在的位置上
    - 第一遍遍历，在1到n内，将每一个数放在他应该在的位置上，数字n， 应该在n-1的位置上, 如果不在就交换，那么原来n-1位置上的值，就要交换到数字n所在的位置；
    - 第二遍遍历，找到第一个不在它应该在的位置上的数就是结果
    - 交互的时候要注意：
      - 不能写成这样： [nums[i], nums[nums[i]-1]] = [nums[nums[i]-1], nums[i]]， nums[i]的赋值会影响nums[i]-1 的计算
      - 把需要计算的写在前面： [nums[nums[i]-1], nums[i]] = [nums[i], nums[nums[i]-1]]


## 矩阵

- 73. 矩阵置0
  - 两遍遍历，一遍记录0的横，纵坐标集合，一遍判断判断元素位置是否在横纵坐标内，在就改0


- 54. 螺旋矩阵
  - 循环里有四种情况，向右，向下，向右，向上， 先记录好边界，每次一种情况遍历完，就把边界减1，同时判断边界是否交叉
  - 同时注意，是变行，还是变列，是加还是减，容易写着写着就弄混了

- 48. 旋转图像（90度旋转）
  - 把旋转变为翻转： 先沿着水平轴对称翻转，然后沿着对角线翻转
    - 这个思路不好想，急着就行，90度旋转就是翻转两次
  - 水平翻转： 遍历到行的一半，遍历时直接交换
    - 对称点就是length - i -1, 这个也不好想
  - 对角线翻转： 遍历时交换，行大于列的的元素

- 240. 搜索二维矩阵 II
  - 从右上角开始搜索，大了就朝左找，小了就朝下找
    - 只要大朝一个方向，小朝一个方向，才好迭代循环； 所以这种寻找题，不一定是从0,0的位置开始的，可以尝试四个角

## 链表

- 2. 两数相加
  - （l1.val || 0） + （l2.val || 0） + 进位
  - l1 和 l2遍历完了，如果还有进位，那就在结尾再加一个进位1节点

- 19. 删除链表的倒数第 N 个结点
  - 快慢指针，都从0开始，也就是虚拟节点dummy开始，快指针先走n步； 然后一起走；到快指针到结尾；

- 25. K 个一组翻转链表
  - 技巧
    - 1. 虚拟头节点， 反转链表
    - 2. 向前走n步，从0开始，从dummy开始，从pre开始

- 138. 随机链表的复制
  - 两遍遍历，第一遍存hash表，第二遍连上指针;
  - 有时候一遍不好处理的可以分成两遍遍历，写起来会好写很多。

- 148. 排序链表
  - 归并排序思想
  - 找链表中点
  - 合并两个有序链表
  - 我忽然想到，所有理工科的学习就想是在搭积木，需要熟悉基础模型，然后才能用基础模型搭建更复杂的模型，如果基础模型不熟悉，那题基本上没法做。而所有文科类的题目，都需要说真话，需要发自内心的去理解，去共情，如果不发自内心，也就无法打动人心。


- 23. 合并 K 个升序链表
  - 完全用归并排序思想， 先拆分，后合并
  - 拆分这一步也必不可少，因为可以避免重复合并运算，如果从前到后合并前的节点就会被重复运算合并进后面，浪费时间；

- 146. LRU 缓存
  - 关键点难点：操作元素后，把元素移到尾部;get 时把对应元素移动到链表尾部；put时，map里有的则移动，map没有的新节点则加到链表末尾
    - 这个操作，在链表里，就是删除节点，然后插入到链表尾部（用双向链表可以在o(1)的时间里完成这个操作）
    - 如果用队列，首先找到这个节点，然后移动到队列尾部，不好操作；
  - 一旦在缓存链表里删除，则是真的删除了，因为只能存两个；这是链表的size减小，hash 表里也对应删除；
  - put时，有节点就用旧节点，把val改掉就行，否则节点没简历pre和next，移动时，会出问题
  - 怎么在map里找到，节点对应的key呢， 把节点删除呢？创建node，时同时保存key
 
  
## 二叉树

- 101. 对称二叉树
  - 镜像遍历： 搞两个指针，一个l遍历左边，一个r遍历右边，l向左走时，r就同步向右走，然后时候他们的值要一样
  - 递归改迭代： 用队列把递归改成迭代是常见方法，先进先出，先左就是先放入左，对那的那一边先放入右；

- 543. 二叉树的直径
  - 左儿子最大 + 右儿子最大 + 1， 就是经过当前节点路径的最大节点数max， 在遍历的过程中更新max， 最后max-1就是最大路径
  - 当前节点最大高度： 左边 和 右边 大的那个 +  1 
  - 要区分高度和路径， 返回的是高度，用高度去算路径;

- 98. 验证二叉搜索树
  - 难点： 如后判断当前节点大于左树所有元素
    - 判断范围： 在遍历过程中，更新子树的节点允许范围；左树范围，lower 到 root.val， 右树范围 root.val 到 uppper， lower， upper 开始为无穷，在遍历的过程中更新
    - 利用二叉搜索树的性质： 二叉搜索树按中序遍历转换为数组后，是升序排列的; 这个好想，好写一点；

- 105. 从前序与中序遍历序列构造二叉树
  - 难点： 要注意开始已经给出了先序和中序数组
    - 始终脑子里得有前序与先序的概念，不然参数太多容易混淆：
      - 先序：[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
      - 中序： [ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]
    - 从中序数组找根节点索引rootIndex， 可以先存map取找，也可以用findIndex找，注意用findIndex 参数是一个回调函数，如果没找到会返回-1，要注意这种情况的处理；
    - 根据根节点索引计算左树的元素个数leftSize，利用左树的元素个数去定各种边界： 
      - 左树：
        - 先序左树，左边界: 原左边界 +1 ， 右边界： 原左边界 + leftSize; 
        - 中序左树，左边界： 原左边界， 右边界： rootIndex-1;
      - 右树：
        - 先序右树，左边界: 原左边界 + leftSize + 1 ， 右边界： 原右边界; 
        - 中序右树，左边界： rootIndex + 1, 右边界： 原右边界；

- 114. 二叉树展开为链表
  - 每一个节点，先把左右节点保存，然后把left置为null， right为原left节点，然后left节点的最右节点连接当前right节点
  - 迭代寻找一颗树的最右节点： 不断地往right 迭代


- 437. 路径总和 III
  - 难点在于： 不需要从根节点开始，叶子节点结束，从任何一个节点，开始往下找都行；思路不好想；
    - 思路1：暴力递归： 计算每一个节点向下延伸的可能路径
      - 思维误区1：以为这种路径可以是中断的，实际从每一个节点开始的话，路径就不能是断的；
      - 思维误区2：问题是路径上的节点能不能重复利用呢？没说不能那就是能；
      - 正确的思路： 双重递归，没做过类似的题比较难想，正常的dfs 就从根节点开始的一个dfs，从根节点开始查找就行了，每找到一个就加一个； 但是这个题由于每一个节点可以是开始节点，意思是都可以当成是根节点，那就是每个节点都要执行一个和根节点类似的dfs；也就是双重递归，*一重的dfs遍历到每一个节点，一重是从每个节点开始计算路径*；
    - 思路2： 前缀和
      - 先序遍历，每次遍历的和记录在map里，key为前缀和，值为出现这个和的次数；
      - 如果当前和 - 目标值target，在map里，说明之前有路径满足，和加起来为target, 值就是满足的次数；
      - 注意：
        - 初始状态：需要初始化哈希表map的初始状态，以处理从根节点开始的路径。初始前缀和为0；
        - 回溯时恢复： 回溯，减少当前路径和在哈希表中的计数；因为如果在左右处理完后回溯了，表示当前节点已经处理完了，把处理完的节点要恢复一下在hash表中的状态；



- 124. 二叉树中的最大路径和
  - 难点：读懂题意： 同一个节点在一条路径序列中 至多出现一次， 就是这条路径不能回头，一个点不能重复链接两次
  - 思路：把路径和，分析成求每个点的贡献值，在递归过程中更新最大值
    - 1. 树形dp: 当前点的最大和等于， 左树的最大贡献值， 右树的最大贡献值， 与当前值，三者相加及对比，分析出来的
      - Math.max(root.val + left, root.val + right, root.val)
    - 2. 求每个点的最大贡献值
      - 每个店的最大贡献值等于： 加左树的贡献值，或者加右树的贡献值  root.val + Math.max(left, 0)+ Math.max(right, 0);
  - 特点： 不能直接求解，求解的答案，与过程中需要一步中间值的转化；1. 先求每个点的贡献值  2. 通过贡献值求解出想要的路径和


- 树的常见疑问：
   - 一个操作，我每一步开始前都要做，常见想法是在递归里做，但是第一步怎么处理呢？用初始值么，如果初始值不知道呢，要把在递归里的操作重复一遍么？
     - 一般用初始值处理，注意从题目中寻找初始值


### 图

- 200. 岛屿数量
  - dfs: 从一个点向四方扩散
  - 二维树类题目： 以左上角为原点，向下为行，向右为列；
  - 遍历的过的标记为2， 注意题目里给的岛屿是数字1，还是字符串1；


-  994. 腐烂的橘子
   -  bfs： bfs的特点是，从起始节点开始，先访问所有与起始节点距离为1的节点，然后访问距离为2的节点，依此类推，逐层扩展。
      -  每次只传播相邻的，就符合bfs队列每次处理一层的理念
   -  思路：
      -  1. 初始队列：首先找到所有腐烂的距离， 并将其加入队列
      -  2. 层次遍历：我们从队列中取出一个腐烂橘子，并检查其上下左右四个方向的橘子， 如果是新鲜橘子（值为1），则将它会变成腐烂橘子，并加入队列。
      -  3. 计时：每次遍历完一层，即遍历完当前队列中的所有腐烂橘子之后，时间增加1分钟。这样可以确保我们记录了每分钟的扩展过程。
   - 注意： 
     - 进入循环，记录下length, 然后用length 循环就不用考虑数组坍塌问题


- 207. 课程表
  - 思路： 拓扑排序
    - 1. 建立入度表，和nexts表， 寻找入度为0的加入zero数组；
    - 2. 遍历zero数组，更新入度表
    - 3. 对比处理过的课程数与总课程数
  - 注意点：
    - 对比处理过的课程数与总课程数， 是判断是否有环的关键；
    - 理解题意： 不需要前置依赖的课程，就不会加入到依赖数组中；入度表建立好后，直接遍历课程，找入度为0的就行；


- 208. 实现 Trie (前缀树)
  - 模拟这样一个结构： 比如对于字符串app， `{a:{p:{p:{ isEnd: true}}}}`
    - 开始node指针指向初始树的空对象，遍历字符，如果当前node里没有这个字符key, 则建立一个key的对象， 然后然后node指向这个key的对象，如此循环下去；
      - 也就是遍历字符串的时候，然node指针不断地指向当前字符所对应的子对象；
    - 理解题意：    
      - 包含：搜索的最后一个node节点有isEnd则说明包含次字符串
      - 前缀：搜索结果后包含前缀，则有前缀


### 回溯

- 总体思路
  - 回溯题多是排列组合，先可以全量思考
  - 如果要避免回溯，收集path: 数组可以用concat, 字符串可以用 path + 'xx'; 避免用push 和 path+= 'xx'， 这样会影响到其他分支




- 需要回溯的情况
 - 共享状态被修改：如果递归过程中路径数组path被多个分支共享，并且某个分支对其进行了修改，必须在递归结束时恢复其状态，以保证其他分支不受影响。这就是所谓的“回溯”操作。
- 不需要显式回溯的情况
 - 使用不可变数据结构：如果每次递归调用都使用一个新的路径数组（例如通过 concat 创建新数组），则可以避免显式回溯。这是因为每个递归分支都有自己的路径副本，不会影响其他分支。


- 46. 全排列
  - 思路：递归里跑循环
    - 0. path 初始值为[]
    - 1. 每次可以选取，剩下没被选取的任何一个
  - 优化：用标记法，和回溯后恢复状态，避免每次递归时使用filter
    - 0. 在每次递归中总是循环整个数组，如果元素已经被标记使用过则跳过
    - 1. 标记元素是否使用：可以用一个数组记录path里已经存在的元素，把索引放进数组存起来即可，避免每次使用filter去没没用过的元素过滤出来
    - 2. 回溯时清除使用标记，恢复path:当前节点处理完后，回溯回来时，将当前节点从path里移除


- 47. 求子集
  - 简单解法（不需要回溯）： 每一个元素有选和不选两种情况， 用const [first, ...others] = nums 解构出来，分成两种情况处理

- 17. 电话号码的字母组合
  - 一个脑残但是官方就是这么做的初始化： 把字母表映射手动建立好；
  - 简单解法(不需要回溯):  循环第一个字母组合， dfs选取其中一个， slice更新可选字符串，然后进入dfs在第二个字母组合里选取一个，如此递归；结果直接用path 字符串相加；

- 39. 组合总和
  - 要想清楚，因为一个元素可以重复选，所以每一次递归里，都可以从同一个元素，比如a开始，0个a, 一个a, 到n个a,知道和已经超过target界限
    - 也就是可以在递归里用一个循环，每次从索引i开始，并且记录这个i用作为递归参数，便是i这个索引位置的元素可以重复利用；直到这个索引结果已经超过target界限，然后就会自动开始下一个元素；

- 2. 括号生成
  - 不要陷入思维误区，这实际是一个排列组合，排列所有可能，剔除不满足条件的，就是想要的答案，每一个位置有两种可能，要么做有么右
  - 当路径中右括号数量大于左括号数量，就不满足条件了
  - 注意：
    - 收集path， 不能用path+= 'xx', 这样就是修改了path变量， path是一个共享变量，不能去改它，会影响到其他分支，要用path加；



- 79. 单词搜索
  - 思路： 
    - 1. 遍历二维数组，先找到头节点，然后进入判断当前节点和索引对应字符是否相同
    - 2. 结束条件是，字符串的全部索引遍历完成
    - 3. 进入递归里判断当前节点是否满足条件，满足条件的话才继续往下找，四个方向有一个方向找到了即可
    - 4. 注意为了避免重复寻找，当前节点处理完后要染色，回溯时要恢复
  - 注意： 
    - 单词不能重复使用，所以用过的要标记一下， 并且在处理完一个分支后要恢复，避免影响其他分支；

- 131. 分割回文串
  - 思路：这个题的思路不容易想清楚，主要是他的这个分支处理不是很常规
    - 1. 每一个分支操作实际包含了两步
      - 1. 从哪里截取
      - 2. 截取后剩下什么，如果剩下空字符串说明，整个分支操作已经完成，可以做最终的判断和收集了
    - 2. 总体思路是： 递归中循环，每次从什么位置截断，截断的位置+1，就是下一层递归的起始位置

- 51. N 皇后
  - 思路: 关键在于一行行查找，与怎么存储走过的路径
  - 一行一行的尝试，因为不能相互攻击，所以每一行只能放一个
  - 存储： 可以用原始的数组存储路径，但是不是最优解法，不过可以用，没毛病，最优存储解法需要用到矩阵的性质，来存储检查是否在同一条对角线上
    - 1. 主对角线（左上到右下）上的元素，其 行坐标-列坐标 结果都是相等的
    - 2. 副对角线上(右上到左下)上的元素，其 行坐标+列坐标  结果都是相等的
  - 注意最后结果的处理需要嵌套两层map, 因为总体是个三维数组



 ## 二分查找

 - 35. 搜索插入位置： 看题目的时候，看例子也很重要，有助于理解题意避免，无效的思考死角；
   - 看例子： 
     - n等于目标值，返回n的位置
     - n大于目标值，返回n的位置
     - 没有大于目标值，返回末尾位置
   - 总结：返回第一个大于等于目标值的的位置；二分就是找到最后，的大于等于目标值的位置；
   - 所以res初始值 为 nums.length + 1;


- 34. 在排序数组中查找元素的第一个和最后一个位置
  - 关键在于有重复元素，o (logn)不好处理
  - 思路： 
    - 特殊的处理：只不过再找到目标值之后判断，他是第一个还是最后一个，或者是中间的一个
    - 其余同常规二分，只不过要写两遍，写两遍的原因是： 区分是要继续向左找，还是继续向右找；


- 33. 搜索旋转排序数组
  - 思路：
    - 理解题意： 旋转数组，要么是一段递增的数组，要么是两段递增的数组，且第一段数组的第一个值大于第二段的最后一个值；
    - 现根据153题解法找到峰值，区分出两个递增区间
    - 判断目标值target 与 数组最后一个值的大小，决定在哪个区间二分查找；
    - 注意在while循环里找到目标值后，及时的return，或者break, 不然会超时；

- 153. 寻找旋转排序数组中的最小值 【经典基础题型：需熟练】
  - 思路： 
    - 1. 旋转数组的性质就是两个递增区间
    - 2. 需要区分mid中点，落在第一个区间还是第二个区间： 可以和right值比较,right初始值为最后一个值，因为*最后一个值(right)，要么在最小值右侧，要么就是最小值；*
      - right小于mid，就把left右移
      - mid小于right, 就right左移
      - 当他们重合就是答案了；（因为小的那个不会动，会一直停在原地，等待）


## 栈

- 155. 最小栈 【经典基础题型：需熟练】
  - 难点： 维护一个最小栈，怎么能用常数时间呢？ 
    - *维护的最小值顺序和压入数据的顺序一致*就行了， 充分利用了栈中数据的出入顺序；
    - 入栈：假设第一个压入的就是最小值，后面比它小的入最小值栈，比它大的就不用入栈了，因为它就是最有一个出栈的值；
    - 出栈： 出栈时，看一眼当前出的值是不是当前的最小值，如果是，把最小值出了；
  - 如果pop, push, getMin所有操作都是o(1)级别了



- 394. 字符串解码
  - 难点： 
  - 1. 数字，还可能是多位数怎么处理呢？如果拼接，数字的初始值，应该怎么设置呢？
    - 遇到数字，通过拼接构建完整的数字；数字初始值设为0， 因为如果有[]， 则前面必有数字
  - 2. 结算时：怎么处理字符拼接，一直用currentStr临时字符串么， 还是用一个res拼？
    - 每次解码出来的都是当前解码的字符串，所以用currentStr
  - 思路：准备两个栈，一个用来存储重复次数，一个用来存储已解码的字符串。准备两个变量，一个用来存储当前重复次数 k，一个用来存储当前字符串 currentStr。
  - 遇到数字时，构建完整的重复次数 k。
  - 遇到 [ 时，要记录当前状态，也就是将当前的 k 和 currentStr 压入栈中，然后重置 k 和 currentStr。
  - 遇到 ] 时，要结算一次， *从栈中弹出上一个字符串和重复次数*，然后将 currentStr 乘以该次数，并与上一个字符串连接起来。
遇到字母时，直接追*加到 currentStr*。
  - 注意结算时： 这里直接设置currentStr， 不能用 += 会引起重复， 最后的currentStr 就是完全解码的结果



739. 每日温度
    - 思路： 栈用于保存尚未找到下一个更高温度的索引。当找到更高温度时，通过这些索引计算间隔天数。遍历每一天的温度，与栈顶所指的温度进行比较。如果当前温度更高，则更新对应天数的 res 值，并且弹出栈顶索引。
       - 1. 比当前温度大好处理，把温度弹出记录结果即可
      - 2. 比当前温度小呢， 小的直接放进去就行， 后面有大的自然会把他们都挑出来；
    - 可优化点：
      - 一开始使用： Array(n).fill(0)， 后续就不需要处理上述2.3 中 0的问题了， 默认都是0 【可解下属难点1】
      - 初始化时：判断stack有值才进行对比，没有就直接push, 也就不需要考虑初始值的问题了；【可解下属难点2】
    - 易错点： 注意stack[k] 才表示在原数组中的索引，而k不是， k表示在递增栈中存储的索引，最终要用的是stack[k]
    - 难点：
      - 1. 递增栈初始值的设立， 是开始就把第一个元素放进去么？因为后面要对比，并且只有出现把它大的才能把它换出来；
      - 2. 没找到的，不能直接当成0 push,到结果里去，因为stack里记录的都是索引，依然得用索引stack[k], 放到结果数组里去；



## 堆

前端没有堆的概念，如果还要构建堆就太麻烦了，所以这类型题，前端一般就不用堆的解法；

前端一般用快排来解这一类题，快排的1.0版本，和2.0版本，是解题基础；

- 215. 数组中的第K个最大元素 【这一题，不太快排的 优化分区解法不会，搞了大半天】
  - 快速排序： 每次能确定一个索引位置k, k左边的都比k大，k右边的都比k小，那么k, 就是第k+1 大的元素；
  - 难点1： 需对快排很熟练
    - 1. 要注意快排的partition 分区，最终返回的是 *等于区的左右边界*
    - 2. 分区是，左边界 left 初始值为 l-1, 右边界 right初始值为 r 


- 347. 前 K 个高频元素
  - 思路： 把这一条变成解上面的215题
  - 1. 遍历数组，将原始数组转换为频率map 哈希表，和频率表；
  - 2. 用215的思路解题， 因为题目限制了数组中前 k 个高频元素的集合是唯一的， 所以还更简单一些，用快排的简单版就行了，把大的放在基准值左边,不需要移动右边界；这里partition 分区返回的是 *分界点*；
  - 3. 这一题，在选择的时候可以不需要返回结果，只需要把前k个找出来，也是是大于 某一个基准值的数据找出来，结果直接在排好部分顺序的数组上截取就好了；
  
        

## 贪心算法 【只有思路，无区分度，面试一般不考】


- 121. 买卖股票的最佳时机
  - 难点： 思路比较难想，需要转化题意
    - 1. 一层转化，维护一个最小栈
    - 2. 最终转化，只需要*维护一个历史最小值*，只有这个值是有用的，找到了最小值，也就能找到后续最大，因为是一次性的（只需找到一个最大值），所以不需要维护一个栈；


## 技巧

- 75. 颜色分类（荷兰国旗）
  - 快排的简化版：只需把小于1的排1左边，大于1的排1右边，等于1的排一起即可



- 31. 下一个排列 
  - 思路： 这个题的思路比较难想，需要记住，一共三步：
    - 先大概理解： 一个数，如果要变大，只能是 用数前面的小数n，换后面的大数； 但是又能尽可能小，所以得换一个在大于n区间里，尽量小的
    - 1. 从后往前找到第一个升序对（变大的开始位置）：找到一个位置 i，使得 nums[i] < nums[i+1]。这是从右到左第一个违反升序排列的地方。
    - 2. 在 i 后面的部分找到一个比 nums[i] 大的最小元素（在大区里找尽量小的）：在 i 后面的部分找到一个最小的 j，使得 nums[j] > nums[i]，然后交换 nums[i] 和 nums[j]。
    - 3. 反转 i 后面的部分： i后面是从右到左升序排列的，要把它变得尽量小；
  - 易错点： 找到1 start，才需要步骤2； start初始值可以给-1；


- 287. 寻找重复数
  - 思路： 比较难想，需要记住： 总体是二分查找
    - 选取一个中间数n，小于等于n的元素个数如果有n+1个，说明重复在 <=n这一边，否则就在另一边；
    - 有一个潜在条件容易混淆： 数据范围是1到n, 就意味着，不管nums怎么排列，我们其实是掌握着数据的顺序的，取的中点也正好是数据的中点；也因此需要每一次都遍历整个nums数据，因为nums是无序的， 我需需要知道小于mid值的一共有多少个；
    - low 和 high 相遇表示，数据搜索范围只有一个数了， 那必定就是答案；
  - 查找一个有范围的整数，可以考虑用二分查找；每一次进行边界收缩， 就需要将数组里的所有元素都看一遍，是其中一类题的解法，时间复杂度为nlogN

## 动态规划

动态转移方程： 当前结果，如何由之前的结果推导出来，有几种情况；


一个猜想： 
- 1. 动态规划里，dp表记录的一般是值， *以值为核心*，分为总值和阶段值， 从小开始，每一个值可不可以被组成，或者组成的最优结果，以推导出最后的值；


动态规划题目的解题思路
  - 识别问题的性质： 问题可以被分解为相同形式的子问题，并且这些子问题之间有重叠。
  - 定义状态： 确定状态（即子问题）的含义，并用一个数组或其他数据结构来表示。状态通常是问题的某个部分的最优解。
  - 状态转移方程：找出从一个状态到另一个状态的递推关系，即状态转移方程。这是动态规划的核心，也是解决问题的关键。

模版： 

```

// 1. 定义状态数组 dp，dp[i] 表示到第 i 个位置或选择第 i 个元素时的最优解
let dp = new Array(n).fill(0);

// 2. 确定初始条件
dp[0] = 初始值;

// 3. 确定状态转移方程
for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
        dp[i] = Math.max(dp[i], dp[j] + ...);  // 根据具体问题确定转移方程
    }
}

// 4. 计算最终结果
return dp[n-1] 或其他与问题相关的 dp[i] 的值;

```

两层循环的含义：
- 1.  外层循环：遍历决策阶段
  - 外层循环通常遍历的是每一个“决策点”，通常遍历的是问题的每个部分、每个阶段或每个元素，代表逐步推进问题求解的过程。
- 2. 内层循环：更新状态
  - 内层循环: 通常遍历的是所有可能的状态或选择，基于当前决策点来更新状态。


哪些问题适合用动态规划
最优子结构：问题的解由子问题的解组合而成，如最长递增子序列、最短路径、最大子数组和等。

重叠子问题：子问题会重复出现，如斐波那契数列、背包问题、不同路径等。

子序列问题：比如最长公共子序列、最长递增子序列等，通常用 DP 来逐步构建和优化解。

分割/划分问题：如分割整数、划分数组等，通常需要递推找到最优解。

路径问题：如从起点到终点的最短路径、最大路径等。

背包问题：经典的 DP 问题，通常涉及如何选择若干个物品使得价值最大化。


- 118. 杨辉三角
  - 思路： 每一行左右都是1， 当前行又上一行推出；
  - 易错点：
    - 因为要频繁的操作索引，所以还是统一为用索引区遍历比较容易写对
    - 当前j位置的值，等于上一行 j + (j-1) 位置的值，这个数学规律，不要弄错了


- 198. 打家劫舍
  - 思路：
    - 因为相邻的不能偷， 对于一间房子，有偷和不偷两种选择：
      - 如果偷：fn1 = f(n-2) + cur
      - 如果不偷： fn2 = fn(n-1)
  - 容易陷入误区： 
    - 1. 怎么表示偷和不偷两种情况，很容易想到用二叉树递归，这样一来复杂度又提高了
    - 2. 要知道如果能知道到i的位置的最大值的行了，不需要考虑i后面会不会堆加出更大值，那是后面的项该考虑的情况；要明晰状态转移方程里， fn1, fn2当表示一个阶段的最大值；


-  322. 零钱兑换
   -  思路： 走楼梯的变体:  走台阶进阶版，从一次一步，变成一次 coin 步. coins 表示我每次可以走几大步台阶。 amont 表示层数。 问，刚好走到amont层最少需要多少步。 走楼梯，用两个变量迭代，就算出来了，这个题由于变量太多，无法迭代，所以用dp表把之前的值记录下来；
   -  递推公式：dpi =  dp[i-coins[j]]+1
   -  难点0: 如果表示无法凑成？ 答： 表格元素初始化为Infinity, 结束时还是Infinity, 就表示这个值凑不成
   -  难点1：i - coins[j] 可能为负啊， 怎么处理呢， 也就是dp表里可能没有？ 答：所以要加一个判断条件，不为负，才需要计算，dp[i]位置才可能有值
   -  难点2：并且硬币可以重复拿，这个又该怎么表示呢? 答： 第一次拿的最小已经算出来了，重复拿，就是+1，依旧包含在递推公式里
-  


- 279. 完全平方数
  - 思路同上
  - 难点1： 内层遍历面值的限制条件是j*j<=i;
  - 难点2： 递推公式： dp[i - j * j] + 1， 必须和 dp[i], 比较一下，因为dp[i - j * j] 这个值可能会被多次更新，
          比如对于12， 第一次更新 8+4, 后续还可能更新 11 + 1, 要保证最优性；


- 139. 单词拆分
  - 动态规划的思想是从头开始检查每个子串，然后使用一个布尔数组 *dp 记录从起点到当前位置是否可以通过字典中的单词组成*
  - 两次循环都在值上做遍历，第一次是扫描到每一个值，天dp表格，第二次是判断当前值是否能被组成；
    - 如果当前值j, 能被dp[i] + word 组成，则当前值能被组成


- 300. 最长递增子序列
  -  在每一个元素的位置想左尝试， 之前的值用dp表记录下来， 对于一个元素j, 向左扫描,对于小于j的元素，取  dp[i] + 1， 与dp[j] 中较大的一个；
  -  面试中用上述n^2 的动态规划的思路即可，不需要nlogn， 那个太难想；



- 152. 乘积最大子数组
  - 难点： 负数不好处理, 值为负数的时候，他的最大乘积怎么取呢，是取他自己，还是取前面一个，似乎都不太合适；取自己和取前面一个都会是错误的最大值；
  - 思路： 负数的处理比较巧妙，需要记住， 
    - 由于乘以一个负数，会把一个最大值变成一个最小值（负数），而一个最小值（负数）乘以一个负数，又可能变成一个最大值；
    - 而我们要求解的就是依次以某个值结尾的元素的最大乘积值，所以可以维护以当前元素结尾的最大乘积值，和最小乘积值，因为这两个值都有可能被后续用到；

- 416. 分割等和子集
  - 难点： 这个感觉还是挺难想的，因为数组里的值不能重复使用，所以还要考虑哪些用过，哪些没用过？
    - 1. 实际如果用正确的思路，就没有这个问题，我们用现有的“工具”是凑结果值， 如果凑到了就填表，对于每一个工具，我们都去看看，他能凑到最终目标值之前的所有能凑到的值；
    - 2. 倒序遍历target 值， 确保每个 num 只能被使用一次， 如果 dp[j-num] 为 true，说明在之前的迭代中，已经有一个子集和为 j-num
      -  如果正序遍历：因为num，本身肯定可以生成num，填上num位置的dp表格，所以不能先填num,否则2倍的num, 3倍的num都能一次生成的，会多次重复使用num， 所以要从后往前填；
  - 解法：
    - 1. 先遍历工具
    - 2. 对于每一个工具，遍历最终目标值前面，所有的阶段值，看1的工具能凑成哪些目标值，把值填到dp表上





## 多维动态规划


- 62. 不同路径
  - 思路：
    - 1. 如果使用dfs很好解，但是要求严格就会超时，解的时候要注意给的行，列(m,n)，都是长度length，而我们解题一般用的是索引，所以要m-1,n-1；
    - 2. 动态规划：
      - 状态转移： 因为到某个点，只能从上方，或者左方，所以到某个点的路径数： dp[i,j] = dp[i-1][j] + dp[i][j-1];
      - 初始化： 到第一行，和第一列的路径数为1；二维表的初始化：  `const dp = Array(m).fill(0).map(() => Array(n).fill(0));`
      - 有了上面两步，这个题就很好解了： 通过状态转移公式，把dp表填完就行了；

- 64. 最小路径和
  - 思路同上62；状态转移方程出来了，题就解了，很简单；
  - 注意点：如果需要优化，节省空间，就可以不用额外的填dp表，直接在原表格上改；



- 1143. 最长公共子序列
  - 思路： 这个思路不好想，需要记住
  - 定义： d[i][j] 为 s1 的*前i个字符 和 s2 的前j个字符*的最长公共子序列
    - 那么
      - 末尾字母相同时：d[i][j] = d[i-1][j-1] + 1; 
        - 解释： 如果s1 i位置 和 s2 j位置的 字符相同(i-1, j-1)，那么用他们前面dp表得到的结果+1（加上这个相同的字符），就是当前的结果了
      - 末尾字母不同时： d[i][j] = Math.max(d[i-1][j], d[i][j-1])
        - 解释： 如果末尾字母不同，则可以选择舍弃掉一个字符串的末尾字符，来缩小问题规模，讨论问题；
  - 难点： 定义状态转移方程式要区分字符串s，与dp表格， 字符串前i，j个字符为 0到i-1处，和 0才j-1处，而要填的dp表是dp[i][j],所以是判断s1[i-1] 是否等于s2[j-1]


- 72. 编辑距离
- 思路： 这个思路也挺难的，需要记住
- 定义： d[i][j] 为 s1 前i个字符，到s2前j个字符的编辑距离
  - 如果：
    - 1. s1 的第i个字符和s2 的第j个字符相等，则不需要操作，只需要考虑他们的前面的
      - d[i][j] = d[i-1][j-1]
    - 2. s1 的第i个字符和s2 的第j个字符不相等，有三种情况，对应三种可能得操作
      - 1. 增：在s1末尾(i位置)增加一个s2的j位置的字符，*那么剩下只需对比 s1 的前i个字符，和s2 的前j-1个字符*， +1，表示进行一次操作
        - d[i][j] = d[i][j-1] + 1
      - 2. 删：在s1 的i位置删除一个字符，那么剩下只需对比 s1 的前i-1 个字符和s2的前j个字符
        - d[i][j] = d[i-1][j] + 1
      - 3. 改：把s1 的i位置字符改成s2 j位置的字符, 那么剩下只需要对比 s1 前i-1 和 s2 前 j-1 个字符；
        - d[i][j] = d[i-1][j-1]
- 难点1： 在于这个思路，不好想，需要理解性记忆
- 难点2： 初始化时，d[i][0] = i, d[0][j] = j, 表示由空字符串生成，和变成空字符串需要多少次操作



## 贪心：向左右尝试 和  左右&右左尝试

- 5. 最长回文子串 【非动态规划解法： 由中心向左右两边尝试】
  - 1. 暴力解法： 在每个元素向左尝试很简单，但是要注意以下几点，并且要求高一点就无法通过了：
    - 算两个索引之间元素的长度（个数）： i - j+ 1, 要加1，不然就不是长度了，是差值；
    - 由于题目提示了： 1 <= s.length <= 1000， 测试场景，字符串长度有限，所以可以设计n^2的算法；
  - 2. 中心扩展法： 从中间向两边扩展；
    - 要注意，对于每一个字符，都要考虑他为奇数回文，和偶数回文的两种情况，所以需要把判断回文的地方封装成函数；
    - 算长度的时候，不需要轮加，因为初始值，可能为1,2不好处理，可以直接用最终得到的索引算；
    - 难点： 得到长度用，怎么用长度算索引，截取位置；
      - 1. start 开始位置好算一些，结束位置不好算，那就用开始位置+ len，来算结束位置；
        - start = k- Math.floor((maxLen-1)/2);


- 32. 最长有效括号【非动态规划解法：左右&右左尝试】
  - 难点： 要求格式正确且连续，这个连续不好处理啊；
  - 思路： 本题为困难题，因为思路比较难想，一旦有了思路，写起来比较容易
    - 1. 括号有效必须左括号等于有括号
    - 2. 从左到右扫描左右括号个数，一旦右括号比左括号多，说明前面的已经构不成配对了；归0，继续扫描；
    - 3. 两边扫描，从左到右保证了，不会出现无效的右括号，一旦出现就停止，从新计数； 而从右往左，则保证了，不会出现无效的左括号，一旦出现，则重新计数；


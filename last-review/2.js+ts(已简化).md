- 记录
  - 11.27 12:33 看到：JS中数据类型转换


## 学习JS，我们学习它的几部分组成

ECMAScript（ES）：JS的核心语法
DOM：document object model 文档对象模型，提供各种API（属性和方法）让JS可以获取或者操作页面中的HTML元素(DOM和元素)
BOM：browser object model 浏览器对象模型，提供各种API让JS可以操作浏览器

### 如何被运行

把代码运行在浏览器中(浏览器内核来渲染解析)
基于NODE来运行(NODE也是一个基于V8引擎渲染和解析JS的工具)

## 数据类型

数据值是一门编程语言进行生产的材料，JS中包含的值有以下这些类型

- 基本数据类型（值类型）
  数字number
  字符串string
  布尔boolean
  null
  undefined

- 引用数据类型
  对象object
  普通对象
  数组对象
  正则对象
  日期对象
  ...
  函数function

ES6中新增加的一个特殊的类型：Symbol，唯一的值

```
[Symbol]
创建出来的是一个唯一的值
var a = Symbol('x');
var b = Symbol('x');
a==b =>false

```

### number

NaN：not a number 但是它是数字类型的
isNaN：检测当前值是否不是有效数字，返回true代表不是有效数字，返回false是有效数字

isNaN('13') =>false
isNaN('x') =>true

```
重要：isNaN检测的机制
1、首先验证当前要检测的值是否为数字类型的，如果不是，浏览器会默认的把值转换为数字类型

  把非数字类型的值转换为数字
  - 其它基本类型转换为数字：直接使用Number这个方法转换的

  [字符串转数字]
    Number('13') ->13
    Number('13px') ->NaN 如果当前字符串中出现任意一个非有效数字字符，结果则为NaN
    Number('13.5') ->13.5 可以识别小数

  [布尔转数字]
    Number(true) ->1
    Number(false) ->0

  [其它]
    Number(null) ->0
    Number(undefined) ->NaN 

  - 把引用数据类型值转换为数字：先把引用值调取toString转换为字符串，然后再把字符串调取Number转换为数字

   [对象]
     ({}).toString() ->'[object Object]' ->NaN

   [数组]
     [12,23].toString() ->'12,23' ->NaN
     [12].toString() ->'12' ->12

   [正则]
     /^$/.toString() ->'/^$/' ->NaN

  Number('') ->0
  [].toString() ->''
  => isNaN([])：false

2、当前检测的值已经是数字类型，是有效数字返回false，不是返回true（数字类型中只有NaN不是有效数字，其余都是有效数字）
```

Number：出现任意非有效数字字符，结果就是NaN
parseInt：把一个字符串中的整数部分解析出来
parseFloat是把一个字符串中小数(浮点数)部分解析出来

```
parseInt('13.5px') =>13
parseFloat('13.5px') =>13.5

parseInt('width:13.5px') =>NaN 从字符串最左边字符开始查找有效数字字符，并且转换为数字，但是一但遇到一个非有效数字字符，查找结束

```

NaN的比较

```
NaN==NaN：false NaN和谁都不相等，包括自己

```

### 布尔类型

只有两个值：true / false;

如何把其它数据类型转换为布尔类型?

```

Boolean(1) =>true

!'xx' =>先把其它数据类型转换为布尔类型，然后取反

!!null =>去两次反，等价于没取反，也就剩下转换为布尔类型了

```

规律：在JS中只有“0/NaN/空字符串/null/undefined”这五个值转换为布尔类型的false，其余都转换为true

### null && undefined

null：空对象指针
undefined：未定义


### console

我们用 console.time() 和 console.timeEnd()
检测一段代码执行时间，包围要测试运行时间的代码，这两个方法的参数保持一致，以便正确识别和匹配代码开始和结束的位置


console.count()
我们经常需要知道一段代码被执行了多少次，我们可以使用 console.count() 来方便的达到我们的目的

```
for(i=0;i<3;i++){
  console.count('name');
}

```



## 类型检测

- typeof
- instanceof
- constructor
- Object.prototype.toString.call()

```
语法：typeof [value] =>检测value的数据类型

返回值：使用typeof检测出来的结果是一个字符串，字符串中包含着对应的数据类型，例如："number"/"string"/"boolen"/"undefined"/"object"/"function"
 
typeof null =>"object" 因为null代表空对象指针（没有指向任何的内存空间）

typeof检测数组/正则/对象，最后返回的都是"object"，也就是基于这种方式无法细分对象

面试题：
console.log(typeof []); 
//=>"object"

console.log(typeof typeof []); 
//=>typeof "object"
//=>"string"



fn instanceof Object：  只要在当前实例的原型链上，用instanceof检测出来的结果都是true，所以在类的原型继承中，最后检测出来的结果未必是正确的
  - 它用于检测一个对象是否是某个构造函数的实例


  object instanceof constructor



constructor:

var num = 1;
console.log(num.constructor === Number); // true
或者这么写： (1).constructor === Number


Object.prototype.toString.call()：

Object.prototype.toString.call()是检测数据类型最准确最常用的方式，起原理为：
先获取Object原型上的toString方法，让方法执行，并且改变方法中的this关键字的指向；  Object.prototype.toString 它的作用是返回当前方法的执行主体（方法中this）所属类的详细信息

console.log(Object.prototype.toString.call(ary)); // --> "[object Array]"

```

### JS中数据类型转换

#### 把其它数据类型转换为number类型

1.发生的情况

- isNaN检测的时候：当检测的值不是数字类型,浏览器会自己调用Number方法把它先转换为数字，然后再检测是否为非有效数字
- 基于parseInt/parseFloat/Number去手动转换为数字类型
- 数学运算：+ - * / %，但是“+”不仅仅是数学运算，还可能是字符串拼接，字符串拼接优先

```
 '3'-1 =>2
  Number('3')->3
  3-1->2

'3px'-1 =>NaN

'3px'+1 =>'3px1' 字符串拼接

var i='3';
i=i+1; =>'31'
i+=1; =>'31'
i++; =>4  i++就是单纯的数学运算，已经摒弃掉字符串拼接的规则

```
- 在基于“==”比较的时候，有时候也会把其它值转换为数字类型

2.转换规律

```
//=>转换的方法：Number（浏览器自行转换都是基于这个方法完成的）

【把字符串转换为数字】
只要遇到一个非有效数字字符，结果就是NaN
'' ->0
' ' ->0 空格(Space)
'\n' ->0 换行符(Enter)
'\t' ->0 制表符(Tab)


【把布尔转换为数字】
true ->1
false ->0

【把没有转换为数字】
null ->0
undefined ->NaN

【把引用类型值转换为数字】
首先都先转换为字符串（toString），然后再转换为数字（Number）

```

### 把其它类型值转换为字符串

1.发生的情况

- 基于alert/confirm/prompt/document.write等方法输出内容的时候，会把输出的值转换为字符串，然后再输出
- 基于“+”进行字符串拼接的时候
- 把引用类型值转换为数字的时候，首先会转换为字符串，然后再转换为数字
- 给对象设置属性名，如果不是字符串，首先转换为字符串，然后再当做属性存储到对象中（对象的属性只能是数字或者字符串）
- 手动调用toString/toFixed/join/String等方法的时候，也是为了转换为字符串

2.转换规律

```
//=>调用的方法：toString

【除了对象，都是你理解的转换结果】
1 ->'1'
NaN ->'NaN'
null ->'null'
[] ->''
[13] ->'13'
[12,23] ->'12,23'
...

【对象】
{name:'xxx'} ->'[object Object]'
{} ->'[object Object]'
不管是啥样的普通对象，最后结果都一样

```

### 把其它值转换为布尔类型

1.发生的情况

基于!/!!/Boolean等方法转换
条件判断中的条件最后都会转换为布尔类型

```
if(n){
  //=>把n的值转换为布尔验证条件真假
}

if('3px'+3){
  //=>先计算表达式的结果'3px3'，把结果转换为布尔true，条件成立
}

```

2.转换的规律

只有“0/NaN/""/null/undefined”五个值转换为布尔的false,其余都是转换为true

### 特殊情况：数学运算和字符串拼接 “+”

当表达式中出现字符串，就是字符串拼接，否则就是数学运算

```

1+true =>2 数学运算
'1'+true =>'1true' 字符串拼接

[12]+10 =>'1210' 虽然现在没看见字符串，但是引用类型转换为数字，首先会转换为字符串，所以变为了字符串拼接
({})+10 =>"[object Object]10"
[]+10 =>"10"

{}+10 =>10 这个和以上说的没有半毛钱关系，因为它根本就不是数学运算，也不是字符串拼接，它是两部分代码
  {} 代表一个代码块（块级作用域）
  +10 才是我们的操作
  严格写法：{}; +10;

```

### 特殊情况: “==”

“==”在进行比较的时候，如果左右两边的数据类型不一样，则先转换为相同的类型，再进行比较

两边类型不同时的的比较，都是把其它值转换为数字，然后再进行比较的，一种情况除外：对象和字符串的比较会转换为字符串再比；

NaN==NaN：false
NaN和谁都不相等包括自己

```
[]==false：true  都转换为数字 0==0
![]==false：true  先算![]，把数组转换为布尔取反=>false  =>false==false

```

## 语法

### JS中的判断操作语句
```
// >= / <= / == 常规比较
if(0){
 //=>不管你在条件判断中写什么，最后总要把其计算出TRUE/FALSE来判断条件是否成立（把其它类型的值转换为布尔类型，只有 0/NaN/''/null/undefined 是false，其余都是true）
}

if('3px'+3){
 //=>在JS中，+ - * / % 都是数学运算，除 + 以外，其余运算符在运算的时候，如果遇到了非数字类型的值，首先会转换为数字类型（Number），然后再进行运算
 
 //=>+ 在JS中除了数学相加，还有字符串拼接的作用（如果运算中遇到了字符串，则为字符串拼接，而不是数学相加）

 '3px'+3 =>'3px3'
}
if('3px'-3){
 '3px'-3 =>NaN
}

```

```
BAT面试题：

var num = parseInt('width:35.5px');
if(num==35.5){
 alert(0);
}else if(num==35){
 alert(1);
}else if(num==NaN){
 alert(2);
}else if(typeof num=='number'){
    //=>先算typeof num
    //=>在做比较
 alert(3);//=>alert输出的都是字符串格式的 '3'
}else{
    alert(4);
}

===> 3
```

### 三元运算符

```
//=>如果三元运算符中的某一部分不需要做任何的处理，我们用 null/undeifned/void 0... 占位即可
var num = 12;
num>10?num++:null;

//=>如果需要执行多项操作，我们把其用小括号包裹起来，每条操作语句用逗号分隔
num=10;
num>=10?(num++,num*=10):null;

```

## 函数

### 函数的运行机制

```
function fn(){
 var total=10;
 total+=10;
 total=total.toFixed(2);
 console.log(total);
}
fn();

【创建函数】
1. 函数也是引用类型，首先会开辟一个新的堆内存，把函数体中的代码当做“字符串”存储到内存中（对象向内存中存储的是键值对）
2. 把开辟的堆内存地址赋值给函数名(变量名)

此时我们输出fn（切记不是fn()）代表当前函数本身
如果我们执行fn()，这是把函数执行
所以是否加小括号是两种不同本质的操作

【函数执行】
目的：把之前存储到堆内存中的代码字符串变为真正的JS代码自上而下执行，从而实现应有的功能

1.函数执行，首先会形成一个私有的作用域（一个供代码执行的环境，也是一个栈内存）
2.把之前在堆内存中存储的字符串复制一份过来，变为真正的JS代码，在新开辟的作用域中自上而下执行 


**普通函数执行**：

1.形成一个私有的作用域 2.形参赋值 3.变量提升 4.代码执行 5.栈内存释放问题

**构造函数执行步骤**：

1.像普通函数执行一样，形成一个私有作用域（栈内存） >形参赋值 变量提升

2.构造函数独有操作

创建实例对象： 在Js代码执行之前，首先在当前形成的私有栈中创建一个实例对象（创建一个堆内存：暂时不存储任何东西），并且让函数中的执行主体（this)指向这个新的堆内存（this ===> 创建的对象）

3.代码自上而下执行

4.构造函数独有操作:

把之前创建的堆内存地址返回（无需return,浏览器默认返回）(也就是开始创建的对象其实就是当前Fn这个类的一个实例，我们让this指向这个实例，代码执行中的this.xxx = xxx都是给实例设置“私有属性”，最后浏览器会把默认创建的实例返回，供外面接收。)

return 是一个基本值，返回的结果依然是类的实例，没有受到影响
如果返回的是引用值，则会把默认返回的实例覆盖，此时接收到的结果就不再是当前类的实例了

```

### 栈内存： 作用域

1.提供一供JS代码自上而下执行的环境（代码都是 在栈中执行的） 2.由于基本数据类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去，当栈内存被销毁，存储的那些基本值也跟着销毁了

### 堆内存：引用值对应的空间

1.存储引用类型值的（对象：键值对， 函数：代码字符串） => 当前堆内存释放销毁，那么这个引用值彻底没了 => 堆内存的释放：当堆内存没有被任何的变量或者其他东西所占用，浏览器会在空闲的时候，自主的进行内存回收，把所有不被占用的堆内存销毁掉（谷歌浏器）

### JS中的堆栈内存释放

堆内存 释放：
让所有引用堆内存空间地址的变量赋值为null即可（xxx = null 通过空对象指针null可以让原始变量（或者其它东西）谁都不指向，那么原有被占用的堆内存就没有被东西占用了，浏览器会销毁它）

栈内存释放：
一般情况下，当函数执行完成，所形成的的私有作用域（栈内存）都会自动释放掉（在栈内存找那个存储的值也都会释放掉，但是也有特殊不销毁的情况
函数执行完成，当前形成的栈内存中，某些内容（堆内存）被栈内存以外的变量占用了，此时栈内存不能释放（一旦释放外面就找不到原有内容了）

全局栈内存只有在页面关闭的时候才会被释放掉
如果当前栈内存没有被释放，那么之前在栈中存储的值，也不会被释放

### 变量提升：

当栈内存或者作用域形成，JS代码自上而下执行之前，浏览器首先会把所有带var和function关键字的进行提前的声明或者定义，这种预先处理的机制 称之为变量提升！

**在变量提升阶段，带 var 的只声明未定义 带 function 的声明和赋值都完成了**

es5: 在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性值（私有作用域中声明私有变量和window没啥关系）,全局变量和window中的属性存在“映射机制” ，window\.a属性改，全局变量a也改

私有作用域中，带var 和 不带也有区别：

带var的在私有作用域提升阶段，都声明为私有变量，和外界没有任何关系 2.不带var不是私有变量，会向他的上级作用域查找，看是否为上级的变量，不是，继续上查找，一直找到window为止（我么把这种查找机制叫： “作用域链”），也就是说我们在私有作用域中操作的这个非私有变量，是一直操作别人的

条件判断下的变量提升
当前作用域下，条件判断中，不管条件是否成立都要进行变量提升，新版本浏览器对于函数（在条件判断中的函数），不管条件是否成立，都只是先声明，没有定义，类似于var（条件判断下的变量提升，循环也算条件判断）

关于重名的处理：如果名字重复了，不会重新声明，但是会重新定义，不管是变量提升还是代码执行阶段皆是如此


### es5 函数执行做题总结

1.变量提升，看有没有变量重新赋值（ES6没有变量提升） 
2.是否是私有变量（函数中的全局函数名容易忽略），不是私有的话，变量是在哪个作用域创建，在哪几个地方发生改变，及时更改变量（自加自减特别注意，非私有变量及时更改） 
3.关于this，函数前面没点，this指向window，new 一个函数this指向 创建的实例， ES6中切断了全局变量和window属性的映射机制 
5.原型题图要画清楚


### 箭头函数

1. 不具备this, arguments
自己没有this, 找上一级的this(箭头函数的this是固定的，没有自己的this，是定义时的父级作用域或者叫执行上下文的this)

2. 如何更改this指向
a. call bind apply
b.let _this = this
c. =>

3. 如何确定this是谁
看执行时，谁调用的， 点前面是谁，this就是谁  
> 这是普通函数的this确定方法


## 数组方法

数组方法： 

```
ary[0] 获取第一项
ary[ary.length-1] 获取最后一项
```

会改变原有数组的：

push：向数组“末尾”追加新的内容,追加的内容（可以是一个，**也可是多个**）,返回新增后数组的长度
pop：删除数组最后一项，返回被删除的那一项内容
shift：删除数组中的第一项， 返回被删除的那一项内容
unshift： 向数组开始位置追加新内容，参数要新增的内容，返回新增后数组的长度
splice： `修改：ary.splice(n,m,x,...)` 从索引n开始删除m项（m可以为0,m不写就是一直删除到末尾），把X或者更多需要插入的内容（这部分内容可以没有，就是无需添加，也就是删除效果）存放到数组中索引N的“前面”，把删除的部分以一个新数组返回
reverse： 把数组倒过来排列，返回排列后的新数组, 改变原数组
sort: 给数组排序, 参数:无/函数, 原数组进行原地排序（即修改原数组），并返回该数组

```
//=>sort在不传递参数的情况下，只能处理10以内数字排序
var ary=[1,3,2,4,5,6,7,9,8];
ary.sort(); =>[1,2,3,4,5,6,7,8,9]

var ary=[18,1,23,27,2,35,3,56];
ary.sort(); =>[1, 18, 2, 23, 27, 3, 35, 56] 没有按照我们想象中的排序

//=>真实项目中，基于sort排序，我们都需要传递参数
var ary=[18,1,23,27,2,35,3,56];
ary.sort(function (a,b){
 return a-b;//=>升序  return b-a; 降序
});

```


```
//=>删除最后一项
ary.pop()
ary.splice(ary.length-1)
ary.length--

//=>向数组末尾追加新内容
ary.push(100)
ary.splice(ary.length,0,100)
ary[ary.length]=100

```

不改变原有数组的：

slice： 两个参数（n/m），从索引n开始（默认0），找到索引m处（不穿会提取到后面的所有元素），但是不包含m, 以一个新数组存储查找的内容并返回
concat： 实现多个数组(或者值)的拼接， 数组或者值， 返回拼接后的新数组
toString： 把数组转换为字符串，返回数组中的每一项用逗号分隔的字符串
join： 和toString类似，也是把数组转换为字符串，但是我们可以设置变为字符串后，每一项之间的连接符，参数是指定的链接符
indexOf / lastIndexOf： 检测当前值在数组中第一次或者最后一次出现位置的索引, 参数是要检测的值，有这个字符，返回大于等于零的索引，不包含这个字符，返回的结果是-1



除了这些数组方法，常用的还有：

filter: 接受函数参数,函数里返回的结果是TRUE或者FALSE，返回的是TRUE会把这一项存放到新数组中，不改变原数组
find
forEach
includes
keys
map
reduce / reduceRight
every
some
...

#### es6 数组扩展


find: 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

findIndex: 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。

另外，find,findIndex这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。

```
[NaN].indexOf(NaN) // -1

[NaN].findIndex(y => Object.is(NaN, y)) // 0 , findIndex方法可以借助Object.is方法做到发现NaN

```

entries()，keys() 和 values(): ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

includes: 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似
> 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。indexOf方法内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。

```
[NaN].indexOf(NaN)
// -1

[NaN].includes(NaN)
// true

```


Array.from()： 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。


```
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']

```

>另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)。Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)。


数组的空位: 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。`Array(3) // [, , ,]`

注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。

```
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false

ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。
ES6 明确将空位转为undefined。由于空位的处理规则非常不统一，所以建议避免出现空位。

```

for...of 循环: ES6引入了for...of循环,作为遍历所有数据结构的统一的方法,遍历获得键值,一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口,就可以用for...of循环遍历它的成员, 包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。

JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。

```
var arr = ['a', 'b', 'c', 'd'];

for (let a in arr) {
  console.log(a); // 0 1 2 3
}

for (let a of arr) {
  console.log(a); // a b c d
}


```

数组的遍历方法: 

map: map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回,原数组没有变化。map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。

forEach: forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。

ﬁlter: filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。


every, some: 它们接受一个函数作为参数，所有数组成员依次执行该函数, every每一个成员的返回值都返回true才返回true, some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。

> 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。

reduce,reduceRight: reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。

```
[1, 2, 3, 4, 5].reduce(function (pre, cur) {
  return pre + cur;  // 要理解 pre 表示的是这个回调函数上次返回的结果， 如果是第一次执行： pre表示的是 传入的初始值 或者 数组第一项；
}, 10);
// 25

```



### 字符串方法：

字符串是基本数据类型，字符串的每一次操作都是值直接的进行操作，不像数组一样是基于空间地址来操作的，所以不存在原有字符串是否改变这一说，肯定都是不变的

substr:也是字符串截取的方法，用法是：str.substr(n,m)，从索引n开始截取m个字符

substring:  和slice语法一模一样，唯一的区别在于：slice支持负数索引，而substring不支持负数索引
slice: str.slice(n,m) 从索引n开始找到索引为m处(不包含m)，把找到的字符当做新字符串返回

charAt/charCodeAt: charAt根据索引获取指定位置的字符，charCodeAt不仅仅获取字符，它获取的是字符对应的Unicode编码值(ASC II码值)

toUpperCase/toLowerCase: 实现字母的大小写转换，toUpperCase小写转大写，toLowerCase大写转小写
indexOf/lastIndexOf:可以获取字符在字符串中第一次或者最后一次出现位置的索引，有这个字符，返回大于等于零的索引，不包含这个字符，返回的结果是-1，所以可以基于这两个方法，验证当前字符串中是否包含某个字符
split:和数组中的join相对应，数组中的join是把数组们一项按照指定的连接符变为字符串，而split是把字符串按照指定的分隔符，拆分成数组中每一项
replace: 替换字符串中的原有字符, 参数：原有字符，要替换的新字符, 返回：替换后的字符串

```
//=>把“zhufeng”替换为“珠峰”
var str = 'zhufeng2017zhufeng2018';
str = str.replace('zhufeng','珠峰'); //=>在不使用正则的情况下，每执行一次replace只能替换一个 “珠峰2017zhufeng2018”
str = str.replace('zhufeng','珠峰'); //=>“珠峰2017珠峰2018”

//===================
str = str.replace(/zhufeng/g,'珠峰');


```

字符串中还有很多常用方法:

includes： 查找字符串是否包含
trim： 去除字符串的头尾空格:


### 数学函数：

abs： 取绝对值
ceil： 向上取整
floor： 向下取整
round： 四舍五入（在两个整数之间，离谁近取谁，对于负数.5 不入， -1.5 ==> 1 ）
random： 获取0~1之间的随机小数， 
```
Math.round(Math.random()*(m-n)+n)：获取n-m之间的随机整数

```
max/min: 获取最大值和最小值, 参数为 0 个或多个数字，将在其中选择。
pow： 取幂（N的M次方）
sqrt： 开平方

## Set 及其实例方法

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

Set 本身是一个构造函数，用来生成 Set 数据结构。

Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。

```
// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll('div'));
set.size // 56

// 去除数组的重复成员
[...new Set(array)]

```

Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。

Set 结构的实例属性：

```
size: 返回Set实例的成员总数。
```

Set 实例的 操作方法：

```
add(value)：添加某个值，返回 Set 结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。


s.add(1).add(2).add(2);
// 注意2被加入了两次

s.size // 2

s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2);
s.has(2) // false

```

Set 结构实例的遍历方法:

```
keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员

```

需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。

```
for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]

```
Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。

```
Set.prototype[Symbol.iterator] === Set.prototype.values
// true

```

### WeakSet

WeakSet 对象允许你将弱保持对象存储在一个集合中。

WeakSet 只能是对象的集合，而不能像 Set 那样，可以是任何类型的任意值。
WeakSet 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 WeakSet 中对象的引用，那么这些对象会被当成垃圾回收掉。

ps:  这也意味着 WeakSet 中没有存储当前对象的列表。正因为这样，WeakSet 是不可枚举的。

## Map 

Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。

```
const m = new Map();
const o = {p: 'Hello World'};

m.set(o, 'content')
m.get(o) // "content"

m.has(o) // true
m.delete(o) // true
m.has(o) // false

上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。

```

```
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"

上面代码在新建 Map 实例时，就指定了两个键name和title。

```

注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

Map 结构的实例的属性和操作方法:

```

size: size属性返回 Map 结构的成员总数。

set(key, value): set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。

let map = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');


get(key): get方法读取key对应的键值，如果找不到key，返回undefined。

has(key): has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

delete(key): delete方法删除某个键，返回true。如果删除失败，返回false。

clear(): clear方法清除所有成员，没有返回值。

```

Map 结构 实例的遍历方法:Map 结构原生提供三个遍历器生成函数和一个遍历方法。

```
keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。

```

需要特别注意的是，Map 的遍历顺序就是插入顺序。

### WeakMap

WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。**其键必须是对象**，而值可以是任意的。

普通 Map 的 key 如果是一个可引用对象，这个引用是会被 gc 标记为一次引用，即使其他地方没有对 key 的引用，但是 map 这里还有一次引用，那么就不会被 gc 回收。但是 WeakMap 里对 key 的存储不会被 gc 计次，只要是其他地方对 key 没有了引用，那么 gc 就认为 key 对象引用次数为0，就 可以进行回收了，回收之后， WeakMap 里面的 key 也不复存在了。

正由于这样的弱引用，WeakMap 的 key 是不可枚举的（没有方法能给出所有的 key）。如果 key 是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。

## Symbol

ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

基本数据类型, 唯一的值
Symbol 值通过Symbol函数生成

Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

```
let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // "Symbol(foo)"
s2.toString() // "Symbol(bar)"

```

上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。

注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。

```
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');

s1 === s2 // false


```

## Iterator（遍历器）的概念

JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。

遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。

当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。
一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。

ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。

原生具备 Iterator 接口的数据结构如下。

Array
Map
Set
String
TypedArray
函数的 arguments 对象
NodeList 对象

其他类型，如 Object 对象 {}是没有的；

```
let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator]();

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }


```

## Object

## dom

### 获取页面中的DOM元素

document.getElementById
> 在整个文档中，通过元素的ID属性值，获取到这个元素对象

```
var oBox = document.getElementById('box');

1. 同过getElementById获取的元素是一个对象数据类型的值（里面包含很多内置的属性）
typeof oBox  =>"object"

2. 分析包含的属性
className：存储的是一个字符串，代表当前元素的样式类名
id：存储的是当前元素ID值（字符串）

innerHTML：存储当前元素中所有的内容（包含HTML标签）
innerText：存储当前元素中所有的文本内容（没有元素标签）

onclick：元素的一个事件属性，基于这个属性，可以给当前元素绑定点击事件
onmouseover：鼠标滑过事件
onmouseout：鼠标离开事件

style：存储当前元素所有的 "行内样式" 值（获取和操作的都只能是写在标签上的行内样式，写在样式表中的样式，无法基于这个属性获取到）

...
```

[context].getElementsByTagName
> 在指定的上下文中，通过元素的标签名获取一组元素集合

document.getElementsByName(): 它的上下文也只能是document,在整个文档中，基于元素的name属性值获取一组节点集合（也是一个类数组）
getElementsByTagName: 在指定的上下文中，根据标签名获取一组元素集合
getElementsByClassName: 在指定的上下文中，基于元素的样式类名，获取到一组元素集合

querySelector: 在指定的上下文中基于选择器（类似于css选择器）获取到指定的元素对象（获取的是一个元素，哪怕选择器匹配了多个，我们只获取第一个）
querySelectorAll: 在querySelector的基础上，我们获取到选择器匹配到的所有元素，结果是一个节点集合（nodeList)

document.head： 获取HEAD元素对象
document.body： 获取BODY元素对象
document.documentElement： 获取HTML元素

```
// 获取一屏幕的宽高，并且兼容所有浏览器

document.documentElement.clientWidth  || document.body.clientWidth

document.documentElement.clientHeight ||
document.body.clientHeight

```

在Js中，默认会把元素的ID设置为变量，而且ID重复，获取或的结果就是一个集合，包含所有ID项，不重复就是一个元素对象（类似于ById 获取的结果）


parentNode： 获取当前节点唯一的父亲节点
childNodes： 获取当前元素的所有子节点
children： 获取当前元素所有的元素子节点


previousSibling： 获取当前节点的上一个哥哥节点（获取的哥哥节点可能是元素也可能是文本等）
previousElementSibling： 获取上一个哥哥元素节点
nextSibling： 获取当前节点的下一个弟弟节点
nextElementSibling： 下一个弟弟元素节点

firstChild： 获取当前元素的第一个子节点（可能是元素或者文本等）
firstElementChild
lastChild： 获取当前元素的最后一个子节点（可能是元素或者文本等）
lastElementChild

document.createElement([标签名])： 创建一个元素标签（元素对象）
document.createDocumentFragment()
appendChild： 把一个元素对象插入到指定容器的末尾
removeChild： 在指定容器中删除某一个元素
insertBefore： [container].insertBefore([newEle], [oldEle])，把一个元素对象插入到指定容器的某一个元素标签之前
cloneNode： 把某一个节点进行克隆，`[curEle].cloneNode()`:浅克隆，只克隆当前的标签，`[curEle].cloneNode(true)`:深克隆，当前标签以及其里面的内容都一起克隆了

set/get/removeAttribute： 设置/获取/删除 当前元素的某一个自定义属性

### 节点

在一个HTML文档中出现的所有东西都是节点，包括： 元素节点（HTML标签）， 文本节点（文字内容）， 注释节点（注释内容），注释节点（注释内容）等，每一种类型的节点都会有一些属性区分自己的特性和特征

nodeType:  节点类型
nodeName: 节点名称
nodeValue:  节点值

### DOM的回流（reflow）和重绘（repaint）

重绘：当某一个DOM元素样式更改（位置没变只是样式更改，例如：颜色变为红色...)，浏览器会重新渲染这个元素

当DOM元素的结构或者位置发生改变（删除，增加，改变位置，改变大小...)都会引发回流，所谓回流，就是浏览器抛弃原有计算的结构和样式，重新进行DOM TREE 或者 RENDER TREE，非常非常非常...消耗性能


### js盒模型

在JS中通过相关的属性可以获取（设置）元素的样式信息，这些属性就是盒子模型属性（基本上都是有关于样式的）

特点： 获取的结果是没有单位的， 结果是整数（会自动进行四舍五入）



clientWidth & clientHeight： 获取当前元素可视区域的宽高（内容的宽高+左右/上下padding)，和内容是否有溢出无关（和是否设置了overflow:hidden无关），就是我们自己设定的内容的宽高+PADDING
对于浏览器来说，可视区域其实就是一屏幕的宽度和高度

```
获取当前页面一屏幕(可视区域)的宽度和高度
document.documentElement.clientWidth || document.body.clientWidth
document.documentElement.clientHeight || document.body.clientHeight

```

clientTop & clientLeft: 获取（上/左）边框的宽度

offsetWidth & offsetHeight: 在client的基础上加上border (和内容是否溢出无关)

scrollWidth & scrollHeight: 真实内容的宽高（不一定是自己设定的值，因为可能存在内容溢出，有内容溢出的情况下，需要把溢出的内容也算上） + 左/上 padding ,而且是一个约等于的值（没有溢出时，宽高和client一样）

```
=>获取当前页面的真实宽高（包含溢出的部分）
document.documentElement.scrollWidth || document.body.scrollWidth
document.documentElement.scrollHeight || document.body.scrollHeight

```


理解： 

js 盒模型，有三种类型（client 盒内, offset 盒子， scroll 卷去）, 每种类型各有两组属性表示元素尺寸的width/height, 表示元素与外界关系的left/top;

三种类型: client 盒内 (包括内容+padding), offset 盒子本身， 也就是client + 边框border，scroll 如果内容不溢出，结果就是盒内client, 如果溢出就是真实宽高。

有特殊:

clientLeft/Top 表示边框宽度;
offsetLeft/Top 距离其父参照物（一般父参照物都是body, 如果给元素增加一个定位属性， 会让它的子孙元素父参照物指向当前元素）的左偏移， 上偏移（从边框外沿开始算）
scrollLeft/Top 滚动条卷去的宽度/高度, js盒模型， 13个属性，只有这两个是可读写的，快速定位到底部scrollTop = 0;



#### offsetParent 

offsetParent: 当前盒子的父级参照物

> “参照物” ： 同一个平面中，元素的父级参照物和结构没有必然联系，默认他们的父级参照物都是body(当前平面最外层的盒子) ，body的父级参照物是null
> 参照物是可以改变的： 构建出不同的平面即可（使用zIndex, 但是这个属性只对定位有作用），所以改变元素的定位（position:relative/absolute/fixed)可以改变其父级参照物
> 例如：把outer脱离文档流，独立出一个新的平面，它的后代元素的父级参照物都是outer


offsetTop/offsetLeft : 获取当前盒子距离其父级参照物的偏移量（上偏移/左偏移）,当前盒子的外边框开始到父级参照物的内边框

#### scroll

scrollTop/scrollLeft: 滚动条卷去的宽度或者高度

最小： 0
最大：真实页面的高度 - 一屏幕的高度

`document.documentElement.scrollHeight - document.documentElement.clientHeight`

3.在JS盒子模型13个属性中，只有scrollTop/Left 是“可读写属性”，可以修改它的值，其余都是“只读”属性

### 通过JS盒子模型获取值的特点

1. 获取的都是数字，不带单位, 
2. 获取的都是整数，不会出现小数（一般会四舍五入，尤其是获取的偏移量）
3. 获取的结果都是复合样式值（好几个元素的样式组合在一起的值），如果只想获取单一样式值（例如： 只想获取padding)，我们的盒子模型属性就操作不了了（这不能说没有用，真实项目中，有时候我们就是需要获取组合的值来完成一些操作）

### 获取元素的具体的某个样式值

1. [元素].style.xxx 操作获取

> 只能获取所有写在元素行内的样式（不写在行内上，不管你写没写都获取不到，真实项目中我们很少会把样式写在行内上）

2. 获取当前元素所有经过浏览器计算的样式：

```
window.getComputedStyle([元素], [元素伪类， 一般都不写或者写null])获取到当前元素所有被浏览器计算过的样式（对象）
```

### 给元素设置样式

JS中给元素设置样式只有两种：

JS元素的样式类名（前提： 样式类及对应的样式已经处理完成）
通过行内样式设置 xxx.style.xxx=xxx



## git

git是一个分布式代码版本管理控制系统

1. 建立关联

git remote -v: 查看所有关联信息
git remote add xxx 远程仓库git地址: 建立关联
git remote remove xxx: 移除关联

我们远程仓库关联在一起的名字默认是： origin,当然自己可以随意修改

2. 推送

git pull origin(远程仓库名字) master(远程分支)
git push origin(远程仓库名字) master(远程分支)

一般本地新建分支后可以  git push -u origin dev , 推送并追踪


## node

node并不是一门语言，它是一个工具或者环境

- 基于V8引擎（webkit）渲染和解析JS的
- 单线程
- 无阻塞I/O操作
- 事件驱动
- ...

之所以把node称之为服务器端语言，是因为node给予JS操作服务器的能力：我们在服务器端安装node，只用js完成服务器端需要处理的一些事情，最后把写好的js代码交给node环境运行即可


### NPM模块管理 

安装完成node后，基本上自带npm模块管理器


### call/bind/apply

call 让传入的第一个参数能够使用另一个对象的方法；

fn.call(p1,[param]......): 当前实例（函数FN)通过原型链的查找机制，找到Function.prototype 上的call 方法,fn.call() 把找到的call 方法执行,当call方法执行的时候，内部处理了一些事情:

改变fn里的this: 首先把要操作函数中的this关键字变为call方法第一个传递的实参
把要操作的函数执行： 把第二个以后的传递进来的实参传递给函数，并把要操作的函数执行

```

Function.prototype.call = function (context, ...params) {
  context = context? Object(context): globalThis; // globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（

  let fn = Symbol('fn'); // 使用Symbol的原因：防止key 重复， 简写时这一步不要也行；
  context[fn] = this;  // 这里的this，表示调用call的函数

  const res = context[fn](...params)  // 对象上属性函数执行，this 指向对象, 因为对象上的属性是通过xx.调用的
  delete context[fn]
  return res
}


或者


Function.prototype.myCall = function(obj){
	obj = obj ? Object(obj): globalThis;
	obj.fn = this; // 关键点: 利用 . 的机制改变函数this指向
	const res = obj.fn([...arguments].slice(1));  // arguments是类数组，用展开运算符变成真数组
	delete obj.fn;
	return res;
}

```


apply: 和call基本上一模一样，唯一区别在于传参方式, apply把需要传递给FN的参数放到一个数组（或者类数组中）中传递进去

bind: 语法和call一模一样，唯一的区别在于立即执行还是等待执行, fn.bind(obj,10,20), 改变fn中的this,此时fn并没有执行

### call apply 的作用

改变函数中的this

> 可以基于call让类数组借用数组原型上的方法（例如：借用slice实现把类数组转换为数组
> 可以基于call 实现继续

## 扩展运算符 ...

收集运算符：把数组或者参数序列没有匹配的剩余项，以一个数组形式赋值给变量, 收集

展开运算符：把数组(对象/类数组)中的每一项展开，变为 xxx,xxx,xxx...的形式

## JSON

JSON不是一种数据类型，而是一种数据格式，只要把对象的属性名用双引号括起来，此时的对象就不再称之为普通对象，而是叫做JSON格式的对象

```
window.JSON 对象中有两个方法：
1.parse：把JSON格式的字符串转换为对象   JSON.parse()
2.stringify：把对象转换为JSON格式的字符串

```

## 正则

### 创建正则的两种方式

1. let reg1 = /^\d+$/g => 字面量方式
2. ar reg = new RegExp(pattern, attributes); => 构造函数方式

>  参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。
> 参数 attributes 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。

要注意的点： 

[…] 方括号内任意字符
[^…] 不在方括号内任意字符


正则捕获方法有：

[正则方法]
exec
test

[字符串方法]
replace
split
match
...



exec： 如果当前正则和字符串不匹配，捕获的结果是null， 如果匹配，捕获的结果是一个数组

```
0：大正则捕获的内容
index: 正则捕获的起始索引
input: 原始操作的字符串
...

```

正则的捕获有懒惰性,只能捕获到第一个匹配的内容，剩余的默认捕获不到， 解决正则懒惰性，我们需要加全局修饰符g


match： 正则不加G返回第一个匹配的即可，加了G，把所有匹配的内容都捕获到，最后统一存储到一个数组中 （注意参数不是回调函数，只有一个正则表达式）

在正则捕获的时候如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到（数组第一项），而且把小分组匹配的内容也单独抽取出来（数组中的第二项开始就是小分组捕获的内容） = > "分组捕获"，而?: 是用来阻止分组捕获的，只匹配不捕获

replace ：用reg 正则和str字符串进行匹配，匹配几次就替换几次，每一次都是把当前“大正则”匹配的结果用第二个传递的参数替换掉了，
注意第二个参数可以是回调函数

有分组加g的情况下，exec，replace（参数回调函数里）， 匹配的结果数组都是： 匹配的内容， 第一个小分组开始依次匹配的内容...

## 正则进阶

从ast 看 正则
https://astexplorer.net/

简单认知
简单字符

/abc/ simple

元字符

/\d\d/ meta

任一字符匹配

/[abc]/ CharacterClass 字符类

进阶
重复次数

贪婪： /a{1,3}/.exec('aaab') range 范围 quantifier 数量修饰语 greedy 贪婪模式：尽量多的匹配，默认模式

非贪婪 ?： /a{1,3}?/.exec('aaab') .*？

组

捕获: /(aaa)bbb/.exec('aaabbb') Group capturing: 捕获, 捕获内容能提取出来，对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，缓冲区从1开始编号, 可以用\n访问,n为十进制数

不捕获 ?：： /(?:aaa)bbb(dd)/.exec('aaabbbddd')

断言

/aaa(?=bbb)/.exec('aaabbbb') Lookahead 先行,往未来看 Assertion 断言 断言后面跟着啥
/aaa(?=bbc)/.exec('aaabbbb')

/aaa(?!bbb)/.exec('aaabbbb') negative : 否定 断言后面不能跟啥
/aaa(?!bbb)/.exec('aaabbc')

同理

/(?<=bbb)aaa/.exec('bbbaaa') Lookbehind 后行，向过去看 断言前面有啥
/(?<=bbb)aaa/.exec('bbcaaa')

/(?<!bbb)aaa/.exec('bbcaaa') 断言前面没有啥
/(?<!bbb)aaa/.exec('bbbaaa')

反向引用

/bbb(.?)ccc\1/.exec('bbbgkhcccgkh') Backreference 向后引用
/bbb(.?)ccc\1/.exec('bbbgkhcccgke')


```
加深理解

1.  正则优先级（理解括号）

\ 转译符最高

其次是 （）

2.  \1

是对第一个括号里匹配值得引用，还可以\2, \3等

匹配重复字符： /(\w)\1+/

3.  replace

第二个参数里

`$1、$`2、...、\$99 => 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。

\$&   ===> 与 regexp 相匹配的子串。

4.

/^(0|\[1-9]\[0-9]{0,7})(.\[0-9]{1,2})?\$/

最大支持8位整数+2位小数

5. 不是字母、数字、下划线的替换为空

'A man, a plan, a canal: Panama'.replaceAll(/[^\w]/g, '');  // 'AmanaplanacanalPanama'


也可以用\W， 表示匹配非字母、数字、下划线， 还可以写成[^A-Za-z0-9_] 

如果仅仅不是数字和字符的[^A-Za-z0-9]


```

## ES6新语法

1.let / const

和ES5中的VAR的区别
1)let不存在变量提升机制（变量不允许在声明之前使用）
2)let不允许重复声明
3)在全局作用域中基于let声明的变量不是window的一个属性，和他没关系
4)typeof 未被声明的变量 =>不是undefined而是报错（暂时性死区）
5)let会形成块级作用域（类似于私有作用域，大部分大括号都会形成块作用域）
…

2.解构赋值
3.“…” 拓展、剩余、展开运算符
4.ES6中的模板字符串
5.箭头函数

和普通函数的区别
1)没有arguments，但是可以基于…arg获取实参集合（结果是一个数组）
2)没有自己的this，箭头函数中的this是上下文中的this

6.Promise（async/await）
7.class（ES6中创建类的）
8.interator（for of 循环）
9.Map / Set

## 请说出你对 “重排(回流)和重绘读写分离” 的理解

浏览器渲染一个页面的时候是按照“先创建DOM树->再加载CSS->生成渲染树 RENDER TREE->把渲染树交给浏览器（GPU）进行绘制”，如果后期我们修改了元素的样式（但是没有改变大小和位置），浏览器会把当前元素重新生成渲染树，然后重新渲染，这个机制是重绘，但是一旦元素的位置或者大小等发生改变，浏览器就要从DOM树重新计算渲染，这个机制是回流(重排)，不论是重排还是重绘都非常的消耗性能

在我的以前项目中，我特意的重视了这个问题，尽量减少操作DOM引发的回流和重绘问题，常用的解决方案：

1.需要动态向页面追加元素的时候，基于文档碎片或者先把需要增加的所有元素拼接成字符串，最后统一进行增加

2.读写分离：把统一修改样式都放到一起执行，新版浏览器都有一个自己检测的机制，如果发现下面紧挨着的操作也是修改元素的样式，会把所有修改的事先存起来，直到遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘

当然还有一些其它的办法，这些是最常注意的，我认为减少DOM的回流重绘是非常重要的性能优化手段之一

## 谈一下你对作用域链和原型链的理解

作用域：

当前函数执行，形成一个私有作用域a, a的上级作用域是谁，和他在哪里执行没有关系，和他在哪创建(定义)的有关系，在哪创建，他的上级作用域就是谁

作用域链

>函数执行会形成一个私有的作用域，形参和在当前私有作用域中声明的变量都是私有变量，当前的私有作用域有自我保护机制，私有变量和外界是没有关系的，但是如果私有作用域中遇到一个非私有的变量，则向它的上级作用域找，如果还不是上级作用域私有的，则继续向上查找，一直找到window为止。这种变量一层层向上查找的机制就是“作用域链机制”

原型链

> 它也是一种查找机制，实例首先在自己的私有属性中进行属性的查找，如果不是私有属性，基于__proto__ 向所属类的原型上进行查找，如果在找不到，则继续基于__proto__ 向上查找，一直找到Object.prototype为止，例如：obj.hasOwnProperty() 这里调取的hasOwnProperty这个属性就是找到Object.prototype才找到的


Object 原型 指向null， 也就是原型链尽头是null;
Function 原型指向 Object 原型对象；


## this 汇总

this: 当前方法执行的主体(谁执行的这个方法,那么this就是谁，所以this和当前方法在哪创建的或者在哪执行的都没有必然的关系）

1. 给元素的某个事件绑定方法，方法中的this都是当前操作的元素本身
2. 函数执行(自执行函数也算)，看函数前面是否有点，有的话，点前面是谁，this就是谁，没有点，this是window(在JS的严格模式下，没有点，this是undefined)
3. 构造函数执行，方法中的this，一般都是当前类的实例
4. 箭头函数中没有自己的this,this是上下文中的this
5. 在小括号表达式中，会影响this的指向（最后一项中this改成window, 严格模式下改成undefined)

```
let obj = {
    fn: function () {
        console.log(this);
    }
};
obj.fn();//=>this:obj
(12, obj.fn)();//=>this:window

```
6. 使用call/apply/bind 可以改变this指向（非严格模式下，call/apply/bind第一个参数不写或者写null和undefined,this都是window,严格模式下写谁this就是谁，不写是undefined


## 数组去重

1.对象键值对处理（推荐）
Array.prototype.myUnique = function () {
    //=>this:ary 我们需要操作的数组，如果不想改变原有的数组，我们需要把要操作的数组克隆一份一模一样的处理，处理的都是克隆的这个数组
    let _this = [...this],
        obj = {};
    for (let i = 0; i < _this.length; i++) {
        let item = _this[i];
        if (typeof obj[item] !== 'undefined') {
            //=>当前迭代的这一项在数组中已经存在，我们把这一项在数组中干掉
            // _this.splice(i, 1); [后面项移位，消耗性能]
            _this[i] = _this[_this.length - 1];
            _this.length--;
            i--;
            continue;
        }
        obj[item] = true;
    }
    obj = null;
    return _this;
};

## 闭包

1.闭包是JS中一个非常重要的机制，我们很多编程思想，业务逻辑，设计模式都是基于闭包完成，先说一下我对闭包的理解：闭包就是函数执行产生一个私有作用域（不销毁）， 在这个作用域中的私有变量和外界互不干扰，而且作用域（栈）不销毁，这些私有变量存储的值也都保存下来了，所以整体来说闭包就是为了保护和保存变量的

## 继承

```
call 继承，继承父类实例方法

在子类构造函数中，用父类调用call

父类.call(this, 参数)


原型继承， 继承原型方法
e.__proto__ = EventEmitter.prototype;
e.__proto__ = Object.create(EventEmitter.prototype);
function G(){}; Object.setPrototypeOf(G.prototype, EventEmitter.prototype);  (es6方式)
extends   (es6方式)

```


es5 写继承

A父的私有变为B的私有，A父的公有变为B的公有

```
 Object.create：内置Object类天生自带的方法
   1.创建一个空对象
   2.让新创建的空对象的__proto__指向第一个传递进来的对象（把OBJ作为新创建空对象的原型）


function A() {
  this.x = 100; // 私有属性
}
A.prototype = {
  constructor: A,
  getX: function(){ // 公有属性
    console.log(this.x)
  }
}


function B() {
  A.call(this);  // 执行A父方法，把A父的私有变成B的私有 f.x = 100
  this.y = 200;
}

B.prototype = Object.create(A.prototype);  // 不直接写B.prototype = A.prototype， 避免轻易修改父类A原型上的东西

let f= new B();

```

es6

```
class B extends A {//=>extends类似于实现了原型继承
    constructor() {
        super();//=>类似于CALL继承：在这里SUPER相当于把A的CONSTRUCTOR给执行了，并且让方法中的THIS是B的实例，SUPER当中传递的实参都是在给A的CONSTRUCTOR传递
        this.y = 200;
    }

    getY() {
        console.log(this.y);
    }
}

let f = new B();


```

## 事件

事件就是元素天生自带的行为，我们操作元素，就会触发相关的事件行为；

事件绑定：给元素天生自带的事件行为绑定方法，当事件触发，会把对应的方法执行；

【鼠标事件】

click: 点击（ PC端是点击，移动端的click代表单击，移动端使用click会有300ms的延迟的问题， 单击和点击的区别在于，点击是不管你点的快和慢，只要点了，事件就触发了，单击是在一段时间内【300ms】只点一次,点多次算是双击）
dblclick: 双击

mouseover: 鼠标经过
mouseout:鼠标移除
mouseenter: 鼠标进入
mouseleave: 鼠标离开
> over: 属于滑过（经过）事件，从父元素进入到子元素，属于离开了父元素，会触发父元素的out， 触发子元素的over
> enter: 属于进入，从父元素进入子元素，并不算离开父元素，不会触发父元素的leave，会触发子元素的enter
> enter 和 leave 阻止了事件的冒泡传播，而over 和 out 还存在冒泡传播的
> 对于有子元素的鼠标经过操作，使用mouseleave和mouseenter，更能简单归化操作

mousemove: 鼠标移动
mousewheel: 鼠标滚轮滚动

mousedown: 鼠标按下（鼠标左右键都起作用，它是按下即触发，click是按下抬起触发，而且是先把down和up 触发，然后才会触发click）
mouseup: 鼠标抬起

【键盘事件】
keydown: 键盘按下
keyup: 键盘抬起
keypress : 和 keydown类似，onkeypress 属性在按下按键时触发。只不过keydown返回的是键盘码，keypress返回的是ASCII码值

input : 内容改变事件，由于PC端有实体物理键盘，可以监听到键盘的按下和抬起，但是移动端是虚拟键盘，所以keydown和keyup 在大部分手机上都没有，我们使用input事件统一代替他们

【表单元素常用事件】

focus: 获取焦点
blur: 失去焦点
change: 内容改变（select 下 option被选中可以用这个事件（onclick在option下无效））
...

change 内容改变失去焦点后触发（也就是停止输入后，点了一次别的地方，丢失焦点）
input 是键盘抬起时触发

【其他常用事件】

load: 加载完成
unload: 页面关闭(页面卸载)或者浏览器窗口已关闭。 在用户从页面导航离开时发生（通过点击链接、提交表单或者关闭浏览器窗口等等）。
beforeunload: 页面关闭之前
scroll: 滚动条滚动
resize: 大小改变事件 window.onresize = function(){};当浏览器窗口大小发生改变，会触发这个事件，执行对应的事情


【移动端手指事件】

touch单手指操作

touchstart: 手指按下
touchmove: 手指移动
touchend: 手指离开
touchcancel: 因为意外情况导致手指操作取消（比如： 意外关机）


gesture 多手指操作

gesturestart: 手指按下
gesturechange: 手指移动
gestureend: 手指离开

【H5中的audio/video音视频事件】

canplay: 可以播放（播放过程中可能出现由于资源没有加载完成，导致卡顿）
canplaythrough: 资源加载完成，可以正常无障碍播放

### 事件绑定

1.DOM0 级事件绑定

```
[element].onxxx = function(){};

```

DOM0事件绑定的原理： 就是给元素的某一个事件私有属性赋值（浏览器会建立监听机制，当我们触发元素的某个行为，浏览器会自己把属性中赋的值执行）

DOM0事件绑定，只允许给当前元素的某个事件行为绑定一个方法，多次绑定，后面绑定的内容会替换前面绑定的，以最后一次绑定的方法为主

2. DOM2级事件绑定

```
[element].addEventListener('xxx',function(){},false);

removeEventListener是移除(使用的方法都是EventTarget.prototype定义的，window也是EventTarget的实例)
```

DOM2 基于 addEventListener 完成事件绑定，是基于‘事件池机制’完成的,

当我们触发box的click行为后，浏览器会到事件池中‘按照顺序’（按照其存放增加的顺序）依次把之前监听的方法执行.

事件池机制: 浏览器其实只有一个事件池, 事件池记录了序号，元素，事件类型，方法，阶段，会有一个类似于表格的统计, 
当添加时，浏览器会到事件池中筛选： 按照元素，事件类型，方法，阶段，严格筛选，如果都一样，属于重复，只要有一个不一样就不是重复，重复是不会向事件池中添加的

DOM2 级事件绑定可以给当前元素的某一个事件行为绑定‘多个不同的方法’

#### DOM0 和DOM2 事件绑定的区别
1.机制不一样

DOM0采用的是给私有属性赋值，所以只能绑定一个方法
DOM2采用的是事件池机制，所以能绑定多个不同的方法

2. 移除操作

```
dom0:

box.onclick = function(){};

box.onclick = null;//=>赋值为NULL就移除了（所以不需要考虑绑定的是谁）


dom2: 
box.addEventListener('click',function (){} )，
DOM2在移除的时候必须清楚要移除哪个方法，才能在事件池中移除掉，所以基于DOM2做事件绑定，我们要有‘瞻前顾后’的思路，也就是绑定的时候考虑下如何移除（技巧： 不要绑定匿名函数，都绑定实名函数，才能在事件池中移除）

box.removeEventListener('click', function () {
   console.log(1);
   });

```

3. DOM2 事件绑定中增加了一些DOM0 无法操作的事件

例如： DOMContentLoaded事件（当页面中的HTML结构加载完成就会触发执行）

DOM0和DOM2可以共存，执行顺序和编写顺序有关

```
 //=>可以共存，执行顺序和编写顺序有关系
    box.addEventListener('click', function () {
        console.log(2);
    });
    box.onclick = function () {
        console.log(1);
    };
    box.addEventListener('click', function () {
        console.log(3);
    });

```


### 事件对象

给当前元素的某个事件绑定方法（不管是基于dom0还是dom2）， 都是为了触发元素的相关行为时候，能做点事情（也就是把绑定的方法执行,不仅把方法执行了，而且浏览器还给方法传递了一个实参信息值 ===> 这个值就是事件对象
）；

事件对象记录了很多属性名和属性值，这些信息中包含了当前操作的基础信息，例如: 鼠标点击位置的x/y轴坐标，鼠标点击的是谁（事件源）等信息
> 事件对象是用来存储当前本次操作的相关信息的，和操作有关，和元素无必然关联
> 当我们基于鼠标或者键盘等操作的时候，浏览器会把本次操作的信息存储起来（标准浏览器存储到默认的内存中（自己找不到）） ，存储的值是一个对象（堆内存）；操作肯定会触发元素的某个行为，也就会把绑定的方法执行，此时标准浏览器会把之前存储的对象（准确来说是堆内存地址）当做实参传递给每一个执行的方法，所以操作一次，即使在多方法中都有EV,但是存储的值都是一个（本次操作信息的对象而已）

```
box.onclick = function (ev) {
    //=>定义一个形参EV用来接收方法执行的时候，浏览器传递的信息值（事件对象：MouseEvent鼠标事件对象、KeyboardEvent键盘事件对象、Event普通事件对象...）
    //=>事件对象中记录了很多属性名和属性值，这些信息中包含了当前操作的基础信息，例如：鼠标点击位置的X/Y轴坐标，鼠标点击的是谁（事件源）等信息

    //[MouseEvent]鼠标操作
    ev.target：事件源（操作的是哪个元素）
    ev.type：当前事件类型
    ev.path: 记录的是事件冒泡传播的路径
    ev.clientX / ev.clientY ：当前鼠标触发点距离当前窗口左上角的X/Y轴坐标
    ev.pageX / ev.pageY：当前鼠标触发点距离BODY(第一屏幕)左上角的X/Y轴坐标
    ev.preventDefault()：阻止默认行为
    ev.stopPropagation()：阻止事件的冒泡传播
    

    //[KeyboardEvent]键盘操作
    ev.code：当前按键'keyE'
    ev.key：当前按键'e'
    ev.which / ev.keyCode（低版本ie)：当前按键的键盘码 69
    let code = ev.which || ev.keyCode;

    //=>常用的键盘码
    /*
     * 左-上-右-下：37-38-39-40
     * Backspace：8
     * Enter：13
     * Space：32
     * Delete：46
     
     * Shift：16
     * Alt：18
     * Ctrl：17
     * ESC：27
     
     * F1~F12：112 ~ 123
     * 48~57：数字键
     * 65~90：小写字母
     */
};


```

### 事件的默认行为

事件本身都是天生的就有的，某些事件触发，即使你没有绑定方法，也会存在一些效果，这些默认的效果就是事件的默认行为

1.a标签的点击操作就存在默认行为： 
> 1. 页面跳转   2. 锚点定位（hash定位【哈希定位】）


2. input 标签
> 1. 输入内容可以呈现到文本框  2. 输入内容的时候会把之前输入的一些信息呈现出来（并不是所有浏览器和所有情况下都有）

3. submit 按钮也存在默认行为：
> 点击按钮页面会刷新。在form中设置action，点击submit，会默认按照action指定的地址进行页面跳转，并且把表单中的信息传递过去（非前后 端分离项目中，有服务器进行页面渲染，由其它语言实现数据交互，一般都是这样处理）

## 如何阻止默认行为

1 . 阻止A标签

```
//1.阻止A标签的默认行为：很多时候我们使用A标签仅仅是想当做一个普通的按钮，点击实现一个功能，不想页面跳转，也不想锚点定位
/
 在结构中阻止
   <a href="javascript:;">珠峰培训最新全栈视频，等你来拿~~</a>
   javascript:void 0/undefined/null...;

```

在JS中也可以阻止:preventDefault
> 给其click事件绑定方法，当我们点击A标签的时候，先触发click事件，其次才会执行自己的默认行为（我们在click中返回false，

```
link.onclick = function (ev) {
    ev.preventDefault();
};


```

超过6个字符不许输入：

```
tempInp.onkeydown = function (ev) {
    let val = this.value.trim(),
        len = val.length;
    if (len >= 6) {
        this.value = val.substr(0, 6);

        //=>阻止默认行为去除特殊按键（DELETE\BACK-SPACE\方向键...）
        let code = ev.which;
        if (!/^(46|8|37|38|39|40)$/.test(code)) {
            ev.preventDefault()
        }
    }
};

```

### 事件传播机制

冒泡传播： 触发当前元素的某一个事件行为（比如： 点击事件），不仅当前元素事件行为触发，而且其祖先元素的相关事件行为也会依次被触发，这种机制就是事件的冒泡传播机制

#### 事件传播阶段

1. 捕获阶段: 点击inner的时候，首先会从最外层开始向内查找（找到操作的事件源），查找的目的时，构建 出冒泡传播阶段需要传播的路线（查找就是按照html层级结构找的）（没有捕获的元素，事件就不会再冒泡阶段触发）
2. 目标阶段: 把事件源的相关操作行为触发（如果绑定了方法，把方法执行）
3. 冒泡阶段: 把当前事件源的祖先元素按照捕获阶段规划的路线，自内而外，把当前事件源的祖先元素的相关事件行为依次触发（如果某一个祖先元素事件行为绑定方法，则把方法执行，没绑定方法，行为触发了，什么都不做，继续向上传播即可）

```
dom0事件绑定，给元素的事件行为绑定方法，这些方法都是在当前元素事件行为的冒泡阶段（或目标阶段）执行的

xxx.addEventListener('xxx', function(){}, false) 第三个参数false也是控制绑定的方法在事件
传播的冒泡阶段（或者目标阶段）执行，只有第三个参数为TRUE才代表让当前方法在事件传播的捕获阶段触发
执行（这种捕获阶段执行没啥实际意义，项目中不用）；

```

不同浏览器对于最外层祖先元素的定义是不一样的

```
谷歌： window => document => html => body...
IE高： window => html => body...

```

### 事件委托（事件代理）

利用事件的冒泡传播机制 ，如果一个容器的后代元素当中，很多元素的点击行为（其他事件行为也是）都要做一些处理，此时我们不需要再像以前一样，一个个获取一个个绑定，我们只需要给容器的click绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播机制，把容器的click行为触发，把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而做不同的事情即可

1.当前元素的某一个事件行为被触发，那么其祖先元素的相关事件行为都会被触发（大部分事件行为是这样的），如果该元素的这个事件行为绑定了方法，方法也会被触发执行，如果没有绑定方法，触发了，只是没有任何做任何事情，事件的这种传播机制叫做冒泡传播

2. 一个容器中，很多后代元素的点击行为都要处理一些事情，之前的思路是把需要操作的元素一一获取，然后再一一做事件绑定，在不同的方法中完成不同的需求，现在不用了，基于事件的冒泡传播，我们可以只给容器的click绑定一个方法，这样不管以后点击的是容器中的哪一个后代元素，都会通过事件的冒泡传播机制，把容器的click行为触发，把绑定的方法执行，我们在方法执行的时候，根据时间对象中的事件源来做不同的业务处理即可，这种机制即是事件委托机制

什么时候用事件委托?

1.容器中后多后代元素的某个行为要进行操作，委托给容器处理是不错的选择
2.元素是动态绑定的
3. 需求是除了某某某，剩下的操作都是干同样的事情（此时把点击行为的操作委托给BODY，事件源是某某做什么，不是统一做什么）

事件委托这种处理方式比一个个事件绑定(内存消耗大)性能上提高50%左右；

## 异步

### 定时器

setTimeout(\[function],\[interval])
setInterval(\[function],\[interval])

清除定时器

clearTimeout/clearInterval：这两个方法中的任何一个都可以清除用任何方法创建的定时器（没区别）；clearInterval() 方法可取消由 setInterval() 函数设定的定时执行操作。

原理： 1.设置定时器会有一个返回值，这个值是一个数字，属于定时器的编号，代表当前是第几个定时器（不管基于setTimeout，还是setInterval创建的定时器，这个编号会累加）


## ts

1. 作用： 

避免粗心导致的bug,提前提示；
增强编辑器的提示功能；

2. 编译： ts 不能直接在浏览器，或node中运行，一般先要将他转译成js，再执行。这时候就要用到tsc转译器

`npm i  tsc -g`  , 然后tsc xx.js 就可以完成转译了； 当然这个流程也可以用webpack 来自动管理；

3. 校验： ts最好的编辑器是vscode, 默认情况下vscode已经可以对代码进行自动提示和语法报错，如果你需要额外的配置，可以在项目根目录下建一个tsconfig.json文件；

```
{
  "compilerOptions": {
    "removeComments": true, // 删除源文件中的注释
    "target": "ES6", // 指定想要编译目标的js版本
    "noImplicitAny": true, // 禁止动态类型，所有没有标注类型的代码都会提示报错
    "strictNullChecks": true, // 禁止给任意类型赋值null 或者 undefined (默认是可以的)， 除非明确指出可以为null 或者 undefined 
  }
}
```

4. 第三方库类型：

有可能第三方库本身并不是用ts编写的，但我们又想使用ts提供更加完善的类型支持，可以安装由社区维护的类型定义包，
所有的包名都有一个@types前缀， `npm i @types/包名 -D`

### ts数据类型

鸭子类型是 TypeScript 类型的最大特性：仅关注对象上的属性和方法，而不关注继承关系

A满足了（有）B上面的所有属性和方法，那么A就是B的子类型；

```
 type A =  {
    name: string;
  }

  type B = {
    name: string;
    age: number;
  }
  // B满足A上面的所有属性， B是A的子类型

  let a:A = {name: '张三'}
  let b: B = {name: '李斯', age: 18}
  // a = b; // 子类型可以赋值给父类
  b = a; // 父类型不能赋值给子类：类型 "A" 中缺少属性 "age"，但类型 "B" 中需要该属性。 


```


#### 类型声明

在声明变量的时候可以指定类型：

通过类型声明可以指定ts中变量（参数，形参）的类型。

指定类型后， 当为变量赋值时， ts编译器会自动检查值是否符合类型声明， 符合则赋值，否则报错

简而言之，类型声明给变量设置了类型， 使得变量只能存储某种类型的值

> 声明变量如果不指定类型，但是同时赋值了，就会根据值自动推测类型
> 声明变量如果不指定类型，也不同时赋值，默认就是any类型

相关知识：

变量声明不开辟内存，只是告诉编译器，要声明的部分存在，要预留部分的空间。
变量定义开辟内存。


```
let 变量: 类型;

let 变量: 类型 = 值;

function(参数:类型, 参数:类型): 类型 {

}


```

#### ts基本类型


ts 是 js的超集；

js 基本数据类型： number, string, boolean， null, undefined， Symbol

ts的基本数据类型： 
number, string, boolean，any, 
unknown，viod，never, 字面量（值本身，一般和 | 配合是有）
object, array, tuple, enum
> 可以把类型理解成集合

null和undefined： null和undefined 是所有类型的子类型, 也就是说默认可以把null和undefined给任意类型赋值(不过void,和never不行)

viod: 空值，常用来表示函数没有返回值的情况, 申明为 void 类型的变量，只能将 undefined 赋值给viod
never: 永远不会有值的一种类型，连空值都不返回
  - 在处理错误和异常情况时，我们常常会使用 never 类型。比如当一个函数遇到无法恢复的错误时，我们可以使用 never 类型来表示函数会抛出异常。
  - 当一个函数进入无限循环，或者是一个递归函数永远不会终止时，可以将其返回类型标注为 never。

unknown：
- any类型，可以用任意类型赋值，也可以给任意类型赋值， 相当于把别的类型也弄的不准确了，这是any不好的地方；
- unknown类型，只能赋值给unknown 类型或者any类型， 所以unknown 不会影响到别的类型的值的 "类型准确性", 也就是说unknown是类型安全的any;
- 如果想将unknown赋值给别的类型，要先做类型检查（比如typeof）,或者类型断言（as， 可以用来告诉解析器，变量的实际类型）

```
let a:any = 3;
a = '55';

let c:unknown = 4;

let b:number = 1;
b = a;  // 这样是可以的，any类型可以给任意类型赋值；相当于把别的类型也弄的不准确了，这是any不好的地方；

b = c;  // 这样会报错： 不能将类型“unknown”分配给类型“number”。

c = a; // 只能unknown类型只能给any类型，和unknown 赋值；

不过当使用类型推断可以就可以把unknown类型赋值给其他类型了，因为这是类型已经知道了：

let n: unknown = 4;
let v:number;
if(typeof n === 'number'){
  v = n;
}



```




其他类型：

数组： 
  - 元素类型为number的数组: number[]或者Array<number>,  二维数组 number[][]

```
语法：

类型[]

Array<类型>


```



元组：元素个数和类型确定的数组

```
语法：

[类型, 类型, 类型...]

```

枚举类型: enum 关键字定义
- 可以给一组数值赋予名字，这样对开发者比较友好， TypeScript会为它们每个值分配编号，默认从0开始，在使用时，就可以使用名字而不需要记数字和名称的对应关系了
- 如果想要从其他值开始递增，可以将第一个值的索引值进行指定


```
语法：

enum Color {
  Red = 2,
  Blue,
  Yellow
}


```


联合类型： 中间用竖线分割的多种类型， 或者值  |， 表示或
交叉类型：  中间用&分割的多种类型， 或者值  &， 表示合并
对象类型: 用interface 接口 或者 type 别名定义

```
定义一个变量为object类型，其实没啥意思，我们更想限制的是对象的属性

语法： {属性名: 属性值, 属性名: 属性值}

let b:{
  name: string,
  age?: number,
  [prop:string]:any
}

b = {
  name: 'xx',
  gender: '男'
}



```


函数： 定义函数时定义，或者 单独用type 别名定义
> 同样，只定义一个变量是函数类型是没什么意思的，我们希望定义参数类型和返回值类型

```
语法： (形参:类型, 形参:类型, ...) => 返回值类型

注意： 上面的 => 不是es6 中的箭头函数的=> ,这里是专门用来定义函数类型的


let a: (b:number, c:number)=>number;
a = (b, c) =>{return b+c}



```


定义类型的关键字：两种情况, 1. 定义变量或者函数时添加类型; 2. 单独定义类型

一：类似js, 在 声明或定义 变量时指定类型 (注意，这里是声明的是变量，不是类型，只不过是为变量指定了类型)

语法： 关键字 变量名: 类型


const,
let, 
function

```
let a:number;
let f:number[];
let b:{
  name: string,
  age?: number,
  [prop:string]:any
};
let g: Array<number>;
function c(a:number, b: string):void{};
let d: (b:number, c:number)=>number;



const b:number = 3;




```

二： 单独定义类型
type, 
interface, 定义变量时首字母大写

```
  语法：

  type 别名=类型;

  interface 接口名 {
    属性名： 类型
  }




```


? 表示可选；

#### 枚举类型

```
enum C {
  BLACK,
  BLUE,
  PINK,
}

```

// 如果枚举属性没有赋值，默认就会从0开始赋值，0,1,2...,  如果给第一个赋值为6，就就会在此基础上累加， 也可以给每个属性赋值默认值

#### 联合类型 |  和 交叉类型 &

联合类型 |： 或的关系


交叉类型 &: 取并集，合并的意思，有几个特性
- 父类型收敛，如果父类型 & 子类型， 那么结果是 子类型；（any 和 never例外，可以先不管；）
- 如果交叉对象包含相同的属性，但是属性不一致，那么这个相同的属性会变成never类型


```
对象类型 交叉结果是他们的并集； 如果交叉对象包含相同的属性，但是属性不一致，那么这个相同的属性会变成never类型；

interface IA {
  name: string;
  age: number;
}

interface IB {
  name: string;
  gender: string;
}

let person: IA & IB = {
  name: 'xx',
  age: 1,
  gender: '女'
}

```

#### type

type 给类型起个别名，适用于复杂类型； 

type 通过&（交叉类型），或者 | （联合类型） 符扩展

& 后可以是 type别名类型，interface类型，或者抽象类；

#### interface 接口

interface, 定义变量时首字母大写;  

interface 通过 extends（继承） 扩展， 通过继承，为interface 增加属性



```
interface P {
  readonly name: string;  // readonly 表示只读
  age?: number, // ?表示可选
  [prop:string]: any; // [prop] 表示其他任意属性, 这里prop是变量名，类似于形参变量，可以任意写：xx, key...
}

const p: P = {
  name: 'xx',
  id: 1,
}


```

接口中所有的属性都不能有实际的值， 接口只定义对象结构而不考虑实际值，在接口中所有方法都是抽象方法（需要别人去实现）


interface 使用：

- 1. 定义对象和类
  - 定义对象和类，接口中不仅仅可以有属性，也可以有方法
  - 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。

```
// 定义对象和类
// 定义接口中不仅仅可以有属性，也可以有方法
interface A {
  name: string;
  say(a: string):void;
  a():void;
}

// 只读： readonly
class B implements A{
  name: string;
  constructor(){
    this.name = 'xx';
  }

  say(a: string): void {
    alert('hello')
  }

  a(){}
}

```

- 2. 定义函数： 我们需要给接口定义一个调用签名，它就像是一个只有参数列表和返回值类型的函数定义（有点像一个匿名函数的定义，所以interface里，有指定匿名函数类型，就可以认为是函数类型interface）

```

interface S {
  (a: number, b:number): void;
}

let a:S = () => {}

```

建议用type 来定义函数


#### type 和 interface

区别：
- 1. 类型别名type可以为基本类型，联合类型，交叉类型，或者元组类型定义别名， 而interface 接口不行
- 2. 同名接口会自动合并，而类型别名不会


相同点: 
- 1. 都可以描述对象和函数
- 2. 都可以扩展， type 通过& 符扩展， interface 通过 extends 扩展; 


```

// type 给类型起个别名，适用于复杂类型； 对于非对象类型尤其有用；

type MyNumber = number;
type StringOrNumber = string | number;
type Point = [number, number];
type Callback = (data: string) => void;
type P = {
  x: number;
  y: number;
}


// ts 1.6, 类型别名开始支持泛型

type Lazy<T> = T | (()=>T)

// 泛型定义在： 紧跟变量定义后

// type 和 interface 
// 相同点: 
// 1. 都可以描述对象和函数
// 2. 都可以扩展， type 通过& 符扩展， interface 通过 extends 扩展; 


type Animal = {
  name: string;
}
type Bear = Animal & {
  honey: boolean;
}

interface Animal1 {
  name: string;
}

interface Bear1 extends Animal1 {
  honey: boolean;
}

// 并且type 定义的类型 可以 & 连接interface定义的来扩展. interface 定义的类型也可以  extends 连接type定义的来扩展；

interface Bear2 extends Animal {
  honey: boolean;
}

type Bear3 = Animal1 & {
  honey: boolean;
}


// 区别：
// 1. 类型别名type可以为基本类型，联合类型，或者元组类型定义别名， 而interface 接口不行
// 2. 同名接口会自动合并，而类型别名不会

interface user {
  name: string;
}
interface user {
  id: number;
}

let user: user = {
  id: 666,
  name: 'xxx'
}

// type 和interface 的使用场景
// type: 定义基本类型，元组类型，函数类型，联合类型，映射类型时，使用type
// interface: 需要利用接口的自动合并特性的时候；定义对象类型且无需使用type的时候；

type 给类型起个别名

```

#### 抽象类和interface

抽象类和interface的区别：

interface里只是定义规范，抽象类里不仅可以定义规范（抽象属性和方法），还可以实现业务逻辑（实现）；

所以：

类可以实现接口的规范： implements, 实现接口的规范，类就会被接口约束了

### extends 和 implements , 以及 & 的理解

extends： 继承，继承规范，拓展规范，规范包括: interface, type, 以及抽象类


- 1. interface 继承 上述规范（interface, type, 以及抽象类）
- 2. 泛型 继承 上述规范（interface, type, 以及抽象类）
- 3. 类 继承 父类（抽象类）的规范

implements： 实现

类 实现（implements） interface或type规范


&： type 扩展 (用交叉类型符，扩展)

type 别名用 上述规范 （interface, type, 以及抽象类）来扩展自己的规范


综上， 除了类 需要实现（implements）  interface或type规范， 需要继承（extends）， 抽象类的规范；

其他的，泛型，interface，type *都可以用 interface, type, 以及抽象类* 三种规范来扩展自己，只不过，泛型和interface用的是extends， type 用的是 &;



### 类

定义类时，可以使类去实现（关键字：implements）一个接口，实现接口就是使类满足接口的要求

修饰符：

public : 公开的，默认类里的属性和方法是public公开的
protected: 受保护的，只能在 类或者子类 里面调用，实例不能调用
private: 私有的， 只能在类里面调用， 子类和实例都不能调用

readonly: 只读属性，只能读不能改，不过*在构造函数中是可以改的*
static: 静态熟悉，类本身的属性，只能用类本身来调用

get: 在读取类属性时，加上逻辑拦截
set： 在修改类属性时，加上逻辑拦截


抽象类：类名前用 abstract 标识，继承类抽象类的子类 要实现这些规范(要实现所有抽象方法和抽象属性)； *抽象类不能用于创建实例*；

- 抽象类里可以有抽象方法和抽象属性（当然也可以没有）， 都要在名称前用 abstract 标识
  - 抽象方法： 没有具体实现逻辑，只是定义规范（方法名，参数类型，返回值类型）
  - 抽象属性： 只是定义规范：属性名和类型
- 还可以有普通方法和属性： 和正常类里的方法、属性一样

```
abstract class B {
  abstract name: string;
  abstract move():void;
}

interface E {
  age: number;
}

class F extends B implements E {
  age=18;
  name='xx'
  move(): void {
    
  }
}

```

#### 构造器签名

用 构造器签名 限定类类型, 也就是限定传入的类的构造器，要和限定的一致；

new 是关键字


```
 // 使用字面量构造器签名
  const my: new (n:string, a:number) => Person = Student;
  // 接口方式构造器签名
  const my1: {new (n:string, a:number): Person} = Student;
  // 用接口定义构造器签名
  interface My3 {
    new ():string;
  }

```


```

需要根据传入的类去实例化该类, 该如何写？

// 不能给clazz 直接指定Person类型(clazz: Person)，指的是clazz是Person类型的实例(clazz属于Person类型)，所以new去实例化的时候，直接报错
// 解释： clazz是指定了构造器签名的类，返回Person类型（Person的实力）
function createInst(clazz: new (n:string, age:number) => Person): Person{
  return new clazz("YXX", 18); 
}

加入泛型：

function createInst1<T>(clazz: new (n:string, age:number) => T): T{
  return new clazz("YXX", 18); 
}

// 使用
createInst1(Student)
createInst1(Person)

```


# 以下为相对高质量区（可以反复看，快速复习）


### Promise

它是ES6中新增加的类（new Peomise）， 目的是为了管理JS中的异步编程的

Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败），只有异步操作的结果，可以决定当前是哪一种状态（成功或者失败），任何其他操作都无法改变这个状态

基础理解：

resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去，执行resolve就表示异步成功，触发对应函数

reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。


Promise.resolve: 

```
Promise.resolve(value):


Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))

```

理解与运用promise：

- 0. Promise 新建后就会立即执行。then 里的内容才是异步的。

- 1. resolve(value)
  - 1. *如果value这个值是一个 promise，那么将返回这个 promise*
    - *用promise作为resolve的参数,会导致自己的promise状态失效，而采用参数promise的状态*
  - 2. 其他值，则promise 将以此值完成;

- 2. reject(err)
  - 1. Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数

- 3. 调用resolve或reject并不会终结 Promise 的参数函数的执行，即resove, reject后，后面有代码还会继续执行

- 4. then
  - then方法返回的是一个新的Promise实例, 所以可以继续.then
  - *then 的成功回调返回了（return）一个promise, 这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。*所以如果想异步串行，得return promise
    - *如果promise或者其他异步函数在then的成功回调内部，则会正常执行，后续的then不会等待这个异步执行*
  - then 的成功回调返回的不是promise,则会将该值继续向后传递

- 5. catch
  - 1. 捕获rejected的原因, 以及运行中抛出的错误
  - 2. catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法
  - 3. Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。
    - 一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。
  - 4. *已经被catch捕获过的错误，继续向后return传递，会传到后续的then里*

- 6. finally
  - 用于指定不管 Promise 对象最后状态如何，都会执行的操作
  - 返回的还是一个 Promise 对象,因此后面还可以接着调用then()方法
  - 默认向后传递的是它前面的promise的结果



### async  await


#### Generator


简单理解:

- Generator 函数执行，会返回一个遍历器对象（可以调用next）
- Generator 函数是一个状态机，每次yield 后 的表达式都是一个状态
- 每次next都是给当前yield传返回值，并指向下一个yield状态； 一个是yield状态（yield 后），一个是yield返回值（yield前）要区分清；


应用场景：

- 1. 异步操作的同步化表达（让异步操作更优雅一点）
- 2. 控制流管理（一个任务的多个异步步骤的管理）
- 3. 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。

```
function* iterEntries(obj) {
  let keys = Object.keys(obj);
  for (let i=0; i < keys.length; i++) {
    let key = keys[i];
    yield [key, obj[key]];
  }
}
let myObj = { foo: 3, bar: 7 };
for (let [key, value] of iterEntries(myObj)) {
  console.log(key, value);
}
// foo 3
// bar 7


```

原理：（yeild暂停执行的原理）

由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。

遍历器对象的next方法的运行逻辑如下。

- 1. 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象(状态)的value属性值。
- 2. 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。
- 3. 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。
- 4. 如果该函数没有return语句，则返回的对象的value属性值为undefined。



Generator 函数是 ES6 提供的一种异步编程解决方案。

Generator 函数有多种理解角度。 

语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。

执行 Generator 函数会返回一个遍历器对象， 也就是说，**Generator 函数除了状态机，还是一个遍历器对象生成函数**。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield（产出）表达式，定义不同的内部状态。

调用 Generator 函数后，该函数并不执行，而是返回一个**指向内部状态的指针对象（遍历器对象）**；

下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。


yield表达式本身没有返回值，或者说总是返回undefined(也可以理解为next没传参，上一个yield返回就是undefined)；next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
> 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。

这里要区分，**yield的返回值，和 yield后面的表达式的值是两个东西，没有任何关系**， 调用next得到的是yield 后面表达式的值，也是Generator里的状态，但是并不是yield的返回值， 当前yield 的返回值，由下一次执行next时，next的参数决定(也就是说，第一个yeild的值，有第二次next的参数决定)；
> 不过在做封装的时候，比如co，一般将上一个yield 的状态值，作为下一个next的参数， 这样就和我们的直觉一致了， 看起来yield返回的就是对应的状态值了

```
function* foo(x) {
  var y = 2 * (yield (x + 1));  // 注意什么事yield的返回值，这场yield 的返回值就next传入的12， 2*12 = 24
  var z = yield (y / 3);
  return (x + y + z);
}
var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}
var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }

```

#### Iterator 遍历器

- 1. JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set,需要一种统一的接口机制，来处理所有不同的数据结构。
- 2. 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）
- 3. Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
- 4. ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性


Iterator 的遍历过程是这样的。

（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。

（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。

（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。

每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。


### for ... of

for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及*字符串*。(一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。)

> 注意默认不能直接遍历对象

所以，遍历新的数组结构Set，Map还是for...of方便。


```
const arr = ['red', 'green', 'blue'];
for(let v of arr) {
  console.log(v); // red green blue
}

```



#### async  await


async 函数是什么？一句话，它就是 Generator 函数的语法糖。

使用：

- await 的内容是直接执行的，如果是promise，还会等待这个promise完成
- await 的内容执行完了就继续走await后的内容，await 后的代码就相当于在then里执行的
- await后跟的函数b，b内部如果有需要外界等待的，b内部也是需要await 的，否则外界就不会等，b内部走完同步代码就出来了


简单理解：

- 1. async函数的返回值是 Promise 对象(async函数内部return会作为这个promise的结果),你可以用then方法指定下一步的操作;
- 2. await后面可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象），可以理解为如果不是 Promise 对象，就直接返回对应的值；



async + await 约等于 Generator + co(Generator自动执行机制) + Promise

一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。

async函数对 Generator 函数的改进，体现在以下四点。

（1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。只要调用就会自动执行，输出最后结果。不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。
（2）更好的语义。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
（3）更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
（4）返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。

进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。


不过： *await 后下一行内容，仍然相当是在then函数里执行的，依旧是微任务*

原理：

```
async 函数的实现原理，就是返回一个自动执行器函数，并给它传入生成器（generator）函数， 最终自动执行器函数返回一个promise。


async function fn(args) {
  // ...
}
// 等同于
function fn(args) {
  return spawn(function* () {
    // ...
  });
}

所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。

spawn函数的实现

function spawn(genF){
  return new Promise((resolve, reject)=>{
    const gen = genF();
    const step = (nextF) => {
      let next;
      try{
        next = nextF();
      }catch(e){
        return reject(e);
      }
      if(next.done){
        return resolve(next.value)
      }
      Promise.resolve(next.value).then((v)=>{
        step(()=>gen.next(v))
      }, (e)=>{
        step(()=>gen.throw(e))
      })
    }
    step(()=>gen.next(undefined))
  })
}


```

## Proxy 和 Reflect

Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写

`var proxy = new Proxy(target, handler);`

Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。

```
 new Proxy(data, {
      // 拦截属性值读取
      get(target, prop){
        return Reflect.get(target, prop);
      },
      // 拦截属性值修改或者添加
      set(target, prop, value){
        return Reflect.set(target, prop, value);
      },
      // 拦截属性值删除
      deleteProperty(target, prop){
        return Reflect.deleteProperty(target, prop)
      }
    })


```

对于对象的操作，有两种方式，一种是 . ,另一种就是Reflect，它提供拦截 对象 操作的方法， 这些方法与Proxy的handler方法一一对应。

Reflect的目的是：
1. 把Object对象上的一些方法放到Reflect上，现阶段一些方法同时在Object和Reflect部署，未来的一新方法只部署在Reflect对象上
2. 修改某些Object方法的返回结果，让其变得更加合理， 比如Object.defineProperty(obj, prop, descriptor)，而Reflect.defineProperty(obj, prop, descriptor)则会返回flase, 这样就可以减少很多try catch，尤其是在写库的时候很有用
3. 让Object操作都变成函数行为， 比如之前的命令式的操作，name in obj, delete obj.prop, 变成Reflect.has(obj,name),
   Reflect.deleteProperty(obj,name), 这样就对象操作就更加统一

## 请求

### axios

拦截器中如果有可能出现错误一定要捕获，不然可能让请求程序断在拦截器里，也不一定会有错误抛出。


## 模块化

一个模块（module）就是一个文件,将 JavaScript 程序拆分为可按需导入的单独模块的机制

### common.js

node的模块规范commonjs

1. CommonJS规定， 每一个JS文件都是单独的模块（模块是私有的： 里面涉及的值和变量以及函数等都是私有的，和其他JS文件中的内容是不冲突的。
2. CommonJS中可以允许模块中的方法互相调用

导出：

CommonJS给每个模块都设置了内置的变量/属性/方法

module ： 代表当前这个模块对象
module.exports: 模块的这个“属性”是用来导出属性方法的
exports: 是内置的一个“变量”，虽然和module.exports不是一个东西，但是对应的值是同一个（module.exports = exports 值都是对象）

导入：

require: CommonJS提供的内置变量，用来导入模块的（其实导入的就是module.exports暴露出来的东西）

#### CommonJS特点

1. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果，想让缓存再次运行，必须清除缓存。（为了保证性能，减少模块代码重复执行的次数）
2. 模块加载的顺序，按照其在代码中出现的顺序。 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才会执行后面的操作



> 模块中 `this === module.exports`


### es module

ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

导出:

1. export
2. export  default: export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。

导入:

```
// 如果导出的是一个对象，可以使用结构赋值 来获取数据
import {a,b} from './1.js'
import * as zf from './1.js' // 导入所有 使用zf 代表模块所有内容接收
import fn from './2.js'  // 使用default 导出的  在接收时， 不用结构赋值
import {default as randomSquare} from './modules/square.js'; // 导入的时候，给默认导出重命名
import { function1 as newFunctionName,
         function2 as anotherNewFunctionName } from '/modules/module.js'; // 导入的时候，给导出重命名


// 合并模块： 有时你会想要将模块聚合在一起。您可能有多个级别的依赖项，您希望简化事物，将多个子模块组合到一个父模块中

export * from 'x.js'
export { name } from 'x.js'


// 动态加载模块：允许您仅在需要时动态加载模块，而不必预先加载所有模块，将 import() 作为函数调用，将其作为参数传递给模块的路径。它返回一个 promise；

import('/modules/mymodule.js')
  .then((module) => {
    // Do something with the module.
  });


注意导出的一般是一个对象 如果不是直接使用这个对象，而是要使用这个对象中的某个属性，要先用结构赋值，把它解析出来

```

### commonjs和es6模块的差异

1. CommonJS 模块输出的是一个值的拷贝（会对加载结果进行缓存，一旦内部再修改这个值，则不会同步到外部），ES6 模块输出的是值的引用（内部修改可以同步到外部）。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口（编译阶段就确定模块的依赖关系，以及输入和输出的变量）。
3. CommonJs中顶层的this指向这个模块本身，而ESModule中顶层this指向undefined。


## 后端概要

1. 服务器上有一堆项目代码，这堆项目代码中可能有服务器端的程序代码，也可能有客户端的程序代码，而客户端程序代码我们一般都放到static这个文件夹中： static
2. 我们创建的web服务需要处理两类请求：

```
1.  静态资源文件的请求处理： 想要文件
2.  api接口的请求处理： 想要数据


如果有nginx 代理，静态资源请求会走到nginx(监听了对应域名和接口，一般是前端的静态资源，后端api域名一般和前端域名不同，所以是静态资源请求到nginx， api 请求会先走到后端网关)

```





#### 泛型

用尖括号<>的方式来定义泛型， 尖括号里面的变量名用大写字母表示，多个参数可以用逗号分割；

泛型的种类：
- 1. 函数泛型
- 2. type泛型
- 3. interface泛型
- 4. 类泛型


泛型理解，定义时： 泛型的写法就是在标志符（名称）后面添加尖括号（<>），然后在尖括号里写形参，并在 body（函数体， 接口体或类体） 里用这些形参做一些逻辑处理。
- 泛型变量除了函数，都定义在名称（type, interface, 类 的名称）后 
- 对于函数，记成写成()前更合适一点，因为还有箭头函数


```

function get<T,U>(arg:[T,U]):[T,U]{ 
  return arg;
}

type LeetCode<T = {}> = {
  name: T;
};

interface id<T, U> {
  id1: T;
  id2: U;
}

class MyComponent extends React.Component<Props, State> {
   ...
}

```


#### 泛型约束

对泛型添加一些约束条件:用关键字extends, 这里的extends 可以理解为*符合*， 如果是对象，抽象类表示 *至少得包括所约束的属性，可多不可少*， 而不是继承
> 类比函数，我们可以约束参数的类型，那么我们如何约束泛型（类型参数）的类型呢

- 1. 用extends来给泛型添加约束条件

```
interface L {
  length: number;
}

function getL<T extends L>(arg:T):T{
  return arg;
}

```
- 2. 在泛型约束中使用类型参数

```
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };
getProperty(x, 'a');

```

#### 泛型的条件分配

#### 泛型默认参数

还可以给泛型加默认参数：

```
type A<T = string> = Array<T>;

```

#### 泛型： 对类型编程

平时我们都是对值进行编程，泛型是对类型进行编程（这是泛型的基本思想），ts由于需要类型场景的复杂性，需要一种不依赖 JS 行为， 且不会和现有语法体系冲突的语法来对类型编程；(有点类似函数,不过ts自己定义了一套语法)

```
定义： 

type P<T> = {do something}

类比函数： function P(){do something}


调用：

type newP = P<Person>

类比函数： newP = P(Person)

```

从外表看，只不过是function 变成 type， ()变成<> 而已,  然后type定义时多了个等号


#### 常见的泛型

- 1. 集合类

  数组：实际是调用接口 interface Array<T>

  ```
  const a:Array<number> = [1]

  ```


#### 类型断言

我们常用<> 或者 as 来做类型断言：

```
语法：

变量 as 类型;
<类型>变量



let str: string = 'xx';
let len:number = (<string>str).length;
let len1:number = (str as string).length;

```

#### 非空断言

!
```
let usr: string | null;
console.log(usr!.toLocaleLowerCase());

```

#### 类型守卫

判断类型，或者判断是否包含某个属性：
in: 对象是否包含某个属性
typeof
instanceof

typeof 和 instanceof 和js里的用法一样


## ts 进阶

### declare

1. 用declare声明ts全局变量
   > 引用第三包包有时会报ts错误，找不到变量，可以项目根目录下创建xx.d.ts 声明文件；当然也可以装类型包 @types/xx

2. 用declare声明模块
   > 一般ts项目都要声明 *.css ，*.jpg 等模块, 因为ts编译器不识别这些模块，会提示错误

3. 可以用declare module 的语法，来扩展已有模块中定义的类型



### 条件类型

语法： T extends U? X: Y
>  如果T符合(能赋值给)U， 那么返回类型 X， 否则返回类型Y;  整体语法跟js三元表达式类似

可以利用这个写工具类型：

```
type isString<T> = T extends string ? true: false;
type I0 = isString<number>; // false
type I1 = isString<'acc'>; // true

```

#### 分布式条件类型

T extends U ? X : Y，使用类型参数A | B | C 实例化 T 解析为 (A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)




## ts 中特有的

#### typeof

### 索引类型

使用索引类型，编译器就能够检查使用了*动态属性名*的代码, 也就是用来展开对象的key的

简单理解： 把 对象的key 或者 对象key的类型 变成联合类型

TypeScript里，通过 索引类型查询 和 索引访问操作符  来处理 动态属性名 的情况;

- keyof 索引类型查询操作符

keyof T的结果为T上已知的公共属性名的联合。 例如：

```
let person: Person = {
    name: 'Jarid',
    age: 35
};

let personProps: keyof Person; // 'name' | 'age'

```

- T[K]，索引访问操作符

你需要确保类型变量K extends keyof T， 那么o[name] 就是 T[K] 类型

```
function getProperty<T, K extends keyof T>(o: T, name: K): T[K] {
    return o[name]; // o[name] is of type T[K]
}

```

详细解释： 

- 1. keyof操作符接受一个对象类型作为参数，返回该对象公共属性名组成的字面量联合类型
  - 该关键字一般会和extends关键字结合使用，对对象属性的类型做限定，比如K extends keyof any就代表K的类型一定是keyof any所返回的联合类型的子类
  - 注意点： 遇到索引签名时，typeof会直接返回其类型

  正常： 接受一个对象类型作为参数，返回key名的联合类型

  ```

  type Dog = { name: string; age: number;  };
  type D = keyof Dog; //type D = "name" | "age"

  ```

  特殊1： 遇到字符串索引签名时(参数的对象类型的key是动态的)，返回的就是key的类型的联合类型，而不是key名的联合类型

  ```
  interface Ap<T> {
    [key: string]: T;
  }
  let keys: keyof Ap<number>; // string | number
  let key: keyof Ap<string>; // string | number
  let value: Ap<number>['foo']; // number

  ```

  
  特殊2: any 做为参数
  - 可以用keyof any 指代可以作为对象键的属性
  - 目前，JavaScript 仅支持string、number、symbol作为对象的键值。

  ```
    type H = keyof any; // string | number | symbol

  ```
  
  

- 2. in的右侧一般会跟一个联合类型, 使用in操作符可以对该联合类型进行迭代。 其作用类似JS中的for...in或者for...of

```
type Animals = 'pig' | 'cat' | 'dog'

type animals = {
  [K in  Animals]: string;
}

const ani: animals = {
  pig: '小1',
  cat: '小2',
  dog: '小3'
}


```

### 映射类型

TypeScript提供了从旧类型中创建新类型的一种方式 — 映射类型。

在映射类型里，新类型以相同的形式去转换旧类型里每个属性。基于一些已存在的类型，且按照一定的方式转换字段。 这就是keyof和索引访问类型要做的事情。
- 索引类型和映射类型都用到 keyof 和 in 来达成自己的目的

最简单的映射类型和它的组成部分:

```
type key = "name" | 'age';
type op = {[k in key]: boolean}


它的语法与索引签名的语法类型，内部使用了for .. in。 具有三个部分：具有三个部分：

1. 类型变量K，它会依次绑定到每个属性。
2. 字符串字面量联合的Keys，它包含了要迭代的属性名的集合。
3. 属性的结果类型。

```

同态类型转换： 映射只作用于T（对象）的属性而没有其它的（编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。）
给同态类型转换： 不需要输入类型来拷贝属性，非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符

```
// 同态
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
}

// 非同态
type Record<K extends string, T> = {
    [P in K]: T;
}

type ThreeStringProps = Record<'prop1' | 'prop2' | 'prop3', string>

```

#### infer 

infer可以在extends的条件语句中推断待推断的类型,即 推导泛型参数；
- infer 只能在 extends 的后边使用
- infer P 的 P 也只能在条件类型为 True 的一边使用



理解： infer 关键字让我们拥有深入展开泛型的结构，并 Pick 出其中任何位置的类型，并作为临时变量用于最终返回类型的能力。
- 设一个未知数 x（infer xx）占位， 每一个占位都是一个未知数, 实际调用的时候就能求解（用 泛型描述调用时 才传入的类型，并提前将它描述在类型表达式中）
- 也可以这么理解： 关于 infer 关键字，我们可以把它当成简单的模式匹配来看待。如果真实的参数类型和 infer 匹配的一致，那么就返回匹配到的这个类型。
- 同一个类型变量在推断的值（infer占位）， 有多种情况的时候会推断为联合类型


```
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

解释 ： 如果 T 继承了 extends (...args: any[]) => any 类型，则返回类型 R，否则返回 any。其中 R 是什么呢？R 被定义在 extends (...args: any[]) => infer R 中，即 R 是从传入参数类型中推导出来的。



type ReverseArray<T extends unknown[]> = T extends [infer First, ...infer Rest]  
? [...ReverseArray<Rest>, First]  
: T  
type Value = ReverseArray<[1, 2, 3, 4]> // [4,3,2,1]

```


## ts 工具函数

这些工具类型的实现时，我们发现它们都是基于映射类型、条件类型、infer 推断实现的。可以说掌握了这 3 种类型操作的技巧，我们就可以自由地组合更多的工具类型了。

### 工具函数原理

根据使用范围，我们可以将工具类型划分为操作：
接口类型、联合类型、函数类型、字符串类型 这 4 个方向


操作接口类型： Partial， Required， Readonly，Mutable, Pick,Omit

常见工具函数及实现原理：

- 1. Partial

  功能是将类型的属性「变成可选」

  ```
  type Partial<T> = { [P in keyof T]?: T[P] };
  ```
- 2. Required

  功能和Partial 相反，是将类型的属性「变成必填」， 这里的 -指的是去除。 -? 意思就是去除可选，也就是必填啦。

  ```
  type Required<T> = { [P in keyof T]-?: T[P] };

  ```

- 3. Mutable

  功能是将类型的属性「变成可修改」，这里的 -指的是去除。 -readonly 意思就是去除只读，也就是可修改啦。

  ```
  type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
  };

  ```

- 4. Readonly

  功能和Mutable 相反，功能是将类型的属性「变成只读」， 在属性前面增加 readonly 意思会将其变成只读。

  ```
  type Readonly<T> = { readonly [P in keyof T]: T[P] };

  ```
- 5. Pick

从给定的类型中选取出指定的键值，然后组成一个新的类型

```
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
type NewPerson = Pick<Person, 'name' | 'age'>;
// 相当于
interface NewPerson {
  name: string;
  age?: number;
}

```

- 6. Omit

与 Pick 类型相反，Omit 工具类型的功能是返回去除指定的键值之后返回的新类型

```
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
type NewPerson = Omit<Person, 'weight'>;
// 相当于
interface NewPerson {
  name: string;
  age?: number;
}

```

我们知道 Pick 类型的作用是选取给定类型的指定属性，那么这里的 Omit 的作用应该是选取除了指定属性之外的属性，而 Exclude 工具类型的作用就是从入参 T 属性的联合类型中排除入参 K 指定的若干属性。


联合类型：Exclude, Extract, NonNullable，Record

- 1. Exclude

Exclude 的作用就是从联合类型中去除指定的类型

```
type Exclude<T, U> = T extends U ? never : T;
type T = Exclude<'a' | 'b' | 'c', 'a'>; // => 'b' | 'c'

```

- 2. Extract

Extract 类型的作用与 Exclude 正好相反，Extract 主要用来从联合类型中提取指定的类型，类似于操作接口类型中的 Pick 类型。

```
type Extract<T, U> = T extends U ? T : never;
type T = Extract<'a' | 'b' | 'c', 'a'>; // => 'a'

```
也可以理解为：  Extract 类型相当于取出两个联合类型的交集


我们还可以基于 Extract 实现一个获取接口类型交集的工具类型：

```
type Intersect<T, U> = {
  [K in Extract<keyof T, keyof U>]: T[K];
};
interface Person {
  name: string;
  age?: number;
  weight?: number;
}
interface NewPerson {
  name: string;
  age?: number;
}
type T = Intersect<Person, NewPerson>;
// 相当于
type T = {
  name: string;
  age?: number;
};


```

- 3. NonNullable

NonNullable 的作用是从联合类型中去除 null 或者 undefined 的类型

```
type NonNullable<T> = T extends null | undefined ? never : T;
// 等同于使用 Exclude
type NonNullable<T> = Exclude<T, null | undefined>;
type T = NonNullable<string | number | undefined | null>; // => string | number

```

- 4. Record

Record 的作用是生成接口类型，然后我们使用传入的泛型参数分别作为接口类型的属性和值。
- Record 类型接收了两个泛型参数：第一个参数作为接口类型的属性，第二个参数作为接口类型的属性值。

```
type Record<K extends keyof any, T> = {
  [P in K]: T;
};
type MenuKey = 'home' | 'about' | 'more';
interface Menu {
  label: string;
  hidden?: boolean;
}
const menus: Record<MenuKey, Menu> = {
  about: { label: '关于' },
  home: { label: '主页' },
  more: { label: '更多', hidden: true },
};

```

函数类型： ConstructorParameters, Parameters, ReturnType, ThisParameterType, ThisType, OmitThisParameter

- 1. ConstructorParameters 可以用来获取构造函数的构造参数类型，而 ConstructorParameters 类型的实现则需要使用 infer 关键字推断构造参数的类型。

```
type ConstructorParameters<T extends new (...args: any) => any> = T extends new (
  ...args: infer P
) => any
  ? P
  : never;
class Person {
  constructor(name: string, age?: number) {}
}
type T = ConstructorParameters<typeof Person>; // [name: string, age?: number]


```

- 2. Parameters

Parameters 的作用与 ConstructorParameters 类似，Parameters 可以用来获取函数的参数并返回类型

```
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;
type T0 = Parameters<() => void>; // []
type T1 = Parameters<(x: number, y?: string) => void>; // [x: number, y?: string]


```

- 3. ReturnType

 功能是用来得到一个函数的返回值类型。

 ```
  type ReturnType<T extends (...args: any[]) => any> = T extends (
    ...args: any[]
  ) => infer R
    ? R
    : any;


使用：
  
  type Func = (value: number) => string;

  const foo: ReturnType<Func> = "1";

 ```

- 4. ThisParameterType

ThisParameterType 可以用来获取函数的 this 参数类型。

```
type ThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any ? U : unknown;
type T = ThisParameterType<(this: Number, x: number) => void>; // Number

```

在上述示例的第 1 行中，因为函数类型的第一个参数声明的是 this 参数类型，所以我们可以直接使用 infer 关键字进行匹配并获取 this 参数类型。在示例的第 3 行，类型别名 T 得到的类型就是 Number。

- 5. ThisType

ThisType 的作用是可以在对象字面量中指定 this 的类型。ThisType 不返回转换后的类型，而是通过 ThisType 的泛型参数指定 this 的类型

```
type ObjectDescriptor<D, M> = {
  data?: D;
  methods?: M & ThisType<D & M>; // methods 中 this 的类型是 D & M
};


```

ThisType 工具类型只是提供了一个空的泛型接口，仅可以在对象字面量上下文中被 TypeScript 识别，

```
interface ThisType<T> {}

```

- 6. OmitThisParameter

OmitThisParameter 工具类型主要用来去除函数类型中的 this 类型。如果传入的函数类型没有显式声明 this 类型，那么返回的仍是原来的函数类型。

```
type OmitThisParameter<T> = unknown extends ThisParameterType<T>
  ? T
  : T extends (...args: infer A) => infer R
  ? (...args: A) => R
  : T;
type T = OmitThisParameter<(this: Number, x: number) => string>; // (x: number) => string

```

字符串类型:  Uppercase、Lowercase、Capitalize、Uncapitalize 

这 4 种操作字符串字面量工具类型的实现都是使用 JavaScript 运行时的字符串操作函数计算出来的，且不支持语言区域设置。

```
// 转换字符串字面量到大写字母
type Uppercase<S extends string> = intrinsic;
// 转换字符串字面量到小写字母
type Lowercase<S extends string> = intrinsic;
// 转换字符串字面量的第一个字母为大写字母
type Capitalize<S extends string> = intrinsic;
// 转换字符串字面量的第一个字母为小写字母
type Uncapitalize<S extends string> = intrinsic;
type T0 = Uppercase<'Hello'>; // => 'HELLO'
type T1 = Lowercase<T0>; // => 'hello'
type T2 = Capitalize<T1>; // => 'Hello'
type T3 = Uncapitalize<T2>; // => 'hello'


```

以下代码是这 4 种字符串工具类型的实际实现。

```
function applyStringMapping(symbol: Symbol, str: string) {
  switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {
    case IntrinsicTypeKind.Uppercase:
      return str.toUpperCase();
    case IntrinsicTypeKind.Lowercase:
      return str.toLowerCase();
    case IntrinsicTypeKind.Capitalize:
      return str.charAt(0).toUpperCase() + str.slice(1);
    case IntrinsicTypeKind.Uncapitalize:
      return str.charAt(0).toLowerCase() + str.slice(1);
  }
  return str;
}

```

### ts 类型体操

- 1. 常用type 去写类型函数

定义：
  - 0. 一些简单的就用条件类型去写
  - 1. 处理对象的时候，就是对象类型的写法，直接在{}里用in写逻辑, 
  - 2. 处理函数的时候，就是函数类型的写法，判断是否匹配函数类型，在函数类型里使用infer写逻辑，外层用条件类型extends写逻辑；

```
 

type P<T> = {do something}

```




调用： 

```

type newP = P<Person>

```


- 2. 常用语法：in, keyof, extends, infer

  - 1. in 操作符，遍历联合类型，右侧一般跟着联合类型： k in key， *in 本质上是遍历联合类型的每一项*
    - 映射类型： 从旧类型中创建新类型的一种方式， 新类型以相同的形式去转换旧类型里每个属性，
      - `type key = "name" | 'age';    type op = {[k in key]: boolean}`
  - 2. keyof 操作符, *把 对象的key名 或者 对象key的类型（key是动态的时候） 变成联合类型*,右侧一般跟着对象类型： keyof T;
    - 索引访问操作符： K extends keyof T； 那么T[K] 就是 对象的key的值 或者 对象key的类型。
    - 和in配合使用，遍历对象的key, `[P in keyof T]`
  - 3. extends: ts 中 extends 有 继承， 约束， 条件类型三种用法，其中约束和条件类型，中extends含义一样，都是符合的意思
    - 泛型约束： <T extends L>
    - 条件类型：T extends U? X: Y
    - 分布式条件类型： T extends U ? X : Y；使用联合类型A | B | C 实例化 T， 结果是分别判断后的联合类型，解析为 (A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)
    - 这里的extends 可以理解为*符合*， 如果是对象，抽象类表示 *至少得包括所约束的属性，可多不可少*
  - 4. infer, 在泛型中的*设置未知数，实际调用的时候就能求解，返回匹配位置变量的类型*
    - infer 只能在 extends 的后边使用
    - infer P 的 P 也只能在条件类型为 True 的一边使用
    - 同一个类型变量在推断的值（infer占位）， 有多种情况的时候会推断为联合类型
    - 举例： `type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;`  如果传入的T符合...则返回R，否则返回any;





### es11 的一些新特性(2020年)

TC39 的 Github 仓库上可以看到所有目前公开的提案：https://gitcode.net/mirrors/tc39/ecma262?utm_source=csdn_github_accelerator  一个新语法从提交到成为 ECMAScript 正式标准，需要经历从展示到定案五个阶段，如果到了最后一个定案阶段 (Stage 4)，那么就一定会包含在下一个发布的 ECMAScript 标准， 已经到定案阶段 (Stage 4) 的提案，就是目前的 ESNext。

1. ??  空值合并操作符

空值合并操作符（??）是一个逻辑操作符，当左边的操作数为 null 或 undefined 的时候，返回其右侧操作符，否则返回左侧操作符。

2. 还有一些比较常用的

逻辑或操作符：|| ， 会在左侧操作数为假值时返回右侧操作数
可选链操作符：?. ， 操作符的功能类似于.链式操作符，不同之处在于，在引用为 null 或 undefined 时不会报错

3. globalThis： 现在 globalThis 提供了一个标准的方式来获取不同环境下的全局对象自身值。

4. BigInt 是一种内置对象，用来创建比 2^53 - 1（Number 可创建的最大数字） 更大的整数。可以用来表示任意大的整数

```
如何定义一个 BigInt

1. 在一个整数字面量后面加 n，例如 10n
2. 调用函数 BigInt() 并传递一个整数值或字符串值，例如 BigInt(10)

0n === 0 // false
0n == 0  // true

```

5. String.prototype.matchAll():  返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。

> 有点像一个简化的match, 免得写回调函数

```
const regexp = /t(e)(st(d?))/g;
const str = 'test1test2';

const array = [...str.matchAll(regexp)];
console.log(array[0]);  // ['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', groups: undefined]
console.log(array[1]); // ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', groups: undefined]

```

6. Promise.allSettled(): 类方法，返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。

```
Promise.allSettled([
  Promise.resolve(33),
  new Promise((resolve) => setTimeout(() => resolve(66), 0)),
  99,
  Promise.reject(new Error("an error")),
]).then((values) => console.log(values)); 

// [
//   { status: 'fulfilled', value: 33 },
//   { status: 'fulfilled', value: 66 },
//   { status: 'fulfilled', value: 99 },
//   { status: 'rejected', reason: Error: an error }
// ]

```

7. 动态引入 import()

import 可以在需要的时候，再加载某个模块。

```
button.addEventListener('click', event => {
  import('./dialogBox.js')
  .then(dialogBox => {
    dialogBox.open();
  })
  .catch(error => {
    /* Error handling */
  })
});

```

### es12 (es2021)新增了如下新特性:

1. 逻辑运算符和赋值表达式（&&=，||=，??=）

&&=: 逻辑与 赋值运算符 x &&= y 等价于 x && (x=y)：意思是当 x 为真时，x = y。
||=: 逻辑或 赋值运算符 x ||= y 等价于 x || (x = y)：意思是仅在 x 为 false 的时候，x = y。
??=: 逻辑空 赋值运算符 x ??= y 等价于 x ?? (x = y)：意思是仅在 x 为 null 或 undefined 的时候，x = y。


2. String.prototype.replaceAll(): 返回一个新字符串，字符串中所有满足 pattern 的部分都会被 replacement 替换掉。原字符串保持不变

```
使用正则表达式搜索值时，必须是全局的：
'aabbcc'.replaceAll(/b/g, '.');  // "aa..cc"

```

3. 数字分隔符

ES12 允许 JavaScript 的数值使用下划线（_）作为分隔符, 
> _ 不能放在数值的最前面和最后面
> 不能将两个及两个以上的分隔符连在一起
> 小数点的前后不能有分隔符
> 科学记数法里，e 或 E 前后不能有分隔符

```
123_00 === 12300 // true

```

4. Promise.any

方法接受一组 Promise 实例作为参数，包装成一个新的 Promise。只要参数实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态(包括传递了空的可迭代对象），包装实例就会变成 rejected 状态。结果就是成功的那个promise的结果，失败会有失败信息

```
Promise.any([promise1(), promise2(), promise3()])
  .then((first) => {
    // 只要有一个请求成功 就会返回第一个请求成功的
    console.log(first); // 会返回成功的promise的结果
  })
  .catch((error) => {
    // 所有三个全部请求失败 才会来到这里
    console.log("error", error);
  });


```

# 其他一些之前忽略的

## new Function

new Function() 可以实例化一个新的函数对象并返回

```
new Function ([arg1[, arg2[, ...argn]],] functionBody)

arg1, arg2, ..., argn 为函数的参数列表，functionBody 为函数体的字符串表示

```

new Function 和 eval 的区别:

- 1. 执行方式不同
  - new Function() 构造函数创建的函数对象只会在其被调用时才会执行
  - eval() 函数则立即执行
- 2. 作用域不同： 
  - *由 Function 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量*
  - eval() 函数则可以访问其自身函数作用域和父作用域的变量和函数，因此具有更高的灵活性和不可预知性。
- 3. 安全性不同： 
  - new Function()更安全，由于 new Function() 构造函数定义的函数对象是在严格的函数作用域下运行的，因此其代码不会改变或访问父作用域中的变量。
  - eval() 函数则无法保证代码的安全性，因为它可以访问并改变父作用域中的变量。
- 4. 性能： 
  - new Function() 函数具有更好的性能。这是因为 new Function() 函数在编译时会创建一个新的函数对象
  - eval() 函数一样将代码注入到当前作用域中

使用场景：很适合在需要动态生成 JavaScript 代码的场景中使用



## 一些小js tips

打断循环的方法： return 结束函数，同时也打断了循环；  break 可以打断while 和 for循环;


获取函数字符串的方法： fn.toString() 返回函数字符串带注释，空格， 这个toString 方法在Function.prototype 上

快速用索引生成数组： Array.from({ length: 5 }, (v, i) => i);



### 复习记录

2023-8.13 完成ts体操思路整理，待练习 todo

2024-5.27 done1  (3小时)

【核心内容减少，高质量区 之前的两个月内只需看一次】






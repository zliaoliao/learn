[toc]

# 目录

1. 基础背诵
2. 左神笔记
3. hot100浓缩

每天背诵内容：30分钟， 需要反复背诵，过一周不背就忘得差不多了，所以真的是十鸟在林，不如一鸟在手，不然刷再多题都没用【直到找到工作前，每四天必看一次，每两周必刷一次hot100】
1. 易错背诵
2. 需要背诵的算法基础

每周背诵回顾内容：hot 100 常见题型

- 1. 数组：双指针
- 2. 二叉树遍历，前中后遍历，宽度遍历；
- 3. 栈： 括号匹配，字符串解码
- 4. 队列：
  - 滑动窗口
  - bfs 层级遍历：树或者图的层级遍历
- 5. 递归回溯： 
  - 多步决策
  - 分配组合
- 6. 动态规划（初始化时，会有一个 原数据长度+1 的操作，会多初始化一个数据，因为，一般原始数据不会给 0）
- 7. 快排



# 最容易犯得脑残错误【代码有错误时可以检查一下这几条】

- 0. 如果改变语句需要删掉重写（比如 for 变 while），不要偷懒，写的过程也是思考的过程，否则容易出现低级错误

- 常错：
  - 1. 在比较的时候 没有用===， 而用了赋值符 =; 这两者容易弄混，注意检查
  - 2. 对象取变量值，用了., 而不是 []
  - 3. 数组的push返回的数组长度, 而不是新数组
  - 4. 做算法要注意考察，空节点，空数组，空字符串 的边界情况；

- 不那么常见：
  - 链表比较值相等时， 值应该用val值去比较，而不是node节点
  - undefined 转为数字是 NaN, null 转为数字是0；


  - 常见容易忽略的方法：
    - 数组方法：
      - join(); 是用于将数组元素连接成一个字符串的方法。可以通过传递一个分隔符字符串指定连接的方式。*如果未提供分隔符，默认使用逗号（,）*;
      - Array.from(); 类似数组或可迭代对象 转换为数组；可迭代对象包括*字符串*、Set、Map 等
  - 结构赋值：
    -  在 数组中两个元素交换的 解构赋值 中，右边的值同时计算出来，然后对左边进行按顺序赋值
       -  右边的计算是无序的：无论右边的结构中有多少项，JavaScript 会同时计算出所有的右边表达式的结果。
       -  左边的赋值是有序的：左边的变量会按顺序逐个接收右边计算出来的值。
       -  记忆（目标优先）： 交换 nums[i] 和 nums[nums[i] - 1]，应该 目标位置先，当前元素后。也就是左边顺序是：nums先[nums[i] - 1] 再 nums[i]; 
  
# 思路性的

  - 字符串解码，括号类题：
    - 遇到括号要么压栈记录，要么结算成字符串
      - 无法结算的都压栈记录就好
      - 结算时，一般结算括号里的，以及把括号展开后，和他同一层的，前面部分；


# 易错背诵(15分钟)

  错误2次，3次是要重点看的；

- 滑动窗口，最长模版解法： 右扩到不满足条件，左缩
  - 0. 循环条件为，右指针没有超过边界；
  - 1. 满足条件，移动右指针扩大窗口，加入right对应元素，更新结果 
  - 2. 不满足条件，移动左左指针,缩小窗口,移除left对应元素

- 如果没有顺序要求，只要覆盖所有字符即可，用滑动窗口（最短覆盖子串）。
- 如果必须满足顺序（可能不连续），即明确了子序列，则用双指针或DP，简单滑动窗口无法无法保证顺序（最短覆盖子序列）


- 二叉树的遍历：先，中，后序用栈
  - 中序：一路向左，依次压栈，直到最左节点，弹出节点时访问，然后处理右子树。
  - 先序： 每次弹出节点，先访问当前节点，再把右子节点和左子节点依次压栈
  - 后序： 类似先序，调整入栈顺序，和结果收集方向
  

- 栈：需要用栈结构的场景，后进先出（只能从栈顶进出）
  - 使用栈时，通常不需要移除尾部元素，栈的作用是按需记录并在合适的时候回溯（取出）。
    - 深度优先搜索（先序，中序，后序）：由于递归本质上是用栈的，因此手动实现DFS时可以用栈。
    - 最小栈（155题）：栈中的最小值随时可用，辅助栈（栈顶）可以记录当前最小值
    - 括号匹配（如有效的括号问题）
- 队列：需要用队结构的场景，先进先出（可以从头尾进出）
  - 使用队列时，需要维护一定的顺序或范围（如滑动窗口），因此可能需要移除尾部不符合条件的元素
  - 常用于广度优先搜索（BFS），图或树的层级遍历
  - 滑动窗口问题：队列用于存储窗口中的元素

  - 数组中的第K个最大元素【3次】: 因为题目没有保证答案唯一，所以需要考虑重复元素的情况，以及数据极端情况，需要完整版快排双指针思路
    - 错误点：
      - 1. 需要倒序排, 因为求第k大;
      - 2. 随机索引取法？第一版基准值可以取去右边界，这个简单些，少写两行代码，如果要求更高，再取随机索引；
        - 左闭右闭区间里取随机索引： l + Math.random() * (r-l+1) =>  Math.floor(l + Math.random() * (r-l+1))
      - 3. quicksort, 快排每一次处理范围的左右边界，是一个左闭右闭区间[left, right]。
      - 4. partition的左右边界的left-1 和 right, 是要扩展的边界， 不要和quicksort 的边界弄混了。
        - right 之所以不需要-1， 是因为right位置，最后会放置基准值，也就是最后会换到等于区
      - 4. 在缩小分区的范围的时候， l+1, r-1, 也是重要的，这是逐步缩小范围的关键，否则直接用r,l, 可能会出现死循环
      - 5. l>=r 时返回，排完后在数组中取元素就像行了。

  -  前 K 个高频元素【3次】： 因为题目保证了，数据答案唯一，所以不用考虑重复元素，用快排简化版，用单指针left指针就行了，会简单很多，不要又要统计频率，又要随机索引，细节都，容易出错。。
    - 当l===r 时需要返回什么呢？还是不用返回，或者没有这种可能？
      - l>=r 时，直接返回就行了，不需要考虑返回什么，排完后截取就行了。
    - Math.random(),不需要带参数， 范围为0到1， 不包括1；


- 3. 无重复字符的最长子串
  - 怎么处理重复的这个过程呢？ 遇到的字符记到hash中标记为true，如果下次再遇到呢;
  - 或者不用hash,用数组存储？
    - 用hash存, 用set存，有一个好处，set本身是不重复的，可以直接删除元素，无需判断是否相等；
    - 0. 循环条件为，右指针没有超过边界；
    - 1. 满足条件，更新结果。 并移动右指针扩大窗口，收集里加入right对应元素；
    - 2. 不满足条件，移动左左指针,缩小窗口,移除left对应元素
      - 移除left对应元素，不是移除重复元素，直到不重复，right继续走；
 


- 76. 最小覆盖子串: 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。
  - 如何判断覆盖？
    - 每一个需要的字符次数都找满（满足要求的字符种类的数量），或者超过。但是只在找满的时候计数；
      - 找满后，找满的计数count 不一定等于 t.length, 因为可能t有重复的字符，length就会比count大；
      - 找满的条件为： t的词频， Object.keys(tMap).length, 做判断；
        - 注意这是不是滑动窗口的hash 键数，而是所需要覆盖的字符串的hash键数，容易弄混；
    - 两层while比较好处理；
    - 小疑问： hash里计数为0了，他的key并不会消除啊，hash 的lenth 也不会变啊；
      - 实际不用管这个，只需要判断left移动后，此位置的值是否还是满状态的就行；

- 回溯
  -  N 皇后：注意用回溯
    - 放进判重集合的col, row-col, row+col用完，及时改回去
    - 结果收集：path.push(col) 处理完也得 pop 出来
  - 腐烂的橘子
    - 先遍历一遍二维表，记新鲜橘子数fresh，和腐烂橘子入口队列。处理腐烂队列，用树的层序遍历，过程中腐烂一个新鲜橘子就 fresh--;
    - 遍历固定表[[0,-1], [0, 1], [-1, 0], [1, 0]] + 当前位置(i,j), 表示新的位置索引
    - 别忘了对遍历过的，腐烂的橘子染色，避免往回重复寻找，形成死循环
    - 对于二维表格，变量能结构出来就解构出来用，避免这种写法：grid[cur[0]][cur[1]]，层级过多，容易写错, 应该把cur解构解构，再用grid[row][col]


- 矩阵旋转：
  - 为了保证只遍历矩阵的上三角部分，设矩阵的行索引为 i，列索引为 j，条件是 i < j，即：
  - 当 i == j 时，处于主对角线上，这些元素无需交换。
  - 当 i < j 时，处于主对角线的上方，这部分元素需要与其对应的下三角部分交换。（用[0,1] 这个右上的特殊坐标想象）


- 动态规划
  - 1. 动态规划一般初始化时，会有一个 原数据长度+1 的操作，会多初始化一个数据，因为，一般原始数据不会给 0， 空等情况的数据，而做题时，他们就是最小子问题，是最开始的情况，需要补充上；(有时不需要，具体看需不需0，空 这些最小子问题的答案, 也就是需不需要算 dp[0])
    - 如果有了长度+1，操作就需要注意， 用dp表的长度去遍历，把dp表填满
    - 左动态规划要注意，尤其是求最 大/长， 小/短的时，一个位置可能被反复填充，所以需要和自己先比较一下
      - 最长递增子序列
  - 二维动态规划： 编辑距离，最长公共子序列， 定义当时前n个字符，i到j的xx, 都是要长度算，取索引时要-1, 初始化后然后填dp表；
  - 72. 编辑距离【二次】： 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数
    - 判断：当前位置 d[i][j]， 分析word1 i 位置值 和 word2 j位置值是否相等, 来分解问题，排列所有可能性,分析i到j的操作步骤
    - 难点1：理解增：
      - 源字符删掉尾： dp[i-1][j]+1
      - 源字符改掉尾： dp[i-1][j-1]+1
      - 源字符尾部加一个: dp[i][j-1]+1; “增”的操作可以理解为向源字符串添加字符，使其与目标字符串匹配, dp[i][j-1]的值是知道的，在此基础上,只要源字符串尾部加一个字符，word1就能变成word2, 也就是得到dp[i][j];
    - 难点2： 状态的定义： *dp[i][j] 为将 word1 的前 i 个字符转换为 word2 的前 j 个字符，所需的最少操作数*。i，j都是长度，所以比较是否相等时对应索引需要减1
      - if(word1[i-1] === word2[j-1]) ===> dp[i][j] = dp[i-1][j-1]
    - 难点3： 初始化容易出错：
      - 要用： new Array(word1.length+1).fill(0).map(()=>new Array(word2.length+1).fill(0));
      - 如果用： new Array(word1.length+1).fill(new Array(word2.length+1).fill(Infinity))就错了
        - fill 填充的是引用，会引用到同一个数组；
  - 279. 完全平方数:给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
    - dp[i] = Math.min(dp[i], dp[i-j*j]+1); i 为 当前值，j*j 为i前面的完全平方数
  - 139. 单词拆分【2次】: 如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true;
    - 关键在于如何表示出类似 dp[i-word] 这种效果：
      - 截取字符串值差： sub = s.slice(j,i)；
      - 判断如果有之前的阶段值，并且值差在字典内就可以拼出： dp[j] && wordDict.includes(sub)
      -  因为初始化有长度+1 表示空字符串，所以外层i用dp.length 做遍历把dp表填满，就行了；
      -  内层表示每一个值得起始索引位置，需要到0, 表示索引，依次查看从0到i-1的位置能否被组成; 那么word.slice(i,j) 正好截取一个字符串，dp[j]表示前j个字符;
  - 300. 最长递增子序列【2次】： 数组 nums ，找到其中最长严格递增子序列的长度
    - 关键在于如何表示上一个阶段的值： 依次遍历位置在前面的值， 并且要比当前值小， 前值如果有，+1即可(遍历索引，往前看，比较值)
      - maxLength = Math.max(maxLength, dp[j] + 1);
    - 忘记了： 左动态规划要注意，尤其是求最大最小的时，一个位置可能被反复填充，所以需要和自己先比较一下
      - 比前面两个数都大的情况下，比如 5,3,7; 7的位置就会更新两次；
  - 416. 分割等和子集【2次】:一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
    - 关键点： 因为数字不能重复使用，所以目标值要从后往前遍历，避免出现一个2,可以得到所有+2的值，比如2,4,6等
    - dp[i] = dp[i] ||  dp[i-num];
      - 注意比较时， i-num 不能是负数，也就是i>=cur, 否则，结果就是unfined了
    - 特殊点：先遍历工具，再遍历容量，当前工具，看看可以得出哪些容量的值；（一般是先遍历值，再遍历工具，这题特殊,可能与工具不能重复选择有关）
  - 152. 乘积最大子数组【简单】： 整数数组 nums（有负数） ，找出数组中乘积最大的非空连续子数组
    - 记录到每一个位置为止的最大值和最小值，比较的是: dp1[i-1] * nums[i], dp2[i-1]*nums[i], nums[i]
      - 比较对象容易弄错
    - 初始时dp1 为 [nums[0]], dp2同样， max也为nums[0];


- 排列组合： 求排列，组合，子集，就是选择的过程。
  - dfs(path) 表示一次选择
  - dfs中遍历，从哪里开始选择元素：dfs中遍历，表示本次选择有哪些可选项
    - 如果是全排列，则元素有序，从0开始遍历，hash表记录用过的元素，选没用过的
    - 如果是组合（子集），则元素无序，所以要记开始索引（dfs参数传递），从startIndex开始遍历，往后找
  - 是否需要回溯：
    - 如果dfs中公用了除path 之外的变量则需要回溯，全排列中，有记录元素是否使用过的hash表，所以需要回溯
    - dfs中，只有一个path变量共享时，可以用concat拼接成一个新数组，避免回溯
  - 结果收集：
    - 排列组合都是在结尾收集，因为元素个数是固定的
    - 子集，元素个数不固定，就可是是0,1,2等各种个数，所以每一次进入dfs选择都要收集一次，不然在结尾选，就会漏掉中间的结果
  - 变体：
    - 电话号码的字母组合： 每个数字表示多个字母，也就是每一次可以多个选择，选择时遍历按键表示的数字集合就好了
    - 组合总和:找出 nums 中可以使数字和为目标数 target 的 所有 不同组合
      - 因为组合无序，所以要记开始索引，从startIndex开始遍历，往后找
      - 可重复选：下一次还从i（当前位置开始）开始，而不是从i+1开始
    - 分割回文串:
      - 记录起始索引，遍历剩下的字符串，分割字符串
      - 在什么时候把不是回文的过滤掉；在结尾么，还是过程中？
      - 关键在截取的字符串: *每一次处理时，不是选一个字符进入路径，而是通过遍历过程中累加，选一个或者一组字符，直到可以是回文的才进入路径里收集*
  
    
 - 32. 最长有效括号【二次】: 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度
   - 先从左往右扫描，然后从右往左扫描： 从两个方向找出各自的最大长度，取最大值
   - 从左看：右括号多了则无效，归零，重新计数； 左括号多，则可能有效，继续往后找；
      - 相等时结算一次，和max比较
   - 从右看同理；  

- 34. 在排序数组中查找元素的第一个和最后一个位置：
  - 确定左边界的方法是，当前元素不等于前一个，或当前已经到边界： mid === 0 || nums[mid] !== nums[mid-1]
  - 右边界同理

- 79. 单词搜索： 在二维表格中找单词
    - 1. 用索引index，表示字符串里要查找的字符
    - 2. 判断条件，如果在一个入口匹配到了单词，就可以返回true
    - 3. 染色标记避免重复找
    - 4. 递归中，如果越界或者不等于则提前终止，返回false, 如果找到了最后索引的位置还没有被终止，说明找到了，返回true;

- 208. 实现 Trie (前缀树)：
      - 字符串构建树,遍历字符串迭代, 赋值空对象, 到最后一个字符标记end
      - *abc 字符串 的前缀包括 abc本身*

- 153. 寻找旋转排序数组中的最小值
  - 通过计算中间点 mid, 与nums[right]比较，判断目标值所在区间，开始right指向数组末尾
  - 每次二分缩小范围，最终锁定旋转点，即最小值（区间只剩一个值那这个值必定就是了）

- 287. 寻找重复数： 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），有一个重复的整数 ，返回 这个重复的数 
  - 关键： 数字都在 [1, n]
    - 对于范围 [1, n]，取中间值 mid，然后(遍历)数一下数组中小于等于 mid 的元素个数
    - 如果这些元素个数大于 mid，说明重复的数字在 1 到 mid 之间，否则重复的数字在 mid + 1 到 n 之间；
    - 不断缩小搜索范围，直到找到重复的数字

- 146. LRU 缓存【中等偏难 2次】： 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。 
    - 实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，通常使用一个哈希表（用于快速查找）和一个双向链表（用于记录使用顺序）
    - 初始化时需要保存： key， value信息；需要预设头尾两个虚拟节点，便于删除实际的第一个节点和最后一个节点；
    - 注意： put插入节点时，有节点就用旧节点，否则新节点没建立pre和next，移动时，会出问题
    - get获取时，有可能不存在，需要判断
    - 删除头节点，容易出错：
      - 最后先将head.next.next 记录下来，然后改指针；
        - 不然的话，如果先改： this.head.next = this.head.next.next;， 那么this.head.next就已经发生变化了，已经指向的是this.head.next.next了，一不小心就容易出错；
    - 只需要一个把当前节点移动到末尾的辅助函数；

- 84. 柱状图中最大的矩形【二次】：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
  - 数组中，当我们去求左边或者右边的 第一个比它大或者比它小的的元素，就要想到单调栈；
  - 栈中记录的是未被处理的元素，当遇到比它小的值就可以结算了，用while循环结算所有可以结算的
  - 注意三个位置的值：左边界，右边界，当前元素；当前元素：栈顶 top, 左边界： 栈里top 下面的一个值（也就是左边第一个比它小的值）， 右边界：变动力到的比当前top小的值
  - 不需要单独处理柱子相等的情况，相等也入栈（也不过只是多算几次），并不影响最终结果；
      - 如果把相等的柱子跳过了，可能出错:
        - 举例： 如果有多个1的，情况下，导致本应成为分界点（左边界）的第二个1，无法入栈从而造成错误；
  -  *数组前后放入0，作为最终的左右边界，便于最后清算所有。*
  

  - 31. 下一个排列【*中等偏难*】： 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列
  - 有一个前提假设： 数组从后往前到某一个值为止都是升序排列的
    - 1. 找到第一个从后往前违反升序排列的值n，位置为i （找到可以变大起始的位置i）
    - 2. 然后用后面大区里比n大，又尽量小的值，和n交换 （变大但是要变的尽量小）
    - 3. 逆序i后面的值 （高位处理完后，把地位也尽量变小）
      - 注意（易错点）：i后面的值，无论是否交换过都是递增的，这是处理的逻辑假设前提，可以直接逆序

- 5. 最长回文子串【*中等*】： 给你一个字符串 s，找到 s 中最长的回文子串； 
  - 从中心向两边扩展：分为奇数回文和偶数回文
  - 检查回文时直接返回结果字符串，比较好处理
    -  const str = str1.length > str2.length ? str1 : str2;
  - 判断是否是回文不能越界，越界了可能两边都是undefined了，也会相等，可能就无限循环了
  
- 394. 字符串解码
- 忘了：正则 \d 才是 数字，而不是 d
- 忘了：字符串重复用repeat() 方法，而不是 *
- 忘了： 数字和字符串相加，结果是字符串

- 33. 搜索旋转排序数组
    - 先找极值，然后二分:
      - 注意极值min的条件是： mid <= right值, 此时缩小范围使用 right = mid就好,小于或者等于right,就是*在第二个升序数组，都有可能是min*; 如果用right = mid-1 来缩小范围，就有可能漏掉最小值是首尾值得情况
        - 理解找峰值min的关键：因为轮转数组是一个二段升序数组，所以 min是在第二段， 找min的整体过程是，一个右边right向中值靠拢（right可以等于mid），左边left向右边靠拢的过程(left = mid+1)； 

 - 78. 子集
    - 下一个起始位置不是：startIndex + 1, 而是当前遍历到的位置 i+1， 才当前结束的位置往后看；

  - 51. N 皇后
    - path在中间回溯后，最后放入结果res数组里，path也需要解除引用放入，否则，path引用最后回溯，会始终是空;
      - 或者path中间不用回溯+push&pop, 直接用concat 拼，就是一个新的引用，就没有这些问题了；


  - 208. 实现 Trie (前缀树)
    - 代码怎么组织， search 和  startsWith 有一定相关性，怎么复用抽离？代码需要最后的node节点做辅助，但是题目需要布尔值返回；
      - 共性就是： 都要找到最后一个节点，看有没有， 有就是前缀， 有并且用结束边界就是单词；需要写一个prefix 工具函数；
    - 在search 返回时，要求返回的是布尔值，因此：
      - 不能写成： node && !!node.isEnd，  这样node， 为null时返回的就是null了，不是布尔值；只有在条件判断时，才能强制把表达式转为布尔值；
      - 应该写成： !!node && !!node.isEnd  或者  node !== null && node.isEnd

  - 94. 二叉树的中序遍历: 左边界依次入栈
    - 循环条件是：stack 有长度，或者 left存在
    - 一开始栈里不需要放节点, left = root; 然后把左边界依次入栈； 如果放了，容易放两遍root;
      - 迭代： 有left节点就放入，而不是由left.left才放入，否则会有缺漏

  - 101. 对称二叉树
    - 镜像： 开始传入两个相同节点，left和right都为root（也可以直接传入root的left，和right）； 然后用left.right 和 right.left; left.left 和 right.right 去比较；
    - left 或者 right 其中有一个为空的比较方式： 
    - `if(!l || !r){
            return l === r;
        }`

  - 543. 二叉树的直径
    - 先求树高，再求直径；树高是一个dfs，直径也是dfs，两个能融合成一个dfs么，还是得分开写？
      - 融合写，关键在于理解递归的返回：当前层递归的值，不仅可以在当前层算出了，还可以通过下一层返回回来；
        - 开始的返回是叶子结点的返回
        - 结束的返回是除叶子结点外每一个节点的返回，也包括根节点
    - 一个节点的直径 = 左树深度 + 右树深度; 在递归遍历中更新最大直径就好了

  - 230. 二叉搜索树中第 K 小的元素
    - 理解题意，第一小就是：从小到大排列，第一个元素；以此类推；

  - 114. 二叉树展开为链表
    - 先记下root的左右树；然后找到左树的最右节点，把右树放在其右边；然后把左树放在root的右边；
    - 易错点：找到左树的最右节点
      - 二叉树节点向一个方向迭代时，while里的判断条件是什么，如果是right那么到最后跳出，right为空，如果是right.right 那么第一个right可能为空
      - *根本原因是right 这个初始值可能为null, 那么从不为null 的开始迭代，right从root开始迭代寻找，root已经判空过；*


  - 105. 从前序与中序遍历序列构造二叉树
    - 对于递归参数是算出来的，怎么处理呢？ 如果这个计算逻辑放在递归内，那么第一次调用怎么传参呢？
      - 实际第一次： 初始值先序和中序的数组都是同一个，是一样的， 参数可以一眼看出来；
    - 参数所有的加 与 减， 索引相减得到的是什么？
      - 是相差,个数，保持索引差就行；
    - 节点数量容易想错， 数量应该是： inorderIndex - inorderStart， inorderIndex为找到的中序数组里的先序头节点位置，index为头节点的位置所以 index-start 为size 而不需要加1，因为left数组不包括这个头节点，实际计算可以是index-1-start+1;

   - 437. 路径总和 III
    - 先求和计数，再更新前缀和的映射表，避免污染映射表后，计数错误；
      - 比如 targetSum 为0 时，如果后计数，就会出错；
    - 怎么保证路径方向向下？处理完左右节点，回溯的时候把它在hash里减掉,就能保证向下了；
      - 重点在于回溯。比如处理cur的左右子树时， 处理完左右子树时会回溯的。 同样对于其left分支，当left分支的左右子树处理完后，也是会回溯的饿，会恢复处理left时，hash的状态； 所以当开始处理右子树时，也不会被左子树影响；

   - 236. 二叉树的最近公共祖先
    - 递归，逻辑怎么写呢？ 做二叉树，思考复杂的题，一次只考虑，当前节点，和左右树；不用考虑太深；如果当前节点是，怎么通过左右子树返回结果呢？
      - 依照左右分支递归，那么如果 一个是另一个的子节点，那就处理不了了啊；
        - 如果当前节点满足条件，那么在递的过程中就返回，不需要到归过程再收集；
    - 思路及过程，还是有点难度的，不是很好想：要注意最后返回的是一个节点；
      - 如果根节点为空，或者找到了p或q，则返回该节点
      - 如果左子树和右子树都找到了p或q，说明当前节点是最近公共祖先
      - 如果只在左子树或右子树找到，则返回找到的那个节点
        - 说明，一个是另一个的祖先，返回先找到的那个子树即可

  - 124. 二叉树中的最大路径和
    - 因为要求的是最大值，算出左右左树的最大贡献值需要和0比较，如果是负值就不要，取0就好。


  - 160. 相交链表
    - 代码的简洁写法： 
      - 当A不等于B时继续循环,等于时跳出；
      - 等于null的时候，说明到了结尾，换到另一个的头

  - 141. 环形链表
    - 判断条件是什么呢？
      - 不加?.符号的情况下， 如何避免 fast.next.next; 各种需要判断next为空的情况；
        - 循环判断条件是：fast && fast.next， 然后再循环里如果 slow === fast 则说明相遇，快指针走完还没有相遇，则说明无环；
        - 首先把没有节点，或者只有一个节点的排除掉
        - 在循环里面，走完再判断，避免第一个节点相同的情况不好处理


  - 54. 螺旋矩阵
  - 命名尽量语义化，避免加减的时候方向搞反了。上面的是bottom, 下面的是top;
  - bottom <= 等于top 进入循环， 可以等于，以便于处理一行的情况； left和right也同理；
    - 但也因为这个条件，在循环里剩下最后一行，一列时，可能会出现重复遍历的情况，所以再循环里，也要做边界判断；
    每次加减后，如果越界就跳出循环；

- 56. 合并区间【2】
  - 需要一个结果数组res, 如果结果数组为空，或者当前区间和最后一个区间不重叠, 直接放入结果数组
  - 否则，合并当前区间到结果数组最后一个区间
  - 区间的结尾时，两个合并区间结尾中，取最大值；
- done


- 238. 除自身以外数组的乘积
  - 求前缀积时怎么求呢？
    - 第一遍遍历求前缀积，res数组里对应位置填前缀积， pre记录当前位置前缀积结果
    - 第二遍遍历求前缀积*后缀积,res对应位置填的是最终结果，suf记录当前位置后缀积结果


- 283. 移动零
    - 怎么保证相对顺序不变呢，一次快排除了基准值能保证相对顺序么
      - 从左边开始先处理左边的值，相对顺序就不会变化，不是零的换到0的左边；本质是从左边开始扫描，不是0的往左移，然后扩展左边界吞掉（快排的简化）

- 42. 接雨水
  - 确定了左右边界，怎么表示盛水呢，还需要一个变量么？
    - 需要两个，要记录左右边界的最大高度leftMax 和 rightMax，如果新边界的大于最大的高度，*要更新边界高度*；
      - 有四个关键变量：leftMax 和 rightMax 才作为边界高度计算，算两个边界的最小高度；而left,right只是作为指针移动；

- 49. 字母异位词分组
  - 忘了，字符串排序是咋排的呢？
    - 先变成数组在排序，排序是数组方法；

- 128. 最长连续序列
  - 思路记不清了；
    - 当前值前面一个没有值的，就可以当做一段连续序列的起始点，避免重复遍历；

- 15. 三数之和【3次】
  - 思路混乱：关键是这个区间的数组重复怎么处理；
    - 遍历：固定一个i位置的数，然后从i+1 到 length-1的位置去排查
    - 关键点： 排查范围，循环条件是： left<right
      - 相加等于0时，也就是找到一组时，需要跳过重复的数，便于寻找下一组,*使用while连续跳过*, 相等时，左指针相等时left++, 右指针相等时right--， 直到不相等，或者越界; *内部跳过，不需要用continue,容易迷惑*；
  - 有负数，排序必须自定义，不然排出来是不对的用：nums.sort((a,b)=>a-b)
  - 易错点：
    - 需要到：nums.length-2，最后面留两个位置；
    

  - 41. 缺失的第一个正数
  - 忘记思路： 正数是一个隐藏条件，意味着隐藏着遍历索引有关的序，用遍历去排序，而不用正常的排序，就会是o(n)的
  - 但是把元素按索引放置会不能用额外数组的情况下，会出现覆盖的情况，怎么处理呢？
    - 通过交换，先把当前元素换到正确的位置，然后从当前位置继续处理；
    - 注意nums[i] 应该放在nums[i]-1的位置上
    - 要注意判断索引： nums[i]-1,不能越界 应该 在0到nums.length-1之间
    - 满足条件：不越界，且不相等 `nums[i] !== nums[nums[i]-1] && nums[i]-1 >=0 && nums[i]-1<nums.length` 的情况下，在while循环里一直交换，nums[i]位置上是正确的数，或者索引越界；
  

  

# 需要背诵的算法基础【15分钟背诵】

一些潜规则默认需要知道的：
- 思路方向
   - 先想暴力尝试解法，如果解法可能嵌套多层循环的，想想能不能化解成，多次循环+hash存储，来减少时间复杂度
     - 把那种需要在一次遍历时求出来的值，分解出来，放到不同的循环中
 - 两个变量向前迭代： [pre, cur] = [cur, pre+cur]
 - 做二叉树，思考复杂的题，一次只考虑，当前节点，和左右树；不用考虑太深；如果当前节点是，怎么通过左右子树返回结果呢？

- 常规：
  - 中位数索引： (left+right)/2, 奇数个元素正好是中间的位置，偶数个元素是中间两个元素之间的位置，需向下取整。
  - 非递减顺序排列： 就是递增排列
  - 如何判断二维表格的元素在一条斜线上：坐标，row - col 相等 或者 row +col 相等
  - 插入排序，就是拿起当前i位置元素cur往前插，从i的前一个位置j(j=i-1)开始往前找, 那么j+1的位置每一次都是待填充的，直到找到cur大于的时候，把j+1位置填上即可（注意不要越界）
 
  - 快排每一轮排序，不仅会*排好基准值的位置*，最关键的还是*做好了分区*，以基准值为分界，把大的放一边，小的放一边；
    - 变体:
      - 荷兰国旗，0,1,2分区
      - 移动零,将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序
        -  以0为分界，不等于0的全放在左边，然后让left边界右移吞掉非零区
     - 数组中的第K个最大元素： 如果k-1 这个索引，在本次排好序的区间(等于区)里，left<=k-1<=right， 那么就是找到了；
     - 前 K 个高频元素： 统一元素频率，按频率快排，如果k这个索引位置，在排好序的区间里，那么arr.slice(0,k), 就是前k个高频
  - curStr.repeat(curNum)， 重复一个字符串
  - Object.values(obj); 取obj值的数组
  - Object.entries(obj); 取obj键值对二维数组；
  - Array.from(str); 字符串变数组；
  - 旋转数组特性： 两段升序数组，第一段比第二段大； 或者一段升序数组；可通过中值与数组right值比较，缩小查找范围，判断当前值落在哪一段序列；
    - 如果旋转的次数正好是数组的长度，那么数组的顺序会保持不变，即是一段升序数组；
  - 二维数组里涉及到多个方向查找的，一般先遍历二维数组，找到入口点（四方搜寻的起始点），然后递归。循环开场，也就是在循环里递归；
  - 括号无效： 从左向右遍历，当使用的右括号数量大于左括号数量，则此括号序列无效；反之同理；左右括号相等时可考虑计数；
  - 数组（或树）任意位置向后遍历和为target 的次数， key = res + cur - target,(也就是当前和-target) , map表示到每一个节点的阶段和及次数，map[key]则表示有和为key的有多少次（如果元素有负数，可能出现多次和为同一个值的情况）
    - 可以解题： 求和为 K 的子数组个数，初始化 map[0]=1, 前缀和为0的出现次数开始为1;
  - 异位词判断： 排序 或  charCodeAt
    - 1. 异位词分组：已经确定是异位词，所以用排序的方式，是异位词那么排完序，在变成字符串就是一样的
    - 2. 滑动窗口寻找异位词： 不确定有没有异位词，也不确定从哪里开始，哪里结束，所以用词频统计的方式更省力
      - 在用词频判断异位词时，可以使用哈希表来记录字符频率来比较，但是效率不高，所以用数组代替哈希表
      - 数组的索引代替哈希的key: key(索引)为: s[i].charCodeAt(0) - 'a'.charCodeAt(0)
      - 最终数组toString 去比较
  - 使用 Set 存储数组中的元素：这可以在 O(1) 时间内检查一个元素是否存在； 特别是对于不需要关注key的，有时比map hash更高效;


- 排序：
  -  有依赖关系的一组元素的排序： 拓扑排序
     -  相关概念：入度，出度，nexts(直接相连的节点)
       - 1. 先找到入度为0的点A排在前面， 然后把A点极其影响（也就是它的指向边）擦掉， 也就是把它指向的nexts点的入度减1；
       - 2. 找下一个入度为0的点


- 二叉树：
  - 树深度 = Math.max(左树深度， 右树深度) + 1
  - 一个节点的直径 = 左树深度 + 右树深度 + 1; （树里打弯求路径和，也是类比于树深度+树直径两个概念去解）
  - 搜索二叉树的中序遍历是一个升序数组
  - 二叉树的右视图： 深度遍历，以cur, right, left 这种特殊的顺序去遍历, 每一个深度，第一个遍历到的节点就是从右边看到的节点；左视图同理，先序遍历即可:cur, left, right;
  - 找公共祖先：当找到含有指定节点的左右子树后都*回溯当前节点*，那么当前节点就是要找的节点


- 因为组合无序，组合避免重复选取元素的关键就是： 在dfs里记录当前所迭代到的位置startIndex， 从当前位置往后看看，可以与后面的哪些元素组合;
  - 一般也就是在递归中遍历， 遍历起始是记录的起始位置；



- 链表；
  - 基本技巧： 
    - 设置虚拟节点 dummy = new ListNode()
    - 反转链表
    - 找链表中点：双指针，同时走，慢针走一步，快针走两步，直到快针踏空，慢针就指向中点（偶数的前一个，奇数的中点）
    - 合并两个有序链表
  - 找环形链表入环点：
    - 1. map记录法
    - 2. 快慢指针，让 slow 每次移动一步，fast 每次移动两步，当 fast 和 slow 相遇后，将 slow 指针重新指向链表的头节点，而 fast 保持在相遇点，然后两个指针每次都向前移动一步，它们相遇的节点就是链表开始入环的第一个节点
  - 找相交链表相交点：让这两个指针分别遍历各自的链表。当其中一个指针到达链表末尾时，将其指向另一个链表的头节点继续遍历，这样两个指针都走完相同的路程：A + C + B = B + C + A。如果两个链表相交，那么两个指针最终会在相交节点处相遇。 或者不相交，最终都为null;（相交链表的定义就是，就是两个链表共享同一个尾部）
  - 删除链表的倒数第 n 个结点： 
    - 快慢指针，慢指针从0开始（虚拟节点）走，快指针从n开始，当快指针到达结尾时，慢恰好在倒数第n+1个节点， 然后用这个节点去删
    - 考虑到有只有一个节点的特殊情况，必须设置一个虚拟头节点
  - 排序链表： 使用归并排序；先找链表中点拆分，然后再合并两个有序链表;
  - 合并 K 个升序链表：使用类似归并排序的分治策略，先从中间分割，到不能分割为止，再两两合并，会比逐一从前到后合并快很多 
  - 实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，通常使用一个哈希表（用于快速查找）和一个*双向链表*（用于记录使用顺序）来做
    - 双向链表可以在 O(1) 时间内实现元素的插入、删除和移动操作，而哈希表则提供 O(1) 的查找时间。
    - 初始化时需要保存： key， value信息；需要初始化头，尾两个虚拟节点，便于删除实际的第一个节点和最后一个节点


- 矩阵：
  - 基本技巧：
    - 原地操作： 就是不能用额外的矩阵来保存状态
  - 矩阵置零：第一遍，遍历出行坐标为0的，和列坐标为0的分别记录到map中（或者数组中，索引记录）； 第二遍，发现有元素的行或列坐标在map中，就置为0； 
  - 螺旋矩阵：定好边界left, right ,top ,bottom。在循环中，四遍遍历，在不越界的情况下，遍历矩阵四周边界，依次添加元素到数组，到边界后移动其对应的边界（比如向右遍历上边界，完成后，应该将上边界-1；）
    - *一旦在循环内部发现越界，立即终止循环break，而不是继续判断处理，否则就可能多放；*
  - 旋转图像（90度旋转）：先沿着对角线翻转， 然后沿着纵轴对称翻转
    - 对角线翻转： 
      - 当 i == j 时，处于主对角线上，这些元素无需交换。当 i < j 时，处于主对角线的上方，这部分元素需要与其对应的下三角部分交换。
    - 翻转每一行：将每一行的元素进行左右翻转： matrix[i].reverse()

- 数组：
  - 轮转数组：轮转k步，可以理解为每一个元素的位置都向前走k步，i+k, 新的索引位置为 (i+k)%length；
  - 除自身以外数组的乘积：两次遍历，
    - 第一遍遍历求前缀积，res数组里填前缀积， pre记录当前缀积结果
    - 第二遍遍历求前缀积*后缀积，suf记录当前后缀积结果
  - 缺失的第一个正整数：
    - 两次遍历： 一次遍历，尝试把每个数字 nums[i] 放到其应该出现的位置 nums[nums[i] - 1] 上（通过在原数组交换）， 第二次遍历数组，寻找第一个 nums[i] != i + 1 （元素没在其该在的位置）的位置，那么 i + 1 就是缺失的最小正整数；
    - 注意交互时： *js数组元素交换时，把有计算的元素写在前面*，这样它就是被算出来而不是先被换掉：[nums[nums[i]-1], nums[i]] = [nums[i], nums[nums[i]-1]]， nums[nums[i]-1]必须写在前面
      - 解构赋值的左边是目标位置， 右边是从数组中取出来的值，解构赋值在执行时，右边的表达式先被计算，计算完之后再将值分别赋给左边的变量。为了保证交换操作的正确性，nums[nums[i]-1] 必须放在解构赋值的左边，并且先赋值，以避免 nums[i] 被修改后影响 nums[nums[i]-1] 的计算

- 栈：
 - 数组中，当我们去求左边或者右边，第一个比它大或者比它小的的元素，就要想到单调栈；
 - 字符串解码：维护字符串和字数两个栈,遇左括号入栈记录，遇右括号结算，如： 3[a]2[bc]==> "aaabcbc"

- 滑动窗口：题目关键词： 满足xx条件 最长/最短 子串/子数组/子序列 （子序列可以不连续）
  - 滑动窗口最大值：
    - 求最大值，需要维护一个递减队列，这样可以确保队列的头部始终是窗口内的最大值
      - 理解：新元素如果大于队列尾部的元素，说明它比尾部的元素更有可能是最大值，所以移除尾部较小的元素。队列头部的元素始终是当前窗口的最大值。（新入元素把队尾小的挑掉）
     - 定义左右边界，
       - 左边界初始为-k+1（方便左右边界一起移动），当窗口右边界大于等于 k 时，开始记录最大值
       - 也可以右边界到达索引位置k-1，再开始处理（这个其实更好理解）
     - 当过期的队头元素是即将移动的左边界，则移除队头
   - *维护递增递减队列的思路：求大留大，求小留小；*
     - 求最大，那么新进来的大值就更有意义，大的把小的挑掉，维护的就是递减（*新入元素把队尾小的挑掉*）
     - 求最小，那么新进来的小值就更有意义，小的把大的挑掉，维护的就是递增（*新入元素把队尾大的挑掉*）
 -  最小覆盖子串: 最短模版
    - left, right双指针维护滑动窗口边界
    - 使用两个哈希表进行字符计数， need 用于记录 t 中每个字符需要的次数，window 用于记录窗口中每个字符的出现次数
    - 移动右指针扩展窗口， 到窗口中包含了 t 中所有字符
    - 移动左指针收缩窗口：当窗口中包含了 t 中的所有字符时，移动 left 指针缩小窗口，直到窗口不能再缩小为止，记录最小的有效窗口 
    - 判断覆盖用: valid 计数，记找满字符的次数，当找满字符的次数等于need 的key的数量，说明找满了，可以移动左边界缩小窗口，同时, 如果缩小的左边界也是 恰好的满字符 ，更新valid
  - 无重复字符的最长子串：最长模版
    - 判重用Set： 
      - 删除：obj.delete(val)
      - 判重： obj.has(val)
      - 添加： obj.add(val)

  
   
- 双指针：
  - 盛最多水的容器，数组中两个位置的柱子能盛的最多水量：
    -  记录容量，两边相中间找，哪边矮移动哪边（矮的那边移动，更可能出现更多的容量），有更大的容量就更新；
  - 接雨水
    -  左右指针从左右边界向中间走，然后移动矮的边界(移动矮的才能保证尽可能完整盛水)；比原边界高的就替换原边界；
    -  有四个关键变量：leftMax 和 rightMax 才作为边界高度计算，算两个边界的最小高度；而left,right只是作为指针移动；
    -  移动了哪一边，才去看哪一边能不能盛水;
    - 因为每次移动1，然后就结算，所以结算只需要： less-height[i]
  - 三数之和为0，返回所有和为 0 且不重复的三元组。
     - 先排序
     - 遍历数组，固定第一个数字，然后使用双指针在剩下的部分查找另外两个数。
     - 避免重复：因为不能重复，数组是排好序的，所对于固定值，以及左右两个指针都有遇到和前一个值相同需要跳过的逻辑；固定值如果和前一个值相同，则需要跳过；左指针找出一个值，这个值和自己之前找到过的不能重复；右指针也是如此;


- 哈希：对象存 或者 Set存
  - 两数之和： 只需要一遍遍历，哈希表里找到就返回，没找到就存一下（因为两个数，前面找不到，存了之后，后面肯定找的到，比，2,7， 求和为9，跌到到2的时候找不到，把2存了，到7时就找到了）
  - 最长连续序列：只从连续序列的起点开始扩展序列：遍历数组中的每个数字 num，如果 num-1 不在集合中，说明它是一个序列的起点。从这个起点开始，尝试逐步+1，找到以 num 为起点的最长连续序列。


- 向左右尝试： 
  - 最长回文子串： 给你一个字符串 s，找到 s 中最长的回文子串； 
    - 从中心向两边扩展：分为奇数回文和偶数回文
  

- 多维动态规划：
  - 最长公共子序列： 分为尾部（当前）字符相同，和不相同的两种情况，来谈论dp[i][j]的值


- 一些默认需要熟练于心的模版代码

- 1. 根据字符串生成对象（树）
  
```
let node = {};
    for(const w of word){
        if(!node[w]){
            node[w] = {}
        };
        node = node[w];
    }



    {
      a: {
        b: {
          c: {}
          }
        }
    }

```

- 2. 反转链表： 所有翻转链表，都是先记节点，再改指针

```

var reverseList = function(head) {
    // pre 为null， 而不是初始化为值为null的node节点, 这是不出现环的关键
    let pre = null, cur = head;
    while(cur){
        let next = cur.next;
        cur.next = pre;

        pre = cur;
        cur = next;
    }

    return pre;
};

```

- 3. 找链表中点

```
双指针，同时走，慢针走一步，快针走两步，直到快针踏空，慢针就指向中点（偶数的前一个，奇数的中点）；

let left =head, right = head;
    while(right.next && right.next.next){
        left = left.next;
        right = right.next.next;
    }
    const center =left;

```

- 4. 滑动窗口

```
题目关键词： 满足xx条件 最长/最短 子串/子数组/子序列

// 最短模版：右扩到满足条件时， 左缩

初始化left, right, result, bestResult

while(右指针没有超过边界){ 
  窗口扩大，加入right对应元素， 更新当前result
  while(result满足要求){ 
    更新最优结果bestResult
    窗口缩小，移除left对应元素， left右移
  }
  right++;
}
返回bestResult



```

```
// 最长模版: 右扩到不满足条件时，左缩

初始化left, right, result, bestResult

while(右指针没有超过边界){ 
  窗口扩大，加入right对应元素， 更新当前result
  while(result不满足要求){ // 移动的过程中一直满足 
    窗口缩小，移除left对应元素， left右移
  }
  更新最优结果bestResult
  right++;
}
返回bestResult


```

ps: 有时，用一层循环，里面用if判断也是一样的，关键是要理解过程；

- 5. 动态规划模版

```

- 一层遍历i(值), 二层遍历依次处理i前面的值， 都是此公式的变形： 
- dp[i] = Math.min(dp[i], dp[i-coins[j]]+1) ， 前一个有结果的值与当前值的关系 

function dpSolve(n, input) {
    // 1. 初始化 DP 数组，定义初始状态
    let dp = Array(n+1).fill(某个初始值);  // dp[i] 表示到达第 i 位置时的子问题解

    // 2. 第一层遍历：遍历所有状态（从小到大）
    for (let i = 1; i <= n; i++) {
        // 3. 第二层遍历：从前一个状态转移到当前状态
        for (let j = 0; j < i; j++) {
            // 状态转移：根据前面的结果，更新当前 dp[i] 的值
            // dp[i] = 状态转移逻辑(dp[j], ...);
            // 比如：dp[i] = min(dp[i], dp[j] + cost);
        }
    }

    // 4. 输出结果
    return dp[n];  // 最终的解是 dp 数组的最后一个元素
}



```


# hot 100 题型归纳

各类题型的有点难度的经典题；

- 二维动态规划：初始化+1，dp[i][j], 都表示长度，前i个到前j个， 用字符串取索引时记得-1， 分最后一个字符相同和不相同处理，然后填dp表；
    - 72. 编辑距离
    - 1143. 最长公共子序列



# hot 100 常见题型，规律分类总结，精华浓缩

本篇跟上面的hot 100 类似，只不过本篇更加精炼，适合突击复习，一两个小时内的考前快速复习，记大思路；

标记*中等偏难*的，是我会被卡住的题目，需要重复看；


### 分类

#### 动态规划


总体思路： 
- 1. 定义状态和状态转移方程： 定义dp[i]表示的含义。通常dp[i]会表示前i个元素的最优解或某个特定问题的解。明确dp[i]与dp[i-1]之间的关系， 
- 2. 初始化： 初始化dp数组的起始值，比如dp[0]、dp[1]。这些初始值通常是问题的边界条件
- 3. 遍历顺序： 确定遍历dp数组的顺序，是从前往后，还是从后往前


- 1. 得到当前值：

  - 118. 杨辉三角【简单】： 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行
    - 得到当前值
      - 上一行的两个值相加： dp[i-1][j-1] + dp[i-1][j]

  - 279. 完全平方数【中等】：求和为 n 的完全平方数的最少数量 
    - 得到当前值：
      - 比较： 当前值的dp结果，和 前一个（各种可能）结果 + 各种可能性值； 
      - Math.min(dp[i], dp[i-j*j]+1)

  - 139. 单词拆分【中等】：如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true
    - 得到当前值：
      - 判断： 当前结果可用前一个（各种可能）结果 与 提供的各种工具凑成
      - dp[i-word] ===>  if(dp[j] && wordDict.includes(s.slice(j,i)))

  - 152. 乘积最大子数组【简单】： 整数数组 nums（有负数） ，找出数组中乘积最大的非空连续子数组
    - 得到当前值：得到当前的最大值，和最小值
    - 比较： 当前值*前一个（各种可能）结果 与 当前值，得出最大值和最小值； 取最终的最大值；
      - Math.min(nums[i], nums[i]*dp_min[i-1], nums[i]*dp_max[i-1])
      -  Math.max(nums[i], nums[i]*dp_min[i-1], nums[i]*dp_max[i-1]) 

  - 416. 分割等和子集【中等】
     - 得到当前值： 向左查询，因为num工具不能重复使用，所以倒序向左查,先不填 dp[num]的值，避免多倍num,和其他值重叠；
       - 判断： 当前值 + 前一个（各种可能）结果， 是否等于目标值
       - dp[i] = dp[i-num] || dp[i]

  - 322. 零钱兑换【中等】： 凑成总金额所需的 最少的硬币个数
    - 得到当前值： 获得到当前i位置（阶段）的最大值：
      - 比较：当前值的dp结果，和 前一个（各种可能）结果 + 1； 
      - Math.min(dp[i], dp[i-coins[j]]+1)


- 2. 当前值选不选

  - 198. 打家劫舍【中等】： 你是小偷，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警，不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
    - 当前值选不选： 
      - 选不选怎么表示，感觉还是要分叉用递归啊？2
        - 1.  得到当前阶段最大值就行了； 后面的情况由后面的项考虑；
        - 2.  初始化基本值（头几个）
        - Math.max(dp[i - 2] + nums[i], dp[i - 1]);


- 3. 获得到当前i位置（阶段）的最大（小）值

  - 300. 最长递增子序列【中等】： 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度
    - n^2算法， 其他方法暂时比较难理解
    - 获得到当前i位置（阶段）的最大值：向左查找
      - 比较： 前一个（各种可能）结果 + 1， 更新最大值
      - maxLength = Math.max(maxLength, dp[j] + 1);


#### 多维动态规划

- 62. 不同路径【简单】： 机器人位于一个 m x n 网格的左上角， 每次只能向下或者向右移动一步， 到网格的右下角，共有多少条不同的路径
  - 得到当前值：
    - 通过向右，或者向左走可以得到当前值，推出状态方程；然后填dp表格
    - dp[i][j] = dp[i-1][j] + dp[i][j-1];

- 64. 最小路径和【简单】： 非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小，每次只能向下或者向右移动一步
  - 得到当前值：
    - 通过向右，或者向左走可以得到当前值，推出状态方程；然后填dp表格
    - dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]

- 1143. 最长公共子序列【中等】： 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
  - 判断：当前位置d[i][j], text1 i位置值是否和 text2 j位置值相等，来分解问题，排列所有可能性; 
    - 如果相等： dp[i][j] = dp[i-1][j-1] + 1;
    - 如果不相等： dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j])
  - 初始化dp表示，加上空字符串的表示


- 72. 编辑距离【*中等偏难*】： 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数
    - 注意只能编辑word1;
    - 判断：当前位置 d[i][j]， word1 i 位置值 和 word2 j位置值是否相等, 来分解问题，排列所有可能性,分析i到j的操作步骤
      - 如果相等, 则不用操作，用前一个的答案就好：dp[i][j] = dp[i-1][j-1]; 
      - 如果不等：假设进行一次操作后之后，两个字符就相等（截止到i,j位置），剩下的还需要（对比）那些dp值
        - 源字符删掉尾： dp[i-1][j]+1
        - 源字符改掉尾： dp[i-1][j-1]+1
        - 源字符尾部加一个: dp[i][j-1]+1; “增”的操作可以理解为向源字符串添加字符，使其与目标字符串匹配
        - dp[i][j] = Math.min(dp[i][j-1]+1, dp[i-1][j]+1, dp[i-1][j-1]+1) 
    - 初始化dp表示，加上空字符串的表示, 填第一行，第一列：dp[i][0], dp[0][j]


#### 向左向右，中心向两边尝试

- 5. 最长回文子串【*中等*】： 给你一个字符串 s，找到 s 中最长的回文子串； 
  - 从中心向两边扩展：分为奇数回文和偶数回文
  - 检查回文时直接返回结果字符串，比较好处理
    -  const str = str1.length > str2.length ? str1 : str2;
  - 判断是否是回文不能越界，越界了可能两边都是undefined了，也会相等，可能就无限循环了
   


- 32. 最长有效括号【中等】: 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
  - 先从左往右扫描，然后从右往左扫描： 从两个方向找出各自的最大长度，取最大值
  - 注意点：
    - 1. 左右括号数量相等时，尝试更新最大长度
    - 2. 从左看：右括号多了则无效，归零，重新计数； 左括号多，则可能有效，继续往后找；
      - 相等时结算一次，和max比较


## 堆 - 快排

前端堆类型问题基本可以用快排解决：1.0 版本和3.0 版本最终都能排好序
1. 没有重复元素的可以用快排1.0，从左到右扫描即可，效率低一点，一轮只能排好一个基准值位置
2. 有重复元素的最好使用快排3.0，效率比较高，一轮可以排好所有值为基准值的元素位置

理解快排： 快排每一轮排序，不仅会*排好基准值的位置*，最关键的还是*做好了分区*，以基准值为分界，把大的放一边，小的放一边；


- 215. 数组中的第K个最大元素【中等】：给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 要求O(n)
  - 快排3.0 部分版：实际就是找k-1这个位置应该排什么元素，如果k-1这个位置, 在某一轮排序基准值的左右边界内，那就找到了目标；
  - 疑惑点： 快排的算法复杂度为nlogn, 排一部分满足O(n)要求么？答： 最坏情况是o(n^2), 快排3.0随机选择基准值能抹平最坏情况，最情况目标元素正好在分区里，平均下来时间复杂度约为o(n)


- 347. 前 K 个高频元素【*中等偏难*】：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
  - 快排1.0一半版：因为只需要分界点，不需要完全排好序
  - 【记忆】： 关键步骤
    - 1. 如何理解前k高？对于一个排好序的数组，前k高怎么返回呢？答： 有一步关键的转换操作，先统计数字出现频率，得到数字-频率对，然后按频率排序
    - 2. 为排序一部分就可以了？答： 基准值做好了分区，排好了第k个元素n，那么比n大的就会在一边，比n小的就好在一边
  - 前k高：就是从大到小排序好的频率，的前k个元素；


- 75. 颜色分类【简单】： 给定一个包含红色（0）、白色（1）和蓝色（2）、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列
- 快排3.0简化版： 设定1 为基准值，从左向右扫描，left和right边界向中间挤压，比1小的排1左边，比1大的排1右边
- 注意，循环条件是： i<right, left 一般 碰不到 right, 因为中间有 1 隔着;



## 栈

条件性入栈与条件性出栈


- 20. 有效的括号【简单】： 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效
  - 简单的条件性入栈，与条件性出栈比较
    - 遇到左边入栈，遇到右边出栈对比
  - 做好hashMap

- 155. 最小栈【简单】： 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
  - 简单的条件入栈，与条件性出栈
    - 遇到比top小的入栈，遇到等于top的出栈

- 394. 字符串解码【*中等偏难*】： 给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数
  - 复杂的条件入栈，与条件性出栈
    - 入栈：准备两个栈，遇到数字和[, 分别入对应栈
      - 当遇到数字时，将其与之前的数字组合成一个完整的数字，并将其压入数字栈。
      - 当遇到 [ 时，说明后面会有一个需要重复的字符串，因此将当前构建的字符串压入字符串栈，并开始构建新的字符串。
    - 出栈：当遇到 ] 时，说明当前构建的字符串已经完成，需要根据栈中保存的重复次数进行解码，将解码后的字符串与之前的字符串组合起来。
  - 特殊方法： curStr.repeat(curNum)
  - 一句话： 遇左括号入栈记录，遇右括号结算;


- 739. 每日温度【中等】： 整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后
  - 复杂的入栈，与条件性出栈
    - 没有结果（比栈顶元素小）的入栈直接值的位置（索引），能得到结果的（比栈顶元素大的），先让所有小的栈顶元素出栈，然后再入栈
  - 一句话： 大的挑掉小的，同时结算


- 84. 柱状图中最大的矩形【困难】：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
  - 数组中，当我们去求左边或者右边，第一个比它大或者比它小的的元素，就要想到单调栈；
  - 栈中记录的是未被处理的元素，当遇到比它小的值就可以结算了
  - 注意三个位置的值：左边界，右边界，当前元素；当前元素：栈顶 top, 左边界： 栈里top 下面的一个值（也就是左边第一个比它小的值）， 右边界：变动力到的比当前top小的值
    - 左边的的理解是个难点


## 二分查找

基础模型1正常二分：while循环里，计算中值mid, 比较目标值与mid, 移动更新left,right,缩小查找范围, left>right 时，则找不到返回left;

基础模型2旋转数组二分：while循环里，中值mid与数组尾值比较，移动更新left,right,缩小查找范围, left === right 时返回left;


- 287. 寻找重复数【简单】【基础模型】： 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），nums 只有一个重复的整数 ，找这个重复的数 。
  - 确定二分查找区间，逐步缩小： while循环里，取中值mid， 统计<= mid 的元素个数，如果大于mid就在大于区找，否则在小于等于区找；
  - 值应该在left和right之间，left和right本不应该相等；当left 和 right相等时还没找到，那结果就取left（也就是比正常极限left大1的位置）;

- 153. 寻找旋转排序数组中的最小值【简单】【基础模型】： 长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组，请你找出并返回数组中的 最小元素； O(log n) 
  - 中值与数组尾值比较:
    - 比尾值大，则中值在第一段升序数组，更新 l = mid+1
    - 比尾值小，则中值在第二段升序数组，还可能是最小值，r = mid
    - 因为值必定存在，1的级别逐渐收敛，最后l===r, 无法收敛的就是结果了，返回r;

- 35. 搜索插入位置【中等】： 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
  - 与中值比较，移动更新left,right,缩小查找范围
  - 转化理解： 寻找等于目标值的位置，或者第一个大于目标值的位置；
    - 1. 单独处理比所有元素（最后一个元素）都大，和比所有元素(第一个元素)小的情况;
    - 2. 处理了上述情况后，目标值，必须在l到r之间，结束循环的条件是l>r, 所以，如果找到最后没找到，最后返回的是l(比l,r相等后大1的值);
    - ps： 当然1不需要单独处理，收敛到2中，代码完全不需要变化，但是这个写是一个剪枝，速度快很多，而且好理解；

- 34. 在排序数组中查找元素的第一个和最后一个位置【中等】:一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。O(log n) 
  - 理解： 非递减顺序排列，就是递增排列；
  - 使用常规二分解法，只不过用两遍，一遍找第一个位置，一遍找最后一个位置
    - 等于目标值是，和目标前一个值不同，即为第一个位置；最后一个位置同理；

- 33. 搜索旋转排序数组【*中等偏难*】: 整数数组 nums 按升序排列，数组中的值 互不相同, nums 在预先未知的某个下标上进行了旋转, 找目标值 target （O(log n)）
  - 旋转数组特性： 两段升序数组，第一段比第二段大； 或者一段升序数组；
  - 确定如何缩小查找范围：中值与数组末尾值比较；
  - 思路两段： 先查找出峰值，然后根据峰值划分区间，用正常的二分查找；

## 回溯


排列: 每轮遍历所有元素，选没用过的，直到选满

- 46. 全排列【中等】： 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
- dfs(path) 表示选择
- 因为有序，所以每个节点从0开始遍历，选没用过的
- 递归中：
  - 1. 遍历所有数据，如果当前元素没有被使用过,记录hash表标记使用，然后push 到路径里
  - 2. 递归完成后（回溯时），去除使用标记， 从路径中移除
- 关键点（巧妙点）：剩余可选数据，有一个hash 表记录下来，标记使用
- 一句话： 遍历所有，选没用过的

    
- 78. 子集： 
  - 组合无序，所以要记开始索引，从startIndex开始遍历，往后找
  - 因为是子集，元素就可是是0,1,2等各种个数，所以每一次进入选择都要收集一次，不然直接选，就会跳过一种个数了
  - dfs(path)表示选择
  - 只有一个path变量共享，所以可以用concat 避免回溯

- 17. 电话号码的字母组合： 
  -  dfs(path)表示选择
  -  每一次选择实在当前可选集合中找一个，所以需要在dfs里遍历
  -  因为组合无序，所以要记开始索引，从startIndex开始遍历，往后找

- 39. 组合总和:
  - 无序：因为组合无序，所以要记开始索引，从startIndex开始遍历，往后找
  - 可重复选：下一次还从i（当前位置开始）开始，而不是从i+1开始



- 79. 单词搜索【*中等偏难*】【染色必须回溯】： 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻（水平，垂直）的单元格内的字母构成， 字母不能重复使用
  - 遍历二维数组，找四方搜寻入口点，然后递归
  - 记索引递归，越界或者遇到不相等的（包括染色值）则返回false，往四个方向查找，找完恢复染色值,有一个方向找到即返回true，索引到结束没有被提前停止，则为找到


- 51. N 皇后【*中等偏难*】： 皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子，如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。返回所有不同的 n 皇后问题 的解决方案；该方案中 'Q' 和 '.' 分别代表了皇后和空位。
  - 分为三步解决：
    - 1. 按行解决问题，递归里判断在当前行具体放在哪里列
    - 2. 判断当前位置是否能放；记录当前位置到记录数组（列数组，与两个斜线数组，行肯定是不同的），递归完成会恢复数组
      - 难点如何判断点在不在一条斜线上
        - 1. 主对角线（左上到右下）上的元素，其 行坐标-列坐标 结果都是相等的； row-col
        - 2. 副对角线上(右上到左下)上的元素，其 行坐标+列坐标  结果都是相等的; row + col
    - 3. 处理二维数组结果


## 组合问题


组合: 因为组合无序，组合避免重复选取元素的关键就是： 在dfs里记录当前所迭代到的位置startIndex， 从当前位置往后看看，可以与后面的哪些元素组合
子集: 子集是组合中的一种，特殊的地方在于， 犹豫他不是固定数量的组合，所以每次进入dfs递归都要收集一次结果，而不是在终点收集

组合问题的统一解法：带起始索引，在递归中遍历


- 78. 子集【中等】【concat无需回溯】： 一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集
  - 因为子集无序，[1,2]与[2,1]只能算一个（就是组合问题），所以记录（传递）下一层开始索引，向后迭代（往后组合），避免重复取数
  - 关键点（巧妙点）： 子集在每一个节点上都有一个结果, 一进入递归就要收集
  - 一句话： 从当前位置往后看看，可以与后面的哪些元素组合
    - 从当前元素 i 开始，依次尝试将 nums[i] 加入路径中，并向下递归，直到遍历完所有元素
  - 还一种选和不选的思路，一会看看用哪种好，最好这类问题的格式模版保持一致

- 17. 电话号码的字母组合【*中等偏难*】【concat无需回溯】： 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回,就像手机打字。 比如：2对应abc, 3对应def
  - 简化技巧： 
    - 1. 按键的顺序是有序的，所以每次可选范围向后取一个就好了，范围已经确定,也就不需要记录开始的索引;
    - 2. 需要把数字对应的字符映射表示出来；（手写出来）
  - dfs里，看看本轮可以选择哪些字符去组合；
  - 一句话： 从当前位置往后看看，可以与后面的哪些元素组合


- 39. 组合总和【中等】【concat无需回溯】： 一个 无重复元素 的整数数组 candidates 和一个目标整数 target；同一个 数字可以重复被选取，数字的被选数量不同，则两种组合是不同的；
  - 可重复选，则意味着可以扫描所有元素；
    - dfs 里每次扫描所有元素，并选取，直到和大于等于target
  - 难点： 在可重复选的同时，如何避免数组元素顺序不同，但是个数相同的情况呢
    - 从当前位置往后看看，可以与后面的哪些元素组合；由于可以当重复选，所以下一轮递归还是从当前位置开始，而不是+1


- 131. 分割回文串【中等】【concat无需回溯】： 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。
  - 因为分割无序，所以分割转化为组合： 从当前位置往后看看，可以与后面的哪些元素组合
  - 带索引，递归中循环
    
组合问题参考模版：如果用concat，可避免回溯

```

const backtrack = (startIndex, path) => {
    // 1. 如果满足条件，收集结果
    if (满足某个条件) {
        res.push([...path]);
        // 如果不需要继续递归，可以在这里return
    }

    // 2. 从startIndex开始遍历候选元素
    for (let i = startIndex; i < nums.length; i++) {
        // 选择当前元素
        path.push(nums[i]);
        
        // 3. 递归进入下一层，i + 1 确保组合不重复
        backtrack(i + 1, path);

        // 4. 撤销选择，回溯
        path.pop();
    }
}

backtrack(0, []);
return res;



```

## 图

图的相关难题解法： 重要的是先要设计好数据结构
  - 关键概念： 必须知道图的这几个重要概念，才能解偏难的图类题目
    - 入度in： 有几个指向它的边
    - 出度out： 有几个从它出发的边
    - nexts: 和它直接相邻的点
  - 做题方法：举例： 
    -  拓扑排序： 在事情可能有前置依赖的情况下，如何决定做事的顺序
  - 思路：
  - 1. *先找到入度为0的点A排在前面， 然后把A点极其影响（也就是它的指向边）擦掉， 也就是把它指向的nexts点的入度减1；*
  - 2. 找下一个入度为0的点
  - 详细步骤：
  - 1. 遍历节点，hashMap记录所有点的入度，并把所有入度为0的点加入列表zeroArr；
  - 2. 遍历zeroArr, 加入到结果里去，并在hashMap里把对应入度减小，如果入度为0，进入到zeroArr列表；


- 200. 岛屿数量【简单】： 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成
  - 遍历二维数组，找四方搜寻入口点
  - 递归中染色，避免重复搜索

- 994. 腐烂的橘子【*中等偏难*】： 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。
  - 遍历，统计新鲜橘子的数量，同时把腐烂橘子加入到队列
  - 开始对队列进行层序遍历
    - 队列有长度时， 在while 循环里记录队列长度， 把里面的元素依次拿出来
    - 如果元素索引移动一个位置没有越界，并且是新鲜橘子， 就标记计数开关为true，并且标记为腐烂， 同时把此腐烂橘子加入到队列，新鲜橘子计数-1
  - 收集结果： 如果遍历完成，还有新鲜橘子，则不行
  - 难点： 如果有多个腐烂橘子同时开始感染，不会有最大的时间，最小的时间么？
    - 答： 无所谓，所有的腐烂橘子开始已经作为第一层收集到队列里了，会一起处理掉，会统计到最多的层

- 207. 课程表【*中等偏难*】: 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
  - 难点：这一题的思路比较难想，需要记住，有依赖顺序的元素，按顺序处理的方法
    - 1. 前置结构：建立两个map， 一个数组 【前置步骤比较多，这是最关键，也是比较难想的点】
      - 1. 一个map 表示当前课程有多少依赖；入度 inMap
      - 2. 一个map 表示当前课程是那些可能得前置: 直接相邻的点 nexts
      - 3. zero数组表示无依赖的可以，直接学的课程（入口点）
    - 2. 从zero数组里取出课程学习（zero数组里的只能是别的课程的前置，或者是孤立课程）
      - 如果当前课程不是任何课程的前置，则说明是独立节点，课程直接完成，课程计数count++;
      - 如果是别的课程x的依赖（前置）项，则将x的前置依赖数-1 （擦除其影响）
        - 当x课程前置项为0时，则将课程x添加到zero数组
    - 3. 当numCourses === count 说明所有课程已经学完；

- 208. 实现 Trie (前缀树)【中等】： Trie 前缀树 是一种树形数据结构， 请你实现 Trie 类：Trie() 初始化前缀树对象；insert(String word) 向前缀树中插入字符串 word；search(String word) 如果字符串 word 在前缀树中；startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true
  - 本质是利用字符串生成对象树，到末尾标记end

## 矩阵

- 74. 搜索二维矩阵【简单】：  m x n 整数矩阵：1. 每行中的整数从左到右按非严格递增顺序排列。 2. 每行的第一个整数大于前一行的最后一个整数。 找target
  - 由于行递增，列递增，所有从右上角开始找：target小于cur就向左找，大于cur就向下找

## 二叉树


树形dp：


- 104. 二叉树的最大深度【简单偏技巧】: 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数
  - 树深度 = Math(左树深度， 右树深度) + 1

- 543. 二叉树的直径【简单偏技巧】：
  - 一个节点的直径 = 左树深度 + 右树深度; 在递归遍历中更新最大直径就好了；
    - 要区分直径，边数和节点数的区别，边数别节点数少1， 可以先按节点数算，算出来的结果再减1；
  - 树深度 = Math(左树深度， 右树深度) + 1

- 124. 二叉树中的最大路径和【*中等偏难*】： 二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。
  - 上面543题的变体，求树的直径，只不过把元素加上了值，并且值可能为负数
  - 难点：
    - 1. 贡献值概念，类比于树的深度，只取左子树或者右子树其中比较大的，因为有负值，所以带上cur一起比较： 贡献值 = Math.max(root.val + left, root.val + right, root.val)
    - 2. 路径和： cur = root.val + Math.max(左子树贡献值, 0)+ Math.max(右子树贡献值, 0); 因为可能为负，所以和0比较一下，为负就不要


其他：

- 22. 括号生成【简单】：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
  - 选择类：列举所有可能，中途剪枝排除掉不可能的，收集最后的结果
    - 每次有两种可能，有左括号，可生成左括号；有右括号，可生成右括号；
    - 当使用的右括号数量大于左括号数量，则此括号序列无效；
    - 当左括号和右括号都用完时，收集结果

- 94. 二叉树的中序遍历【简单】：
  - 让left 为根节点，不停的像左迭代，同时压栈，直到叶子节点，开始出栈top，left赋值为right，继续循环；

- 226. 翻转二叉树【简单】
  - 无脑左右交换

- 101. 对称二叉树【简单偏技巧】：给你一个二叉树的根节点 root ， 检查它是否轴对称。
  - 简化的层序遍历思路（不用记长度），每一层对左右节点：
    - 成对的放入（放入自己和镜像）：左树的左节点，和右树的右节点；左树的右节点，和右树的左节点；
    - 取出的时候（取出自己和镜像）：依次成对的取出，对比，如果一方为空，或者不想等则不对称

- 102. 二叉树的层序遍历【简单】： 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。
  - 把节点放进队列，循环里记录队列长度，然后把一层元素依次取出来，同时把下一层依次放进去

- 108. 将有序数组转换为二叉搜索树【*简单偏技巧*】： 整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵平衡二叉搜索树。
  - 通过l,r 取他们的中值，Math.floor, 找到中间元素
  - 构造中间节点，同时dfs构造他的左右节点
  - 直到l>r;
  - 一句话： new TreeNode(nums[center], dfs(l, center-1), dfs(center+1, r))

- 98. 验证二叉搜索树【简单】： 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。节点的左
子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。
  - 搜索二叉树的中序遍历是一个升序数组；
  - 在遍历中如果发现当前值比前一个小，则不是；

- 230. 二叉搜索树中第 K 小的元素【简单】： 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素
  - 中序遍历返回k-1


- 114. 二叉树展开为链表【*中等偏难*】： 给你二叉树的根结点 root ，请你将它展开为一个单链表：展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。展开后的单链表应该与二叉树 先序遍历 顺序相同。
  - 先序递归地处理每个节点，将左子树移动到右子树的位置，同时将原右子树接到左子树的最右边节点后面。
  - 难点： 原来右树的处理，处理完左树后，要将原来的右树，添加到原来左树的最右节点后； 这样继续遍历时，才能位置cur, 左，右的顺序；

- 105. 从前序与中序遍历序列构造二叉树【*中等偏难*】： 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
  - 关键： 前序的第一个节点，就是中序的中间节点，由此可以按索引拆分数组，依次生成节点
  - 难点：
    - 1. root 不一定要放在递归外面，放在第一层返回即可
    - 2. 索引的拆分,加加减减的， 容易出错

- 437. 路径总和 III【*中等偏难*】： 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）
  - 关键点（难点）：当前路径和-目标值的结果，如果在之前的路径和map中，即说明，之前有路径满足;
    - 通过 key = res + root.val - targetSum 来查找是否存在有效的路径
    - 回溯时记得把路径和的map值-1， 免得对其他分支形成干扰

- 236. 二叉树的最近公共祖先【*中等偏难*】： 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。
  - 简洁版的思路比较难想： 当找到含有指定节点的左右子树后都回溯当前节点，那么当前节点就是要找的节点
    - base case: cur 为n1 或 n2，则返回cur, 否则返回 null
    - 假设左边节点在做子树，右边节点在右子树，都找到则染回root，否返回其中找到的一个，继续找下去；
    - 在第三次触达当前节点时（回溯），收集左右树的信息: 左右都不为空返回cur, 左右有一个空则返回有值的那个结果
      - 有一个子树返回为空，则说明在同一颗子树上
  
## 链表

基础模型：
  - 1. 反转链表
  - 2. 找链表中点
    - 双指针，同时走，慢针走一步，快针走两步，直到快针踏空前，慢针就指向中点（偶数的前一个，奇数的中点）；

- 160. 相交链表【简单偏技巧】: 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。注意，函数返回结果后，链表必须 保持其原始结构；
  - 技巧： 以交叉点分界，把链表分为三段, C为公共段，则： A + C + B = B + C + A
    - 双指针法： 让这两个指针分别遍历各自的链表。当其中一个指针到达链表末尾时，将其指向另一个链表的头节点继续遍历。如果两个链表相交，那么两个指针最终会在相交节点处相遇。 或者最终都为null;

- 206. 反转链表【简单】
  - 链表的最后一个节点指向null,而不是为值为null 的节点； 所以pre初始化应该为null, 不然会有环，这是易错点；

- 234. 回文链表 【中等偏难】； 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。空间复杂度o(1)
  - 1. 找链表中点
  - 2. 从中点开始反转右边链表
  - 3. 遍历左边，和翻转后的右边链表，有直到一方结束，有一个节点值不同，则不是回文；

- 141. 环形链表【简单】： 给你一个链表的头节点 head ，判断链表中是否有环。
  - 允许改原链表则用 flag标记，再次遍历到标记则有环；
  - 不允许改，则用快慢指针，慢指针走一步，快指针走两步，最终他们会相遇；

- 142. 环形链表 II【中等偏技巧】： 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。不允许修改 链表。
  - 使用Map，存储节点，遍历过程中，第一次遇到同一个节点，就是入环点；
  - 解法二： 快慢指针， c为相遇点到入口点的距离
    - 第一次相遇时快指针走过的距离 a + b + n(b+c),  慢指针走过的长度为x+y, 由于快指针走过的长度时慢指针的2倍，所以 2(a+b) = a+b + n(b+c), 化简一下可得 a = (n-1)(b+c) + c, 由于b+c是环的长度，可以略去，所以c = a;
    - 故： 第一次相遇后，慢指针从头节点开始走，快指针从相遇点继续走，都每次走一步，那么他们下一次相遇点就是环的入口点；

- 2. 两数相加【中等】：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
  - 由于是逆序所以可以直接相加， 注意设置虚拟节点，保持进位，就行
  - 题意中的逆序很关键，这样就可以直接相加，无值的当做0处理；
  - 注意跳出循环后，如果最后一位好还有进位，要多加一位数（多加一个节点）；

- 3. 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。【简单】
  - 快慢指针，慢指针从0开始走，快指针从n开始，当快指针到达结尾时，慢恰好在倒数第n个节点， 然后用这个节点去删
  - 考虑到有只有一个节点的特殊情况，可以设置一个虚拟头节点


- 24. 两两交换链表中的节点【中等】： 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
  - 设置一个虚拟节点，然后 pre, cur, next, tail 四个值从前往后捋就行了, 交换cur,和next, 交换完连接上tail;
  - 难点在于要考虑到,在内部处理的时候，pre.next等可能没有值的情况, 所有要判断pre.next && pre.next.next有值（及cur, next有值才能交换）才进入


- 25. K 个一组翻转链表【中等】： 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
  - 死循环中，首先遍历链表计算其长度，判断是否有足够的节点可以翻转，不够直接返回结果
  - 反转，并记录前缀
  - 把反转后的链表链接回去

- 138. 随机链表的复制【简单偏技巧】: 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。
  - 两遍遍历
    - 先遍历一遍复制链表节点，并把节点存到map里：map.set(cur, new ListNode(cur.val));
    - 再遍历一遍设置random指针

- 148. 排序链表【中等】： 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
  - 分割链表：使用快慢指针将链表从中间分为两个部分；注意找到中点后要让它跟链表后半部分断开：center.next = null; 
  - 合并两个有序链表

- 23. 合并 K 个升序链表【中等偏难】： 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。
  - 使用类似归并排序的分治策略，先分割，再两两合并，会比逐一从前到后合并快很多

- 146. LRU 缓存【中等偏难】： 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。 
  - 题目要求： 用正整数 作为容量 capacity 初始化 LRU 缓存，get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
  - 解法：
    - 实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，通常使用一个哈希表（用于快速查找）和一个双向链表（用于记录使用顺序）
    - 除了实现题目要求的初始化，get, put, 还需要实现 删除节点remove(node)， 将节点插入链表头部addToHead(node)， 的两个辅助方法；
      - 初始化时需要保存： key， value信息；需要头尾两个虚拟节点，便于删除实际的第一个节点和最后一个节点；
    - 注意： put插入节点时，有节点就用旧节点，否则新节点没建立pre和next，移动时，会出问题



## 矩阵

- 73. 矩阵置零【中等偏技巧】： 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
  - 两边遍历：第一遍，遍历出行坐标为0的，和列坐标为0的分别记录到map中（或者数组中，索引记录）； 第二遍，发现有元素的行后列左边在map中，就置为0；

- 54. 螺旋矩阵【中等偏技巧】：给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
  - 定好边界left, right ,top ,bottom
  - 在循环中：四遍遍历，在不越界的情况下，遍历矩阵四周边界，依次添加元素到数组，到边界后移动其对应的边界（比如向右遍历到右边界后，说明遍历完了一层，应该将上边界-1；）
    - 从左到右遍历当前上边界的所有元素，然后上边界下移。
    - 从上到下遍历当前右边界的所有元素，然后右边界左移。
    - 从右到左遍历当前下边界的所有元素，然后下边界上移。
    - 从下到上遍历当前左边界的所有元素，然后左边界右移。

- 48. 旋转图像（90度旋转）：【中等偏技巧】给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像。
  - 把旋转变为翻转： 先沿着水平轴对称翻转，然后沿着对角线翻转
    - 这个思路不好想，急着就行，90度旋转就是翻转两次
  - 水平翻转： 遍历到行的一半，遍历时直接交换
    - 对称点就是length - i -1, 这个也不好想
  - 对角线翻转： 遍历时交换，行大于列的的元素
    


## 普通数组

- 53. 最大子数组和【简单】： 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
- 向左尝试，dp填表，f(i)=Math.max（f(i−1)+nums[i],nums[i]）

- 56. 合并区间【简单偏技巧】: 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
  - 先按照start升序排列，如果i位置的尾>= i+1 位置的头说明重叠，可合并区间
  - 合并区间，会减少数组元素，在while循环中，有合并迭代所有i就不继续加了，而是停留在原位置，没有才+1，继续迭代

- 189. 轮转数组【中等偏技巧】：给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
  - 轮转k步，可以理解为每一个元素的位置都向前走k步，i+k, 新的索引位置为 (i+k)%length； 可以用额外数组存一下

- 238. 除自身以外数组的乘积【中等偏技巧】：给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。请 不要使用除法，且在 O(n) 时间复杂度内完成此题
  - 两次遍历：一次正向遍历记录元素左边的乘积，一次反向遍历记录元素右边的乘积，同时得出结果；

- 41. 缺失的第一个正数【中等偏技巧】：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。o(n)
  - 但是把元素按索引放置在其应该在的位置上，val应该在val-1的位置上； 比如1应该在0的位置上；
    - 通过不断交换，先把当前元素换到正确的位置，然后从当前位置继续处理（利用while循环，而不是if判断）；
      - nums[i] 应该放在nums[i]-1的位置上
      - 要注意判断索引： nums[i]-1是索引,不能越界 应该 在0到nums.length-1之间
    - 满足条件：不越界，且不相等 `nums[i] !== nums[nums[i]-1] && nums[i]-1 >=0 && nums[i]-1<nums.length` 的情况下，在while循环里一直交换，nums[i]位置上是正确的数，或者索引越界；


## 子串

- 560. 和为 K 的子数组【简单偏技巧】：给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。子数组是数组中元素的连续非空序列。
  - 使用前缀和来记录当前子数组的总和，使用哈希表来记录某个前缀和出现的次数
  - 初始化前缀和0的出现次数为1;

- 239. 滑动窗口最大值【中等偏难】：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。
 - 用双端队列， 定义左右边界；，双端队列存储的是数组元素的下标，并且在队列中的元素从队头到队尾是递减的。新元素大于队尾元素，就不停地挑掉队尾
 - 当窗口右边界大于等于 k 时，开始记录最大值
 - 当过期的队头元素是即将移动的左边界，则移除队头

- 76. 最小覆盖子串【困难】： 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
  - left, right双指针维护滑动窗口边界
  - 使用两个哈希表进行字符计数， need 用于记录 t 中每个字符需要的次数，window 用于记录窗口中每个字符的出现次数
  - 移动右指针扩展窗口， 到窗口中包含了 t 中所有字符
  - 移动左指针收缩窗口，当窗口中包含了 t 中的所有字符时，移动 left 指针缩小窗口，直到窗口不能再缩小为止，记录最小的有效窗口 
  - 判断覆盖用: valid 计数，记找满字符的次数，当找满字符的次数等于need 的key的数量，说明找满了，vaid +1，可以移动左边界缩小窗口，同时, 如果缩小的左边界也是 恰好的满字符 ，更新valid


- 3. 无重复字符的最长子串【中等】：给定一个字符串 s ，请你找出其中不含有重复字符的 最长 
子串的长度。
  - 滑动窗口：最长模版
  - 判重用Set： 
    - 删除：obj.delete(val)
    - 判重： obj.has(val)
    - 添加： obj.add(val)

- 438. 找到字符串中所有字母异位词【中等偏难】：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）
  - 如何判断是不是异位词: 在判断异位词时，使用哈希表来记录字符频率来比较，但是效率不高，所以用数组代替哈希表
    - 数组的索引代替哈希的key: sCount[s[i].charCodeAt(0) - 'a'.charCodeAt(0)]++
    - 最终toString 去比较
  - 易错点：
    - 数组初始化length应为26，否则（如果定义为p的长度）有些字母统计不到，就会出问题；

## 双指针

- 283. 移动零【简单偏技巧】：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序
  - 快排的变体： 以0为分界，不等于0的全放在左边，然后让left边界右移吞掉非零区


- 11. 盛最多水的容器【简单偏技巧】：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。
  - 记录容量，两边相中间找，矮的移动那边移动，有更大的容量就更新；
    - 理解： 矮的那边移动，更可能出现更多的容易


- 15. 三数之和【中等偏技巧】： 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
  - 先排序
  - 遍历数组，固定第一个数字，然后使用双指针在剩下的部分查找另外两个数。
  - 避免重复：因为不能重复，数组是排好序的，所对于左右两个指针，左指针找出一个值，这个值和自己之前找到过的不能重复；右指针也是如此，所以遇到和前一个值相同的就要跳过；
  - 遍历到减3的位置，后面还留两个位置，因为最后一组i, left, right,三个值需要三个位置


- 42. 接雨水【中等偏技巧】： 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
  - 左右指针从左右边界向中间走，记录左右边界中的矮板，当前比矮板矮的就开始盛水，然后移动矮的边界；比原边界高的就替换原边界；
  - 相等时移动一边就好了，不能同时移动， 同时移动就相当于一次走了两步，很可能指针撞到一起就漏掉了一个元素；
  - 因为每次移动1，然后就结算，所以结算只需要： less-height[i]


## 哈希

- 1. 两数之和【简单偏技巧】：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
  - 只需要一遍遍历，哈希表里找到就返回，没找到就存一下（因为两个数，前面找不到，存了之后，后面肯定找的到，比，2,7， 求和为9，跌到到2的时候找不到，把2存了，到7时就找到了）


- 49. 字母异位词分组【简单偏技巧】： 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的所有字母得到的一个新单词。
  - 单词变数组，再排序，再变字符串： arr = Array.from(str)
  - hash表里有就放入，没有就初始化为空数组
  - 收集结果： Object.values(hash)

- - 128. 最长连续序列【中等偏技巧】： 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
  - 使用 Set 存储数组中的元素：这可以在 O(1) 时间内检查一个元素是否存在。
  - 只从连续序列的起点开始扩展序列：遍历数组中的每个数字 num，如果 num-1 不在集合中，说明它是一个序列的起点。从这个起点开始，尝试找到以 num 为起点的最长连续序列。

## 技巧（取巧）：需要背诵技巧思路


- 169. 多数元素【简单】： 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
  - 先排个序，然后取其第 n/2 个

- 31. 下一个排列【*中等偏难*】： 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列
  - 有一个前提假设： 数组从后往前到某一个值为止都是升序排列的
    - 1. 找到第一个从后往前违反升序排列的值n，位置为i （找到可以变大起始的位置）
    - 2. 然后用后面大区里比n大，又尽量小的值，和n交换 （变大但是要变的尽量小）
    - 3. 逆序i后面的值 （高位处理完后，把地位也尽量变小）
      - 注意（易错点）：i后面的值，无论是否交换过都是递增的，可以直接逆序




## 未做的困难题

排除的题型： 

- 295.数据流的中位数：困难
  - 原因： 堆数据操作复杂，而且场景离前端较远，属于比较偏的考点，而且还是困难，遇上了多半是故意为难，就算了

- 4. 寻找两个正序数组的中位数
  - 原因：如果用答案解，各种条件处理起来比较麻烦，思路也比较难想，题解看半天，看不明白；如果遇到了就用归并排序，然后直接找中位数，过不了就算了；



## 做题记录

9.6 过完一遍；

10.4 挑战 重刷100题，5天, 实际到10.20才刷完花了两周时间；
  - 10.5 14题， 做到堆： 前 K 个高频元素
  - 10.8 8题， 做到二分查找，34. 在排序数组中查找元素的第一个和最后一个位置
  - 10.9 13题，做到 208. 实现 Trie (前缀树)
  - 10.10 11题，做到 114. 二叉树展开为链表
  - 10.11 0题，开合约而且亏损，影响
  - 10.12 3题，做到 124. 二叉树中的最大路径和（开合约影响）
  - 10.17 11题，做到41. 缺失的第一个正数，只剩13题了，明天不开合约专心搞能搞定；

- 10.4 这一遍重点麻烦一些的题型：
  - 滑动窗口：
    - 76. 最小覆盖子串
    - 438. 找到字符串中所有字母异位词
  - 链表：
    - 146. LRU 缓存

下一次刷题，就是下一次找工作的时候把，满状态能一周刷完，状态一般至少得两周；

我的全力投入一件事的状态最多不超过两个月，一般是一个半月左右，后面就状态一般了，断断续续的只能维持两周好的状态。所以要做一件事就得一鼓作气，一个月内搞定它。后面再延长时间，收益不大；

- 11.5 没啥面试，再次刷一遍题，不过这一次不用急，只需要把错题，重点题刷一遍，从前往后刷，随缘刷，不强求刷完：
  - 1. 滑动窗口一共5题: done
  - 2. 上次刷题错题，再做一遍，先处理除了链表和动态规划之外的
  - 这一边忘记思路的，或者做起来觉得困难的
    - 41. 缺失的第一个正数
    - 437. 路径总和 III： 保持父子顺序比较难理解
    - 131. 分割回文串
  - 3. 11.20 除了 链表和动态规划，其余的都刷完了，没想到这么久，用了15天，不可思议； 这段时间似乎也没做啥别的事，效率低的不可思议；后面开始背诵吧，链表和动态，有时间就刷刷，没时间算了；


- 31. 下一个排列
  - 细节易错： 注意（易错点）：i后面的值(i是第一个违反从尾部开始递增的位置)，无论是否交换过都是递增的，可以直接逆序

- 编辑距离
  - dp[i][j] 表示word1前i个 到 word前j个是长度，并且有0个 到 0个，所以需要多初始化一个位置；并且fill 如果填充对象则填充的是索引，这个要注意fill函数的用法；
  - i， j 表示长度，当用他们表示索引时需要-1

  - 5. 最长回文子串
    - 判断是否是回文不能越界，越界了可能两边都是undefined了，也会相等，可能就无限循环了；

  - 64. 最小路径和
    - 递推公式粗心写错，想当然的没有思考： Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]）
    - 并且也导致了初始化出错： 路径和应该是之前值+上当前值， 而不能直接等于之前值；

  - 32. 最长有效括号
    - 方法理解错了，应该是：
      - 从左看：右括号多了则无效，归零，重新计数； 左括号多，则可能有效，继续往后找；
      - 相等时结算一次，和max比较


  - 416. 分割等和子集
    - 注意比较时， i-cur 必须为正数，也就是i>=cur, 否则，结果就是unfined了；
  

  - 152. 乘积最大子数组: 思路不清楚，磕磕绊绊作出
    - 记录到每一个为止的最大值和最小值，比较的是: dp1[i-1] * nums[i], dp2[i-1]*nums[i], nums[i]
      - 比较对象容易弄错

  - 300. 最长递增子序列
    - 忘记了： 左动态规划要注意，尤其是求最大最小的时，一个位置可能被反复填充，所以需要和自己先比较一下
      - 比前面两个数都大的情况下，比如 5,3,7; 7的位置就会更新两次；


  -  139. 单词拆分
     -  疑问： dp[0] 表示空字符，而i,j 为0是并不是空字符，而是索引为1 的字符，如何处理这种差异呢？
      - 因为初始化有长度+1 表示空字符串，所以外层i用dp.length 做遍历把dp表填满，就行了；
      -  内层表示每一个值得起始索引位置，需要到0, 表示索引，依次查看从0到i-1的位置能否被组成; 那么word.slice(i,j) 正好截取一个字符串，dp[j]表示前j个字符


  - 215. 数组中的第K个最大元素: 因为题目没有保证答案唯一，所以需要考虑重复元素的情况，以及数据极端情况，需要完整版快排双指针思路
    - 错误点：
      - 1. 需要倒序排（从大到小）, 因为求第k大;
      - 2. 随机索引取法？第一版基准值可以取右边界，这个简单些，少写两行代码，如果要求更高，再取随机索引,一般不需要；
        - 左闭右闭区间里取随机索引： l + Math.random() * (r-l+1) =>  Math.floor(l + Math.random() * (r-l+1))
      - 3. quicksort, 快排每一次处理范围的左右边界，是一个左闭右闭区间[left, right]。
      - 4. partition的返回的左右边界的*left-1 和 right*, right不需要-1，因为最后基准值会换到right这个位置，right就会变成等于区的右边界,要注意
      - 4. 在缩小分区的范围的时候， l+1, r-1, 也是重要的，这是逐步缩小范围的关键，否则直接用r,l, 可能会出现死循环
      - 5. l>=r 时返回，排完后在数组中取元素就像行了。
    - done;

  - 347. 前 K 个高频元素： 因为题目保证了，*数据答案唯一，所以不用考虑重复元素，用快排简化版，用单指针left指针就行了,不需要right，会简单很多*，不要又要统计频率，又要随机索引，细节都，容易出错。。
    - 右扩左边界后，i依然需要继续++，往后遍历不能不动
    - 取对象key,val 数组的方法忘了，是： Object.entries()；
    - done


  - 394. 字符串解码
    - 忘了：正则 \d 才是 数字，而不是 d
    - 忘了：字符串重复用repeat() 方法，而不是 *
    - 忘了： 数字和字符串相加，结果是字符串, 要注意；
    - done;

  - 84. 柱状图中最大的矩形
      - 不需要单独处理柱子相等的情况，相等也入栈，只是多算几次，并不影响最终结果；
      - 如果把相等的柱子跳过了，可能出错:
        - 举例： 如果有多个1的，情况下，导致本应成为分界点（左边界）的第二个1，无法入栈从而造成错误；
      - *数组前后放入0，作为最终的左右边界，便于最后清算所有。*
      - done

  - 35. 搜索插入位置： 二分查找
    - 值应该在left和right之间，left和right本不应该相等；当left 和 right相等时还没找到，那结果就取left（也就是比正常极限left大1的位置）;
    - done;


  - 33. 搜索旋转排序数组
    - 先找极值，然后二分:
      - 理解找峰值min的关键：因为轮转数组是一个二段升序数组，所以 min是在第二段， 找min的整体过程是，一个右边right向中值靠拢（right可以等于mid），左边left向右边靠拢的过程(left = mid+1)；
    - done 
      


  - 78. 子集
    - 下一个起始位置不是：startIndex + 1, 而是当前遍历到的位置 i+1， 才当前结束的位置往后看；
    - done;



  - 79. 单词搜索
   - 找到单词的条件是：单词的所有字母已经找完，没有被提前终止，说明找到了最后, 只要能找到最后的索引位置，说明就是应该返回true
   - dfs 时区分叶子结点返回结果，和dfs 函数总的返回结果
     - 叶子结点返回结果再dfs 函数开始部分，是分支终止条件； 终止分支如果返回结果，结果会返回到上一层；
     - 总得结果在dfs 函数结束部分，是总的返回结果，同时也是每一层的结果；
   - done



  - 131. 分割回文串
    - 结束条件是什么呢？
      - start === s.length， 开始位置到末尾就可以结束了
    - 在什么时候把不是回文的过滤掉；在结尾么，还是过程中？
      - 关键在截取的字符串: *每一次处理时，不是选一个字符进入路径，而是通过遍历过程中累加，选一个或者一组字符，直到可以是回文的才进入路径里收集*
    - done;


  - 51. N 皇后
    - path在中间回溯后，最后放入结果res数组里，path也需要解除引用放入，否则，path引用最后回溯，会始终是空;
      - 或者path中间不用回溯+push&pop, 直接用concat 拼，就是一个新的引用，就没有这些问题了；
    - done;

  - 994. 腐烂的橘子
    - 别忘了对遍历过的，腐烂的橘子染色，避免往回重复寻找，形成死循环
    - 对于二维表格，变量能结构出来就解构出来用，避免这种写法：grid[cur[0]][cur[1]]，层级过多，容易写错, 应该把cur解构解构，再用grid[row][col]
    - done

  - 208. 实现 Trie (前缀树)
    - 代码怎么组织， search 和  startsWith 有一定相关性，怎么复用抽离？代码需要最后的node节点做辅助，但是题目需要布尔值返回；
      - 共性就是： 都要找到最后一个节点node，看有没有节点， 有就是前缀， 有并且用结束边界就是单词；
    - 在search 返回时，要求返回的是布尔值，因此：
      - 不能写成： node && !!node.isEnd，  这样node， 为null时返回的就是null了，不是布尔值；
      - 应该写成： !!node && !!node.isEnd  或者  node !== null && node.isEnd
    - *abc 字符串 的前缀包括 abc本身*
    - done;

  - 94. 二叉树的中序遍历: 左边界依次入栈
    - 循环条件是：stack 有长度，或者 left存在
    - 一开始栈里不需要放节点, left = root; 然后把左边界依次入栈； 如果放了，容易放两遍root;
      - 迭代： 有left节点就放入，而不是由left.left才放入，否则会有缺漏
    - done;



  - 101. 对称二叉树
    - 镜像： 开始传入两个相同节点，left和right都为root （也可以直接传入root的left，和right）； 然后用left.right 和 right.left; left.left 和 right.right 去比较；
    - done
    


  - 543. 二叉树的直径
    - 树高是一个dfs，直径也是dfs，两个能融合成一个dfs么，还是得分开写？
      - 融合写，关键在于理解递归的返回：当前层递归的值，不仅可以在当前层算出了，还可以通过下一层返回回来；
        - 开始的返回是叶子结点的返回
        - 结束的返回是除叶子结点外每一个节点的返回，也包括根节点
      - 要区分直径，边数和节点数的区别，边数别节点数少1， 可以先按节点数算，算出来的结果再减1；
      - done

  - 230. 二叉搜索树中第 K 小的元素
    - 理解题意，第一小就是：从小到大排列，第一个元素；以此类推；
    - done;


  - 114. 二叉树展开为链表
    - 先记下root的左右树；然后找到左树的最右节点，把右树放在其右边；然后把左树放在root的右边；
    - 易错点：找到左树的最右节点
      - 二叉树节点向一个方向迭代时，while里的判断条件是什么，如果是right那么到最后跳出，right为空，如果是right.right 那么第一个right可能为空
      - *根本原因是right 这个初始值可能为null, 那么从不为null 的开始迭代，right从root开始迭代寻找，root已经判空过；*
      - done


  - 105. 从前序与中序遍历序列构造二叉树
    - 对于递归参数是算出来的，怎么处理呢？ 如果这个计算逻辑放在递归内，那么第一次调用怎么传参呢？
      - 实际第一次： 初始值先序和中序的数组都是同一个，是一样的， 参数可以一眼看出来；
    - 参数所有的加 与 减， 索引相减得到的是什么？
      - 是相差,个数，保持索引差就行；
    -  节点数量容易想错， 数量应该是： inorderIndex - inorderStart， inorderIndex为找到的中序数组里的先序头节点位置，index为头节点的位置所以 index-start 为size 而不需要加1，因为left数组不包括这个头节点，实际计算可以是index-1-start+1;
    -  done


  - 437. 路径总和 III
    - 先求和计数，再更新前缀和的映射表，避免污染映射表后，计数错误；
      - 比如 targetSum 为0 时，如果后计数，就会出错；
    - 怎么保证路径方向向下？处理完左右节点，回溯的时候把它在hash里减掉,就能保证向下了；
      - 重点在于回溯。比如处理cur的左右子树时， 处理完左右子树时会回溯的。 同样对于其left分支，当left分支的左右子树处理完后，也是会回溯的饿，会恢复处理left时，hash的状态； 所以当开始处理右子树时，也不会被左子树影响；
    - done;




  - 236. 二叉树的最近公共祖先
    - 递归，逻辑怎么写呢？
      - 依照左右分支递归，那么如果 一个是另一个的子节点，那就处理不了了啊；
        - 如果当前节点满足条件，那么在递的过程中就返回，不需要到归过程再收集；
    - 思路及过程，还是有点难度的，不是很好想：
      - 如果根节点为空，或者找到了p或q，则返回该节点
      - 如果左子树和右子树都找到了p或q，说明当前节点是最近公共祖先
      - 如果只在左子树或右子树找到，则返回找到的那个节点
        - 说明，一个是另一个的祖先，返回先找到的那个子树即可
      - done


  - 124. 二叉树中的最大路径和
    - 因为要求的是最大值，算出左右左树的最大贡献值需要和0比较，如果是负值就不要，取0就好。
  - done

  - 160. 相交链表
    - 代码的简洁写法： 
      - 当A不等于B时继续循环,等于时跳出；
      - 等于null的时候，说明到了结尾，换到另一个的头
      - 判断当前节点为null时才交换，而不是判断next;

  - 141. 环形链表
    - 判断条件是什么呢？
      - 不加?.符号的情况下， 如何避免 fast.next.next; 各种需要判断next为空的情况；
        - 循环判断条件是：fast && fast.next， 然后再循环里如果 slow === fast 则说明相遇，快指针走完还没有相遇，则说明无环；
        - 首先把没有节点，或者只有一个节点的排除掉
        - 在循环里面，走完再判断，避免第一个节点相同的情况不好处理


  - 138. 随机链表的复制
    - 注意做map的时候，是旧链表的节点为key, 新链表的节点为值，这样才能利用旧链表的节点，找到新链表；



- 54. 螺旋矩阵
  - 命名尽量语义化，避免加减的时候方向搞反了。上面的是bottom, 下面的是top;
  - bottom <= 等于top，进入循环， 可以等于，以便于处理一行的情况； left和right也同理；
    - 但也因为这个条件，在循环里剩下最后一行，一列时，可能会出现重复遍历的情况，所以再循环里，也要做边界判断；
    每次加减后，如果越界就跳出循环；
    - *一旦在循环内部发现越界，立即终止循环，而不是继续判断处理，否则就可能多放；*
  - done

- 56. 合并区间【2】
  - 需要一个结果数组res, 如果结果数组为空，或者当前区间和最后一个区间不重叠, 直接放入结果数组
  - 否则，合并当前区间到结果数组最后一个区间
  - 区间的结尾时，两个合并区间结尾中，取最大值；
  - done

- 238. 除自身以外数组的乘积
  - 求前缀积时怎么求呢？
    - 第一遍遍历求前缀积，res数组里填前缀积， pre记录当前缀积结果
    - 第二遍遍历求前缀积*后缀积，suf记录当前后缀积结果
    - done

- 41. 缺失的第一个正数
  - 忘记思路【2次】： 正数是一个隐藏条件，意味着隐藏着和索引有关的顺序，把每一个值放在val-1的位置，也就是他应该在的索引位置，用遍历和交换元素位置去排序，而不用正常的排序，就会是o(n)的
  - 但是把元素按索引放置在正确的位置，（1 应该在 索引0 位置， 因为是正数，从1开始排），会不能用额外数组的情况下，会出现覆盖的情况，怎么处理呢？
    - *通过while循环交换，直到先把当前位置元素，都放到正确的位置，或者当前位置元素越界*；
    - 注意nums[i] 应该放在nums[i]-1的位置上
    - 要注意判断索引不能越界，而且两个交换的数不能相等： nums[i]-1,不能越界 应该 在0到nums.length-1之间
    - 没找到的数，那就是在length+1 的位置；
  - *在 解构赋值 中，右边的值会先被计算出来，而计算的顺序是 无序的，它们会先全部计算完，然后按 左边的顺序 依次赋值给左边的变量*
    -  记忆（目标优先）： 交换 nums[i] 和 nums[nums[i] - 1]，应该 目标位置先，当前元素后。也就是左边顺序是：nums先[nums[i] - 1] 再 nums[i]; 
 - done;


- 239. 滑动窗口最大值
  - 怎么维护队列容易忘记
    - 如果每次只放大的，那么前面的如果过期了就出问题了，就没有候补的。所以应该是小的直接放进去，大的挑掉小的做更新，队头永远是最大的；
    - 滑动窗口初始左右边界怎么处理，特别是右边界；
      - 初始都为0， 右边界到位置开始处理
    - done


- 283. 移动零
    - 怎么保证相对顺序不变呢，一次快排除了基准值能保证相对顺序么
      - 从左边开始先处理左边的值，相对顺序就不会变化，不是零的换到0的左边；本质是从左边开始扫描，不是0的往左移，然后扩展左边界吞掉
    - done;

- 15. 三数之和
  - 思路混乱：关键是这个区间的数组重复怎么处理；
    - 遍历：固定一个i位置的数，然后从i+1 到 length-1的位置去排查
    - 关键点： 排查范围，循环条件是： left<right
      - 相加等于0时，也就是找到一组时，需要跳过重复的数，便于寻找下一组,使用while连续跳过, 相等时，左指针相等时left++, 右指针相等时right--， 直到不相等，或者越界; 内部跳过，不需要用continue,容易迷惑；
  - 有负数，排序必须自定义，不然排出来是不对的，用：nums.sort((a,b)=>a-b)
  - 易错点：
    - 需要到：nums.length-2，最后面留两个位置；
  - done
       

- 42. 接雨水
  - 确定了左右边界，怎么表示盛水呢，还需要一个变量么？
    - 需要两个，要记录左右边界的最大高度leftMax 和 rightMax，如果新边界的大于最大的高度，*要更新边界高度*；
      - 有四个关键变量：leftMax 和 rightMax 才作为边界高度计算，算两个边界的最小高度；而left,right只是作为指针移动；
    - done
  
- 49. 字母异位词分组
  - 忘了，字符串排序是咋排的呢？
    - 先变成数组在排序吧，排序是数组方法；
  - done

- 3. 无重复字符的最长子串
  - 怎么处理重复的这个过程呢？ 遇到的字符记到hash中标记为true，如果下次再遇到呢;
  - 或者不用hash,用数组存储？
    - 不用hash存, *用set存*，有一个好处，set本身是不重复的，可以直接删除元素，无需判断是否相等；
    - 0. 循环条件为，右指针没有超过边界；
    - 1. 满足条件，更新结果。 并移动右指针扩大窗口，收集里加入right对应元素；
    - 2. 不满足条件，移动左左指针,缩小窗口,移除left对应元素
      - 移除left对应元素，不是移除重复元素，直到不重复，right继续走；
  - done
  

- 76. 最小覆盖子串: 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。
- 此题大脑有点超负荷：需要反复消化
  - 如何判断覆盖？
    - 每一个需要的字符次数都找满（满足要求的字符种类的数量），或者超过。但是只在找满的时候计数；
      - 找满后，找满的计数count 不一定等于 t.length, 因为可能t有重复的字符，length就会比count大；
      - 找满的条件为： t的词频， Object.keys(tMap).length, 做判断；
        - 注意这是不是滑动窗口的hash 键数，而是所需要覆盖的字符串的hash键数，容易混；
    - 两层while比较好处理；
    - 小疑问： hash里计数为0了，他的key并不会消除啊，hash 的length 也不会变啊；
      - 实际不用管这个，只需要判断left移动后，此位置的值是否还是满状态的就行；
  - done

- 146. LRU 缓存
  - 双向链表+hash存储
  - get获取时，有可能不存在，需要判断
  - 删除头节点，容易出错：
    - 最后先将head.next.next 记录下来，然后改指针；
      - 不然的话，如果先改： this.head.next = this.head.next.next;， 那么this.head.next就已经发生变化了，已经指向的是this.head.next.next了，一不小心就容易出错；
  - 只需要一个把当前节点移动到末尾的辅助函数；
  - 链表：跳
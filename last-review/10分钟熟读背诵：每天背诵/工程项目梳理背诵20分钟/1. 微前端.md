# 1. 微前端

面试中问微前端的话，可以说：

- 原理（隔离原理）
- 加载过程
- 和同类横向比较；
- qiankun 的具体落地问题处理
- 业务落地的架构设计实践

## 好处

- 跨团队或跨部门协作开发项目导致效率低下的问题: 解决不同团队，不同技术栈的协同开发问题，不同的子应用可以交给不同的团队（不同技术栈）来管理

- 随着项目迭代应用越来越庞大，难以维护: 大应用拆分问题，随着应用越来越大，项目体积越来越大，打包部署越来越慢， 技术升级或者重构相当麻烦, 维护也越来越困难,将应用拆分，每个应用独立运行，独立部署，还可以随意组合，这样就更加灵活;


qiankun 2.0 带来的最大变化便是 qiankun 的定位将由 微前端框架 转变为 微应用加载器。


比较适合性能不敏感场景，管理后台场景；

项目目前这块主要说：

1. 微前端： 大概原理，（需要时可以说：加载过程，本地拉基座），和同类横向比较
2. 性能优化： 项目的衡量标准，横向对比业界工具
3. 多环境： 实施方案，横向对比业界方案
4. 测试环境自动化部署


难点这一块主要说：
- 1. 测试环境 【突出工程功能】
 - 1. 大公司：测试多环境的产生背景
 - 2. 小公司：无基础检查的测试环境自动化部署
- 2. 做一个node的搬运爬虫，异步请求池  【突出思维能力】



### 微前端：

- singleSpa
  - 实现了路由劫持和应用加载
    - 当url路径匹配上子应用，会请求子应用的包，加载子应用到script标签里
    - 子应用运行，在window 上挂上协议对象，bootstrap, mount ,unmount,调用子应用的mount方法，把子应用的dom挂在父应用指定元素下
  - 缺点： 
    - 本身没有隔离机制： 需要开发者自己处理，比如用 CSS Modules， js模块作用域等
    - 加载资源麻烦：不够灵活，不能动态加载子应用js文件，需要手动引入


- qiankun 
  - qiankun 基于Single-spa, 主要完善了：
    - 1. 简化资源加载： 子应用资源由 js 列表修改进为一个url(利用qiankun 内部包import-html-entry 加载资源)，大大减轻注册子应用的复杂度 
    - 2. 实现应用隔离：完成js隔离方案和css隔离方案 
    - 3. 增加资源预加载能力： 预先子应用html、js、css资源缓存下来，加快子应用的打开速速
  - qiankun 加载子应用流程
    - 1. 先注册子应用（可开启预加载）：这里可以配置预加载参数*prefetch*，开启预加载策略，当前匹配的应用加载完毕后，在浏览器空闲的时候再去加载其他子应用，用的是requestIdleCallback, 也就是每一帧的空闲时间
    - 2. 当url路径匹配后开始加载资源: 首先拉取入口html文件，解析拿到tmplate模版（*html里会把所有的script脚本， link样式都注释掉*），script脚本和style样式表 
    - 3. 对子应用模版进行一些处理：*head标签要换一个名，比如qiankun-head， 创建一个div， 把请求回来的模版（html）放到div里（指定的 container 中）*
      - div 里 可以包html， 只不过在展示是，html 会自动把内存html和head标签去掉, 所以可以改下head标签名，把head标签留下来
    - 4. 然后把js放到沙箱里执行
      - 主要的技术手段包括 with 语句和 new Function 构造函数
      - with 语句可以将一个`对象添加到作用域链的顶部`，从而可以在不修改原始代码的情况下，将代码执行上下文切换到指定的对象。使用 with 语句将 window 对象替换为代理对象，然后使用 new Function 在这个新的执行上下文中运行子应用的代码。
      - ```
      const windowProxy = new Proxy(window, traps);

      with(windowProxy) {
        // 应用代码，通过 with 确保所有的全局变量的操作实际都是在操作 qiankun 提供的代理对象
        ${appCode}  
      }

      ```
  - qiankun核心原理
    - js隔离： 单实例：同一时间只会渲染一个微应用；多实例： 同一时间可以渲染多个微应用
      - js沙箱机制主要包括两种：快照沙箱和Proxy 沙箱。
        - 1. SnapshotSandbox 快照沙箱（在旧版浏览器中使用）：（单实例） 原理是切换时， 做所有属性的 Diff，把区别保存起来
          - 进入沙箱： 
            - 记录当前 window 对象的快照
            - 将之前保存的沙箱状态（上次的 window 修改）恢复到当前的 window 对象上
          - 离开沙箱： 
            - 当微应用被停用时，沙箱会再次保存当前 window 对象的状态
            - 这个时候，SnapshotSandbox 会对比当前的 window 对象和最初进入沙箱时保存的快照，找出两者之间的差异，并保存。
        - 2. Proxy 沙箱 (Proxy Sandbox)（单实例和多实例）： 使用现代浏览器支持的 Proxy 对象实现，适用于大多数现代浏览器。
          - 把*浏览器的原生属性都复制到一个空对象fakeWindow上*，这样对于每个沙箱环境都会有一个相对干净的浏览器环境了，给每个子应用分配一个fakeWindow， 通过 Proxy 代理fakeWindow，拦截对全局对象的访问和修改
    - css 隔离
      - 1. 默认模式： 动态样式表样式隔离
        - 此时， qiankun可以*确保单实例场景子应用之间的样式隔离*，但是*无法确保主应用跟子应用、或者多实例场景的子应用样式隔离*。
          - *dynamic stylesheet 动态样式表，当应用切换时移除老应用样式，添加新应用样式*，这样子应用之间不会污染，但是在同一个文档流中，子应用样式会污染主应用
          - 这时需要自己有一些处理，主要是加上样式前缀，有两种方式：
            -  1. 严格使用css module ，子应用自己去解决（全靠组员自觉了）
            -  2. 给子应用的所有样式添加一个前缀， 配置修改webpack打包时硬性给每个样式加上前缀
      - 2. 严格模式： shadow dom样式隔离
        - 基于 ShadowDOM 的严格样式隔离，会有一些兼容问题
          - 子应用的弹窗、抽屉、popover*因找不到主应用的body会丢失*，或跑到整个屏幕外
          - iconfont字体是不能放在shadowdom 里加载的
      - 3. 实验模式：添加前缀样式隔离， 其实就是官方帮你添加样式前缀，官方来做1的动作
        - 当 实验模式 被设置为 true 时，qiankun 会改写子应用所添加的样式，为所有样式规则增加一个特殊的选择器规则来限定其影响范围
    - 可能遇到问题及处理：
      - ui库污染的问题，解决方案：
        - 1. ui库在主应用统一cdn引入，统一版本
          - 将 UI 库在主应用中通过 CDN 引入，并在子应用中不重复引入，是一种常见的优化方式。这种方式可以减少子应用的打包体积和加载时间，同时避免样式冲突问题
        - 2. 修改主应用ui库的前缀，针对ui库配置打包工具，修改其前缀，有的ui库提供了相关的修改方法， 例如*如果ui库是antd,可以用@ant-prefix*
      - 子应用（antd）弹窗、抽屉等 因为Shadow Dom或者 加了样式前缀隔离 导致的样式错乱的问题
        - 因为此时，这些弹窗一般是要插入到body里的，是需要应用全局样式的；而隔离造成了他们不能正确的获取全局样式；
          - 1. 可以限定这些弹窗的挂载点在，容器内，而不是全局body
            - 比如对于antd, 可以全局配置ConfigProvider 的getPopupContainer 属性
          - 2. 把相应样式放到基座中，这样及时弹窗挂载到body中，也会有对应样式；
      - 通讯方式：
        - 1. 基于props主子应用间通信： 
              - 在一些简单场景下，基于 props 的方案会更直接便捷
        - 2. GloabalState （事件机制）
            - 1. 主应用创建共享状态initGloabalState： initGloabalState({ user: 'kuitos' });
              - initGloabalState定义全局状态，并返回通信方法， 一般在主应用使用
                - 通信方法： onGlobalStateChange（订阅监听）， setGlobalState（派发修改）， offGlobalStateChange（移除监听）
              - 微应用通过 props 获取通信方法。
            - 2. 微应用通过 props 获取共享状态并监听： 
            ```
              // 从生命周期 mount 中获取通信方法
              export function mount(props) {
                props.onGlobalStateChange((state, prevState) => {
                  // state: 变更后的状态; prev 变更前的状态
                  console.log(state, prevState);
                });

                props.setGlobalState(state);
              };
            ```
        - 3. 通过全局存储通信
            - localStorage/sessionStorage， 适合一些全局共享的信息   
    - 对于公共依赖的处理方式：
      - CDN 引入- 搭配webpack 的 externals
        - 主应用中引入相关cdn包
        - 子应用中需要配置webpack的externals
        - 保证子项目的独立运行：子应用同样引入相关cdn包，通过*给子项目的index.html中的公共依赖的script和link标签添加自定义属性ignore来实现*。在qiankun运行子项目时，qiankun会忽略这些带有ignore属性的依赖，子项目独立运行时仍然可以加载这些依赖。
      - webpack5 的联邦模块 

    - qiankun相关依赖问题处理：
      - 1. qiankun 如何实现 keep-alive 的需求吗
        - 可以手动*loadMicroApp+display:none，直接隐藏Dom*, 当然这样应用多了会卡顿，可以限制一下
      - 2. 在使用 qiankun 时，你如何处理多个子项目的调试问题
        - 本地基座拉取应用：每个子项目都可以在本地启动，并通过修改主应用的配置，让主应用去加载本地正在运行的子应用，这样就可以对子应用进行调试了。这种方式的好处是，子应用与主应用解耦，可以独立进行开发和调试，不会相互影响。
        - 本地子应用拉取基座：




### 说说现有的几种微前端框架，它们的优缺点？

前置知识：

  webcomponent 的 shadow DOM： shadowRoot是shadow DOM， 相当于一个阉割的 document，但它只有独立的 css 作用域而没有独立的 js 作用域，内部元素的样式在未单独做修饰的情况向，就是浏览器默认样式，完全不受外部样式的影响。shadowRoot 与 document 访问到的是同一个 window 对象。


 - 0. iframe

  优点：
  - 非常简单，使用没有任何心智负担
  - web应用隔离的非常完美，无论是js、css、dom都完全隔离开来

  缺点：由于其隔离的太完美导致缺点也非常明显
  - 路由状态丢失，刷新一下，iframe的url状态就丢失了
  - dom割裂严重，弹窗只能在iframe内部展示，无法覆盖全局
  - web应用之间通信非常困难
  - 每次打开白屏时间太长，对于SPA 应用来说无法接受


- 1. qiankun

  总结： 
  - 优点：生态比较成熟， 经过大量项目实践，可参考案例多
  - 缺点： 不支持vite, 不支持子应用保活， css 沙箱无法绝对的隔离
  
  qiankun是基于single-spa的， single-spa主要实现思路：

  - 预先注册子应用(激活路由、子应用资源、生命周期函数)
  - 路由拦截：监听路由的变化，匹配到了激活的路由则加载子应用资源，顺序调用生命周期函数（bootstrap、mount、unmount）并最终渲染到容器

  乾坤微前端架构则进一步对single-spa方案进行完善，主要的完善点：

  - 子应用资源由 js 列表修改进为一个url，大大减轻注册子应用的复杂度
  - 实现应用隔离，完成js隔离方案 （window工厂） 和css隔离方案 （类vue的scoped）
  - 增加资源预加载能力，预先子应用html、js、css资源缓存下来，加快子应用的打开速度


- 2. 无界方案
  优点：
  - 基于 webcomponent 容器（css隔离）和 iframe 沙箱（js隔离），充分解决了适配成本、*样式隔离*、运行性能、页面白屏(预加载，requestIdleCallback)、子应用通信、、多应用激活、*子应用保活*、*vite框架支持*、应用共享等问题。

  
  底层原理： 
  - 1. js沙箱（隔离）： *将子应用的js注入主应用同域的iframe中运行，iframe是一个原生的window沙箱，内部有完整的history和location接口，子应用实例instance运行在iframe中，路由也彻底和主应用解耦，可以直接在业务组件里面启动应用。*
    - 好处： 
      - 组件方式来使用微前端，不用注册，不用改造路由，直接使用无界组件，化繁为简
      - 一个页面可以同时激活多个子应用， 子应用采用 iframe 的路由，不用关心路由占用的问题
      - 天然 js 沙箱，不会污染主应用环境， 不用修改主应用window任何属性，只在iframe内部进行修改
  - 2. iframe 连接机制和 css 沙箱机制： 
    - 无界采用webcomponent来实现页面的样式隔离，无界会创建一个wujie自定义元素，然后将子应用的完整结构渲染在内部；（天然 css 沙箱， 天然适配弹窗问题）
    - 子应用的实例instance在iframe内运行，dom在主应用容器下的webcomponent内，通过代理 iframe的document到webcomponent，可以实现两者的互联。(dom不在iframe里)
  - 3. 子应用保活：
    - 当子应用发生切换，iframe保留下来，子应用的容器可能销毁，但webcomponent依然可以选择保留，这样等应用切换回来将webcomponent再挂载回容器上，子应用可以获得类似vue的keep-alive的能力.
  - 4. 路由同步机制： （避免刷新时，iframe的路由状态丢失）
    - 路由同步会将子应用路径的path+query+hash通过window.encodeURIComponent编码后挂载在主应用url的查询参数上，其中key值为子应用的 name。
      - 原理:劫持iframe的history.pushState和history.replaceState，就可以将子应用的url同步到主应用的query参数上，当刷新浏览器初始化iframe时，读回子应用的url并使用iframe的history.replaceState进行同步
  - 5. 通信机制： 承载子应用的iframe和主应用是同域的，所以主、子应用天然就可以很好的进行通信，在无界我们提供三种通信方式
    - props 注入机制， 子应用通过$wujie.props可以轻松拿到主应用注入的数据
    - window.parent 通信机制，子应用iframe沙箱和主应用同源，子应用可以直接通过window.parent和主应用通信
      - 主应用调用子应用的全局数据: `window.document.querySelector("iframe[name=子应用id]").contentWindow.xxx`
      - 子应用调用主应用的全局数据: window.parent.xxx;
    - 去中心化的通信机制： 无界提供了EventBusu 这种去中心化的通信方案
      - 可以通过 事件绑定，发射，来通信

  
  使用shadow Dom 隔离css, 使用空的iframe隔离js， 通讯使用的是proxy



- 3. micro-app 方案（京东）

  总结： 
  - 优点： 使用简单，子应用改动少
  - 缺点： 没有经过大量项目实践


  优点：
  - 使用 webcomponent 加载子应用,相比qiankun 注册监听的方式更优雅，简单一些；
  - 复用经过大量项目验证过的 qiankun 沙箱机制，提高了框架的可靠性；
  - 支持子应用保活；
  - 降低了子应用改造的成本，提供了静态资源预加载能力。

  缺点：
  - css 沙箱无法完全隔离，js 沙箱做全局变量查找缓存，性能有所优化；
  - 支持 vite 运行，但必须使用自定义插件 plugin （插件）改造子应用，适配成本高(用vite,不建议使用micro-app)
  - 对于不支持 webcomponent 的浏览器没有做降级处理。


micro-app并没有沿袭single-spa的思路，而是借鉴了WebComponent的思想，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件，从而实现微前端的组件化渲染。并且由于自定义ShadowDom的隔离特性，micro-app不需要像single-spa和qiankun一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置，是目前市面上接入微前端成本最低的方案。

- 4. emp 模块联邦方案 （百度）

emp方案是基于webpack5的module federation(模块联邦)， 必须使用webpack5,强耦合；

一句话总结：与 webpack5强耦合， 没有沙箱， 可能跟适合组件共享

特点：

- webpack 联邦模块编译可以保证所有子应用依赖解耦
- 应用间去中心化调用、共享模块
- 模块远程ts支持

缺点：
- 对webpack强依赖，老旧项目不友好
- 没有有效的css沙箱，js沙箱， 需要靠用户自觉
- 没有子应用宝活， 多应用激活
- 主，子应用可能发生路由冲突


我理解这个项目主要说的点：

- 0. 项目解决的问题，项目的核心方案
  - 1. 开发测试完成后，选择在版本中心配置一些有灰度的仓， 选择灰度发布，会拉取对应分支代码，打包资源，生成一个资源版本的包，把这个包传到cdn上，会返回资源地址，生成一个版本号存到数据库；
  - 这样就建立么，白名单仓，版本号，资源地址一一对应的关系；
  - 兜里方案，如果版本中心挂掉，则请求对应路径下default目录下的文件（每次上线会拷贝一份资源到同级的default目录下）
  - 问题：
    - 部署： 为什么不用原有的流水线部署，而用webpack插件
      - 因为部署成功后，需要把对应的资源地址存到数据库里，而原有流水线没有这个功能，如果要做就需要其他部门配合改造，动作会比较大；

- 1. 在于后端的开发流程：
  - 库表的设计原则
    - 数据库范式
    - 数据关系
  - 项目结构

- 2. 前端灰度部署所有的方式： 
  - 选择灰度发布，会触发对应脚本，和webpack 命令，也触发webpack插件，这个插件的主要作用，一是上传资源，二是和后台数据库做交互
  - 写webpack插件
    - 使用hook: compiler.hooks.emit.tapAsync
  - 字段都传到cdn呢，html也传么？如果不传html放在哪里呢？ 毕竟打包后就是一个html,加一些静态资源？
    - html 传到线上机器
    - 静态资源传到cdn
  - 为什么html 和 静态资源要分开部署
    - html 部署到线上服务器因为html通常不需要缓存，他引用的js，css资源可能是变化的。
    - 其他静态资源传到cdn是为了加速




## 库表的设计原则

基础数据库设计原则

### 数据库范式

1,2,3 范式是包含关系，2范式包含1范式，3范式包含2范式。如果是3范式，那么肯定是2范式，也肯定是1范式；

比如： 对于 一组字段： 学号，姓名，性别，年龄，系名，系主任，课程名，成绩
  - 学号 -> 姓名，性别，年龄，系名
  - 学号 -> 系名 -> 系主任
  - 学号 + 课程名 -> 成绩

- 第一范式（1NF）：原子性，确保每个字段只存储原子值
  - 确保每个字段只能存储单一值，一般都符合原子性；
  - 比如，如果你有一个用户表，其中有一个字段存储电话号码，第一范式要求每一行的电话号码字段只能存储一个电话号码，而不是将多个电话号码放在同一字段中（例如，“1234567890, 0987654321”）
- 第二范式（2NF）：确保每个非主键字段完全依赖于主键，消除部分依赖。例如，如果有一个表存储订单和客户信息，确保客户信息不重复存储在每个订单中。
  - 关键：没有部分依赖
    - 先找主码，能推出行中所有元素的组合就是主码；
    - 一个元素依赖于主码，就是完全依赖；如果有一个元素只依赖于主码中的一部分就是部分依赖；
  - 主码： 学号+ 课程名 能推出其他字段，所以 学号 + 课程名是主码， 但是姓名，性别等只依赖于学号，不依赖课程，所以存在部分依赖
    - 要成为第二范式，就得把课程，成绩拆分出来，同时用学号做联系
- 第三范式（3NF）：确保每个非主键字段直接依赖于主键，消除传递依赖。例如，不要在订单表中存储客户地址，而是引用客户表。
  - 如果一个表中的字段都不依赖于其他非主键字段，那么它就是符合第三范式的。
  - 所谓传递依赖，是指，如果存在A->B->C， A能推出B， B能退出C， 则C传递依赖于A
    - 学号 -> 系名 -> 系主任， 存在传递依赖；要成为第三范式，就得把系名，系主任拆出来，同时用学号做联系；

### 数据关系

一对一：如一个用户只能有一个账号。在设计中，可以在两个表中使用相同的主键。
一对多：如一个用户可以有多个订单。在设计中，订单表可以包含用户ID作为外键。
多对多：如学生和课程关系。通常需要一个中间表，存储学生ID和课程ID。


## webpack 插件

### webpack 阶段

Webpack 的构建过程可以分为几个主要阶段，每个阶段都有相应的钩子


- 1. 初始化阶段
  - 处理配置文件，初始化插件和加载器。
- 2. 解析阶段
  - 在这一阶段，Webpack 解析入口文件及其依赖关系。相关的钩子包括：
    - compilation.hooks.buildModule：当每个模块被构建时触发。
- 3. *构建阶段（emit）*：
  - 在这一阶段，Webpack 将所有模块合并为一个或多个输出文件。相关的钩子包括：
    - emit：在资源被准备输出之前，可以进行修改或处理。
    - afterEmit：在所有资源输出后触发。
- 4. 优化阶段
  - 在这一阶段，Webpack 对资源进行优化，例如压缩和混淆。相关的钩子包括：
    - compilation.hooks.optimizeAssets：在优化资产时调用。
- 5. 输出阶段
  - 将构建结果输出到文件系统。这一阶段的钩子包括：
    - done：整个构建过程结束时触发，适合执行最后的清理或通知操作。
- 6. 监视模式
  - 如果 Webpack 在监视模式下运行，会在源文件变化时重新执行构建。

### 每个阶段的hook

每个阶段都有其对应的hook， 如：

构建阶段（emit）：
- emit：允许你在资源被输出之前修改或处理，通常用 tapAsync 来处理异步任务
  - tap 表示“注册钩子”或“插入处理逻辑”

tapPromise 可以在多个阶段使用。使用 tapPromise 的主要优势在于，它允许你在钩子中返回一个 Promise，而不需要显式的回调函数。它可以用于：
  - 解析阶段（如 buildModule）
  - 构建阶段（如 emit）
  - 优化阶段（如 optimizeAssets）








### 优化专项复述： 性能

- 我主要负责整体方案，与任务分配，以及首屏及公共优化的处理，比如第三方包提取到基座，排查慢接口给后端去优化，然后优化一个子应用做示范演示；
- 其余的按照子应用去分配任务，每个人负责几个子应用的优化；在优化过程中如果，会定期同步进度2,4，各自发现了，新的问题，或者遗漏点回拉会沟通同步；


- 背景: 系统业务转型，有toc 专项 tob, 相关后台管理系统，也由自己内部使用变为需要给合伙人使用
- 我们小组承接了系统优化的相关任务，我作为组长，负责系统优化方案设计与落地，带着三个组员，与其他子应用的对接人，完成了系统的优化;
- 首先，优化任务分为两大块，传统的偏向前端的技术优化，与偏向用户的体验优化;
- 整体的理解前端优化：*Web 性能就是让网站变得更快，以及让缓慢过程看起来更快。*
- 要想走优化，首先就是要找出问题，这些问题来自一下几个方向：
  - 测试同学的反馈
  - 用户的反馈
  - 研发人员自己对于体验与技术的感知
  - light house 的测试
- 整体任务分成了四块：
  - 技术优化方向分为块：
    - 首屏优化
    - 请求与加载的优化 
  - 体验方向分为两大块：
      - 统一交互的方案落地
      - 公共组件的抽离与封装 



#### 优化手段

- 主要分为从前端技术角度的性能优化以及用户角度的体验优化

前端技术优化，主要三个方面： 减少请求体积，请求次数，利用一些加载技术，然后加上代码层面;

  - 1. 体积：对于前端主要是webpack等打包工具能做的一些工作  
    - 1. weppack压缩
      - 静态资源压缩
        - js压缩：terser-webpack-plugin
        - gzip压缩：compression-webpack-plugin， nginx也要配合配置一下
      - gzip大的接口压缩
    - 2. 公共代码提取
      - wepack: optimization.splitChunks, 可配置minChunks
      - 对于微前端项目，还可以将应用之间的公共包，在子应用用externals排除，在基座用cdn引入
    - 3. *按需加载*
      - 按需加载路由：路由组件按需加载（路由组件按需加载：webpackChunkName 配合，动态import）
      - 代码分割按需加载: 配置optimization.splitChunks, 使用代码拆分技术将应用程序分成多个小块，按需加载
      - 大组件按需加载： 通过Vue.js的异步组件、React的React.lazy等
  - 2. *数量*：发送尽量少的请求获取只获取必要的数据 
    - *最小化首屏加载时的数据请求量，只请求必要的数据（非关键资源并仅在需要时加载，或者延时它们的策略）*
    - 请求合并：图片资源小图标考虑雪碧图(CSS Sprites) 配合 background-position 使用。过小的图片可转换为Base64，可在webpack中的url-loader配置
  - 3. 巧妙的加载解析技术：
    - 1. 懒加载： 以合理的顺序加载你的网站资源，以便用户能够更快地开始使用。 
      - 用到的时候才加载，进入用户可视区域再加载（IntersectionObserver）
        - 比如图片加载：越来越多的浏览器支持原生的懒加载，通过给img标签加上loading="lazy来开启懒加载模式。 
      - 路由配置按需加载；(webpack配置)
      - 不紧急的内容加载时机后置
    - 2. 预加载： 在用户继续执行主要任务的同时，任何其他资源都可以在后台继续加载。（requestIdleCallback）
      - 子应用可以预加载；
      - dns预解析， rel="dns-prefetch"
      - preload 作为元素 <link> 的属性 rel 的值，表示用户十分有可能需要在当前浏览中加载目标资源，所以浏览器必须预先获取和缓存对应资源。
- 3. 代码层面
  - 减少重复渲染，key的唯一性
  - useMemo, useCallback与React.memo的合理利用
  - 合理使用React.lazy 进行按需加载组件： 一般可以用户加载比较大的弹窗，tab等，从而减小初始包大小
    - 1. 动态引入函数： `const MyComponent = React.lazy(() => import('./MyComponent'));`(动态引入函数也就是lazy的参数必须返回一个promise, import()返回的就是一个promise)
    - 2. 组件导出: 被动态引入的组件文件（./MyComponent）必须以默认导出（export default）的方式导出组件
    - 3. 按需加载的组件
    - 4. 错误捕获： 在使用React.lazy时，请确保你的项目支持React的错误边界（Error Boundaries）以处理组件加载期间的错误，这个错误边界组件必须定义一个 componentDidCatch 方法，用于捕获子组件中的错误。使用错误边界包装按需加载组件。
  - 4. 针对一些慢接口，推动后端去解决：接口慢查询的统计是从哪拿的数据？网关拿的因为，前端统计的话会收到用户网络影响比较大，数据不实用。

  

## 用户体验优化

- 1. 用户感知，交互体验
  - 进度条
  - 及时反馈: 比如解决列宽拖拽
  

- 2. ui交互风格方面  
  - 1. 开发联邦模块组件库，通用的布局组件，表单，表格统一做一层封装，添加一些自定义交互，比如，表格吸顶，列宽拖拽，表单未保存切页的统一提醒;


- 固定表头(吸顶)

元素在其包含块（最近的滚动祖先）内滚动时，一旦元素到达指定位置（如 top: 0;），它就会“粘附”在这个位置， 注意，一个sticky 元素会"固定“ 在离它最近的一个拥有”滚动机制“的祖先上。

sticky属性仅在以下几个条件都满足时有效：

祖先级元素不能overflow:hidden；
  - 如果祖先级元素设置了，hidden了就没法滚动了自然就不生效

必须指定top、bottom、left、right4个值之一，否则只会处于相对定位




- 表单改动后未保存离开时的弹窗提醒

方案： 离开时（浏览器刷新和关闭，路由切换），子应用判断内容是否变更，如果有变更需要设置一个全局状态即可，基座会根据子应用的状态进行弹窗拦截。设置一个sessionStorage状态,needBackTipStatus = 1; 为1时拦截，其余不拦截。（拦截后，弹窗确认关闭后，重置这个值）


## 设计到的知识到

联邦模块概念：
- 联邦模块（Module Federation）是 Webpack 5 引入的一项重要特性，主要用于实现微前端架构和模块共享
- 它允许不同的项目或应用程序（甚至是运行时动态加载的应用）之间共享模块，从而使多个独立的 Web 应用能够协作开发和部署

原理：
- 在 Webpack 5 中，联邦模块允许应用程序在运行时（而不是构建时）从远程的 Web 应用加载模块。这意味着模块可以在用户访问页面时动态加载，而不需要提前将所有模块打包进主应用程序


#### 性能监控及指标

- 关键概念：
  - 白屏时间： 白屏时间通常从用户输入URL到页面开始呈现内容为止。当*浏览器开始绘制第一个像素时，可以认为白屏时间结束*。这时用户开始看到页面上的内容。
    - 对应着指标*FCP*： 它反映了第一个像素的绘制时间
    - 原理是用：PerformanceObserver 去获取（知道用这个去做就行了，不常用的就不用记细节）
   
  - 首屏时间
    - LCP： 最大内容渲染时间即可作为首屏时间，相对于FMP,能避免造假，因为FMP能自定义元素
      - 微前端项目用子应用的LCP就行
     
- 关键指标：
  - FCP
    - FP与FCP这两个指标之间的主要区别是：FP是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。相比之下，FCP指的是浏览器首次绘制来自DOM的内容（有意义的页面内容，通常是文本或图像的时间点）。例如：文本，图片，SVG，canvas元素等，这个时间点叫FCP。
  - LCP
  - TBT（Total Blocking Time ）： TBT 衡量了页面加载过程中主线程被阻塞的时间，这会影响用户的交互性能。较低的 TBT 时间表示页面更具响应性。
  - CLS(Cumulative Layout Shift): CLS 衡量了页面上元素布局的稳定性，即页面渲染过程中是否出现元素突然移动或改变位置
  - TTI（Time to Interactive）： TTI 衡量了页面何时变得可交互，用户可以进行操作，如点击链接或按钮。
- 测试手段
  - 基础参考数据
    - Lighthouse： Lighthouse测试通常是在你的本地开发环境或服务器上运行的，它提供了一些关于网站性能的有用指标和建议，但它主要反映了你的网站在特定环境中的性能。Lighthouse分析仍然是一个有用的工具，可*用于开发和测试过程中的快速性能检查*
      - 方法一：直接在浏览器的开发者工具中使用Lighthouse
      - 方法二： Lighthouse Docker镜像。有Docker镜像可以运行Lighthouse分析。这对于在容器化环境中使用Lighthouse很有用。
      - 方法二： Lighthouse提供了命令行界面（Lighthouse CLI）， 可以用类似： lighthouse <URL> 的命令进行分析。
  - 用户端数据： performance API 配合 Web Vitals
    - perfomance api： API 更适用于*深度性能分析和自定义监控*，适合对性能有更高级需求的开发者和团队
      - performance.now()： 获取当前时间戳
      - performance.timing： 提供了有关页面加载各个阶段的详细时间数据，如导航开始时间、重定向时间...
      - performance.getEntriesByType(type): 可以按类型获取性能条目，如资源、导航、脚本等，用于分析不同资源或事件的性能
        - 分析页面加载性能：performance.getEntriesByType('navigation')： 来获取与导航有关的性能数据，例如页面的加载时间、DNS查询时间
        - 资源加载监控：performance.getEntriesByType('resource') 
      - PerformanceObserver: 允许你监听性能事件，如 paint 事件、resource 事件、largest-contentful-paint 事件等，以便捕获特定性能事件的数据
    - Web Vitals 提供了一个简便的方式来测量和监控核心的用户体验性能指标, *Web Vitals 库已经封装了与 performance API 相关的复杂工作*，以使开发者更容易获取和监控核心的用户体验性能指标
      - 虽然 Web Vitals 是从外部发展的指标，但它们已被标准化并成为性能监控的关键组成部分



- 1. 浏览器DevTools调试工具里的网络监控分析，性能监控分析。（主要是performance 测试运行中的性能, 也可以测首屏，可以结合network，不过最终是需要自己去分析的，没有建议）

- 2. lighthouse(灯塔):网站整体质量评估并给出优化建议， 会基于上面的FCP, LCP等指标，打分，还会诊断报告和一些参考建议， 就可以针对性去优化（这个已经内置到浏览器DevTools里，一般测首屏比较合适）

> 水印， pointer-events 置为none穿透该元素，然后改下透明度； 或者canvas 把水印设置为背景图；或者用第三方包；

performace.getEntries() 也可以看见每个资源的加载时间（例如图片、script、css 等资源加载））

- 3. PerformanceObserver比较原生， 实际工程开发中计算这些指标，用的是封装好的web-vitals 包


其他性能测试工具： 

PageSpeed Insights： Google的一款免费网站评估工具，可以查网站在移动端和桌面端表现，以及各自对应的优化建议。

WebPageTest： 这个工具可以查看网站在不同国家，不同浏览器的表现，用户可以根据清单对网站逐项优化。

Sentry：  Sentry 是一个错误跟踪和性能监控平台，支持前端和后端应用。实时监控应用的性能问题，如页面加载时间、慢查询等，并记录性能下降的原因。


## 如何看优化前后的提升，如何保证客户端的一致性

- 用docker 去跑网站，看报告的前后对比；你可以在Docker容器中运行Google Chrome和Lighthouse
  - 1. 有一个现成的Docker镜像可以使用，叫做femtopixel/google-lighthouse
    - docker run --rm -v ${PWD}/reports:/home/chrome/reports femtopixel/google-lighthouse https://www.google.com
    - 这个命令会在当前目录下的reports文件夹生成一个名为www-google-com.report.html的Lighthouse报告。当然，你可以将https://www.google.com替换成你需要测试的网站URL。报告是个html打开就好了
    - 如果你希望得到针对桌面设备的审查结果，可以在运行时添加 --preset=desktop 参数


## 代码层面的优化


1. 减少回流（reflow）和重绘（repaint）， vue,react， 它们的使用虚拟dom，也有效的减少了重绘和回流（类似一种分离读写）
2. 尽量使用CSS3动画代替JS动画，因为CSS3的动画或者变形都开启硬件加速，性能比JS动画好
3. 编写JS代码的时候尽可能使用设计模式来构建体系，方便后期的维护，也提高了扩充性等
4. 事件委托： 在做DOM事件绑定的时候，尽量避免一个个的事件绑定，而是采用性能更高的事件委托来实现（减少dom的频繁操作，其中包括给每一个dom元素做事件绑定）

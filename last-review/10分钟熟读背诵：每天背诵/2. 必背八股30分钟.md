## 目录

js

- 请求加载
  - 前端页面加载过程
  - http握手
  - https加密
  - http2
  - 跨域

- 事件环：js & node

- 设计模式

- mobx 原理
- redux 原理
- vite 原理

11.5日：看完一遍；
12.1日： 看到： 登录: cookie session jwt

  

# js

## 事件的捕获和冒泡

事件的捕获（event capturing）和冒泡（event bubbling）是浏览器处理 DOM 事件的两种阶段，它们描述了事件在 DOM 树中传递的顺序

事件捕获： 事件捕获阶段是从文档的最顶层元素（即 window 或 document）开始，向下逐步传递到目标元素的过程。事件会先被祖先元素捕获，逐层往下传递，直到到达目标元素。

事件冒泡： 从目标元素开始向上传递，逐层冒泡回到 window 或 document
  - 通常用于事件委托（event delegation），即在父元素上监听子元素的事件，减少对多个子元素的事件监听

# http 及 页面加载

## 在浏览器地址栏输入一个url, 到页面返回展示，这中间发生了什么

- *检查http缓存*
  - ps: 检查强缓存：在发送 HTTP 请求之前，浏览器会先检查本地缓存（强缓存）。如果缓存有效，直接从缓存中读取数据，而无需发送请求。
  - 强缓存：（不需要与服务器通信）浏览器检查强缓存，如果资源未过期，直接从缓存中加载
    - 浏览器首先会检查本地缓存（内存缓存和磁盘缓存）中是否有该资源，如果有，则检查其缓存头（如Cache-Control和Expires） 
  - 协商缓存：（又叫条件请求）如果资源过期或不存在，发送HTTP请求到服务器。
    - 当资源未命中强缓存但仍可能有效时，浏览器会发送条件请求
      - If-Modified-Since： ：基于资源的最后修改时间
      - If-None-Match： 基于资源的ETag（实体标签）
- DNS解析
  - *查dns缓存*： 依次检查浏览器缓存，操作系统缓存，路由器缓存，如果都没找到会递归查询DNS服务器，最后返回ip 
  - DNS 查询可能涉及 CDN 调度，根据用户地理位置选择最优服务器
- *建立TCP连接*
  - ps: 缓存未命中或需要重新获取资源，浏览器会建立 TCP 连接（包括 DNS 查询和三次握手）。
  - 获取到IP地址后，浏览器会与服务器建立一个TCP连接, 通过“三次握手”完成:
    - 客户端发送SYN包: 客户端向服务器发送一个SYN（同步序列编号）包，请求建立连接.
    - 服务器回应SYN-ACK包: 服务器收到SYN包后，回应一个SYN-ACK包（同步-确认）。
    - 客户端发送ACK包： 客户端收到SYN-ACK包后，回应一个ACK（确认）包，连接建立
  - 如果使用 HTTPS，还包括 TLS/SSL 握手，协商加密算法，完成安全连接

- 发送HTTP请求
- 服务器处理请求并响应
  - 如果响应状态码是200（OK），浏览器接收新的资源并更新缓存。
  - 如果状态码是304（Not Modified），表示资源未修改，浏览器使用缓存中的资源。
- 浏览器解析响应并渲染页面
  - 解析HTML并构建DOM树: HTML 是字节流形式传输，浏览器一边接收一边解析（流式解析），构建 DOM 树
  - CSS 加载和解析,构建CSSOM树: *CSS 的加载和解析是异步进行的，不阻塞 HTML 的解析。*
    - *但 CSS 文件的解析会阻止后续 JavaScript 的执行（因为 JS 可能依赖样式计算结果）*，构建完成后，生成 CSSOM 树；
    - 浏览器必须等待所有 CSS 文件加载和解析完成后，才能构建完整的渲染树并开始渲染页面。
  - JavaScript 加载和执行: 当浏览器遇到 <script> 标签时
    - *如果没有 async 或 defer 属性，浏览器会暂停 HTML 解析，加载并执行 JavaScript*。
    - 由于 JavaScript 可能会修改 DOM 和 CSSOM，浏览器必须等待 JavaScript 执行完成后，才能继续解析 HTML。
  - 构建渲染树: 将DOM树和CSSOM树结合，生成渲染树
  - *布局（Reflow）*: 计算渲染树节点的几何信息（位置和大小）
  - *绘制（Repaint）*: 将渲染树中的节点绘制为像素，显示在屏幕上
  - 执行JavaScript
    - JavaScript代码可能会修改DOM树和CSSOM树，触发重新布局和重绘。



  - html解析关键点： 
    - *CSS 文件加载不会阻塞 HTML 解析，但会阻止其后面的 JS 执行*，因为JavaScript 可能会依赖于 CSS 的计算结果,例如，读取元素的尺寸和样式;
    - 浏览器不会等待 HTML 完全接收才开始解析，而是边接收边解析，尽早开始页面渲染
    
 


ps: 因为接受的html是字节数据，并不会等整个文档就位才开始构建，浏览器收到一部分数据就开始自上而下构建了dom树了，这样可以加快构建过程

- defer：脚本异步下载，不会阻塞 HTML 的解析，HTML 解析完成后按顺序执行（多个defer）。
- async：脚本异步下载，不会阻塞 HTML 的解析，下载完成后立即执行，顺序不定(多个async)。


- 提高css加载速度
  - cdn
  - css压缩： 打包工具压缩； 设置gzip压缩；
  - 合理使用缓存
  - 减少http请求数： css合并；或者写成内联样式（缺点不能缓存）

## http2

HTTP/2 用二进制帧实现多路复用，提高性能

💬 HTTP1.x 的问题：
  - 队头阻塞（队列中第一个请求阻塞后续）
  - 多连接并发受限

✅ HTTP/2 解决方案：
  - 单连接多路复用
  - Header 压缩（HPACK）
  - Server Push（预加载）

⚠️ 局限：HTTP/2 本质仍基于 TCP，仍可能被 TCP 队头阻塞影响（HTTP/3 基于 QUIC 解决此问题）


HTTP/2 的核心是“帧”和“流”。
- 帧是 HTTP/2 中传输数据的最小单位，每个数据帧都有特定的类型（如头帧、数据帧）。多个帧组成一个流（Stream），每个流有唯一的标识符，并且多个流可以在同一 TCP 连接上同时进行传输。
- 例如，客户端请求一个网页时，网页的 HTML 内容和它关联的静态资源（如 JS、CSS、图片）都可以通过一个 TCP 连接的不同流来传输，而不用像 HTTP/1.x 那样建立多个连接


- 流和帧的关系: 帧是 HTTP/2 中传输数据的最小单元。流是 HTTP/2 中传输数据的基本单元。
  - 组合： *一个流由多个帧组成*。一个流代表一个双向的、有序的字节流，可以承载一个完整的 HTTP 请求或响应。
  - 交错传输: 在 HTTP/2 中，*不同流的帧可以交错传输*。例如，流1的帧和流3的帧可以交替传输，而不会互相阻塞。

核心概念：

- 多路复用：一个 TCP 连接可以处理多个请求，解决了 HTTP/1.1 中的队头阻塞问题。
- 头部压缩：使用 HPACK 压缩请求和响应头部，减少传输的数据量。
- 二进制协议：相比 HTTP/1.x 的文本协议，HTTP/2 使用更高效的二进制格式。
- 服务端推送：服务器可以在客户端请求之前，主动推送资源，加快页面加载速度。


问题：
- 兼容性不好：虽然大多数现代浏览器都支持 HTTP/2，但一些老旧的浏览器或代理服务器可能不支持，或者需要特殊配置来使用 HTTP/2。
- TCP 队头阻塞： 尽管 HTTP/2 解决了应用层的队头阻塞问题，但它依赖于 TCP，而 TCP 协议本身存在队头阻塞的问题。HTTP/3 基于 QUIC 协议，旨在解决这一问题

## ajax

onreadystatechange 事件：每当 readyState 改变时，就会触发 onreadystatechange 事件。

readyState 属性存有 XMLHttpRequest 的状态信息。 （0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪）

```
let xhr = new XMLHttpRequest();//=>创建AJAX实例
xhr.open('GET', 'json/product.json');
xhr.onreadystatechange = () => {
    if (xhr.readyState === 4 && xhr.status === 200) {
        productData = xhr.responseText;
    }
};
xhr.send(null);

xhr.open ://=>打开一个请求的地址,最后一个参数是设置同步还是异步(FALSE:同步 TRUE:异步, 默认异步)

```

## GET VS POST

1.  [传递给服务器信息的方式不一样]

get 是基于url地址问号传参的方式把信息传递给服务器， POST是基于“请求主体”把信息传递给服务器

2.【GET不安全，POST相对安全】

因为GET是基于‘问号传参’把 信息传递给服务器的，容易被骇客进行url劫持，POST是基于请求主体传递的，相对来说，不好被劫持：所以登录、注册等涉及安全性的交互操作，我们都应该用POST请求

3.【GET会产生不可控制的缓存，POST不会】

不可控：不是想要就要 ，想不要就不要，这是浏览器自主记忆的缓存，我们无法基于JS控制，真实项目中我们都会把这个缓存干掉

GET请求产生缓存是因为： 连续多次向相同的地址（并且传递的参数也是相同的）发送请求，浏览器会把之前获取的数据从缓存中拿到返回，导致无法获取服务器最新数据（POST不会）

解决方案：

> xhr.open('GET', `/temp/list?lx=1000&=_${Math.random()`);//保证每次请求的地址不完全一致：在每次请求的末尾追加一个随机数即可（使用\_作为属性名，就是不想和其他的属性名冲突

## http 请求数据格式

前端在进行Post请求的时候会根据场景发送不同类型的数据，该Post请求头的Content-Type字段必须声明相应的数据类型(有时候会需要请求时来手动设置，大部分情况下浏览器会根据Body中的数据来自发的设置相应的请求头),比如说:

- application/x-www-form-urlencoded（Form Data）: 表单只包含基于文本的输入组件（例如输入框、单选框等），浏览器会将这些数据以 key=value 的形式组织
- application/json（JSON）
- multipart/form-data（Multipart Form Data）： 如果表单中包含文件或图片等不能被编码成文本的元素，浏览器就会使用 multipart/form-data 向服务器传输数据

## HTTP网络状态码

- 2xx 类状态码 表示请求成功，如 200 OK。
- 3xx 类状态码 表示重定向：
  - 301：永久重定向
  - 302：临时重定向
  - 304：资源未修改，客户端可以继续使用缓存的版本
- 4xx 类状态码 表示客户端错误：
  - 400 Bad Request：客户端请求有误，服务器无法处理，一般是请求参数错误
  - 401 ：未登录。
  - 403 ：无权限
  - 404 ：找不到资源
  - 405 ：请求方法不允许
- 5xx 类状态码 表示服务器错误，典型的有 500 Internal Server Error 和 502 Bad Gateway。
  - 500： 服务器在处理请求时发生了内部错误
  - 502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。

## 常用请求头

- 1. 通用请求头：沟通接收内容
  - Accept： 客户端能够处理的响应格式，常用于告诉服务器希望返回的数据类型，如 Accept: text/html，Accept: application/json。
  - Accept-Encoding： 客户端能处理的内容编码（压缩）方式，如 gzip, deflate。
  - Accept-Language： 客户端的首选语言，通常用于内容的国际化

- 2. 缓存相关请求头：沟通缓存
  - Cache-Control： 强缓存
  - If-Modified-Since：：基于上次请求的时间，询问服务器资源是否修改过
  - If-None-Match：基于资源的 ETag 值检查资源是否更改

- 3. 认证和授权相关请求头
  - Authorization：用于传递认证信息，如使用基本认证时，格式为 Authorization: Basic base64encoded(username:password)
  - Cookie：客户端发送给服务器的存储在浏览器中的 cookie 数据，如 Cookie: session_id=abc123。这些 cookies 用于维护会话状态。

 4. 内容协商请求头： 沟通请求体内容
  -  1. Content-Type： 客户端请求中发送的内容类型，尤其在 POST 和 PUT 请求中，指定请求体的数据格式，如 Content-Type: application/json，Content-Type: application/x-www-form-urlencoded
  -  2. Content-Length：请求体的长度，以字节为单位，用于告诉服务器请求的大小
  -  3. Content-Encoding：用于指定请求体的编码方式，常见的值是 gzip、Brotli 等。  
     -  Gzip：最常用的压缩算法，兼容性好。适合压缩文本内容（如 HTML、CSS、JS 等），对已压缩格式（如图片、视频）的效果有限
     -  Brotli： 更高效的压缩算法（比 Gzip 高 20%-30%），支持度不断提升，现代浏览器如 Chrome 和 Firefox 都支持。 
  -  4. Content-Language：指定请求体中的语言类型，如 Content-Language: en


## http缓存


强缓存失效后使用协商缓存：如果强缓存失效或者有特殊的 Cache-Control 指令（如 no-cache），则发起请求并进行 协商缓存。协商缓存通过 If-Modified-Since 或 If-None-Match 请求头询问服务器资源是否更改。

- 1. 强缓存：浏览器在缓存有效期内直接使用缓存中的资源，不发起请求到服务器验证资源是否更新

常用的响应头控制强缓存的机制有两个：
- Expires： 这是 HTTP/1.0 中的字段，指定资源的过期时间，格式为具体的日期时间，如： Wed, 21 Oct 2024 07:28:00 GMT
- Cache-Control： 这是 HTTP/1.1 中的字段， 常见的取值有：
  - Cache-Control: max-age=3600；表示资源在 3600 秒（1小时）内有效
  - Cache-Control: no-cache；表示浏览器每次都必须与服务器协商
  - Cache-Control: no-store；不缓存



- 2. 协商缓存

当强缓存失效（过期）或缓存被指定为需要验证时，浏览器会发起请求到服务器，服务器通过某些条件来判断缓存的资源是否可以继续使用，这就是协商缓存

协商缓存有两个常用的响应头：

- If-Modified-Since
  - 浏览器请求头 If-Modified-Since 会携带上次服务器返回的资源最后修改时间 Last-Modified
  - 服务器检查资源的修改时间，如果自该时间后资源没有修改，服务器返回 304 Not Modified，浏览器使用缓存
  - 如果资源更新了，服务器返回 200 OK 和新的资源内容。


- If-None-Match：
  - ETag 是服务器生成的一种资源标识符，可以理解为资源的指纹。浏览器会将上次请求返回的 ETag 放入 If-None-Match 请求头中
  - 服务器检查资源的 ETag 值是否与客户端的一致。如果一致，返回 304 Not Modified，表示资源没有更改，浏览器可以使用缓存。
  - 如果不一致，返回 200 OK 并提供更新的资源内容。


## https

## 秘钥

秘钥是一种在加密和解密过程中使用的一段参数，用于改变加密算法的行为

对称加密：
- 对称加密使用的是同一把秘钥进行数据的加密和解密
- 优点：是加密和解密速度快，适合大量数据的加密和解密
- 问题：是秘钥的传播和管理，因为加密和解密使用的是同一把秘钥，这就需要在通信双方之间安全地分发这个秘钥。

非对称加密：
- 非对称加密使用一对秘钥，一把是公钥，一把是私钥。公钥加密的数据，只有配对的私钥才能解密。反过来，使用私钥加密的数据，只有公钥才能解密。
- 公钥是公开的，任何人都可以使用公钥进行加密。
- 非对称加密的优点是可以解决秘钥分发的问题，缺点是加密和解密的速度相比对称加密慢。
  
在实际的使用中，通常会将对称加密和非对称加密结合起来使用：
- 使用非对称加密来安全地传送对称加密的密钥
- 然后使用对称加密来进行数据的加密和解密
- 这样就既解决了密钥的分发问题，又能快速地加密和解密大量的数据。
- 这个确定对称秘钥的过程，也就是ssl握手的过程

## https 

HTTPS 的基本工作机制是在HTTP通信之上加了一层安全协议（SSL/TLS），确保数据在传输过程中是加密的，防止中间人攻击、数据泄露等风险

-  HTTPS通信过程：

简单理解：https主要是要协商出一个对称加密的秘钥；


  
- 1. 客户端发起请求：用户在浏览器中输入HTTPS URL，浏览器请求连接目标服务器的443端口（HTTPS的默认端口）。

- 2. 服务器响应并发送证书：服务器收到请求后，向客户端返回*数字证书，证书中包含服务器的公钥和其他身份信息*。

- 3. 验证证书：浏览器验证证书是否合法，确认证书由可信任的CA机构颁发且未过期。如果验证失败，浏览器会显示警告信息。

- 4. 生成会话密钥：客户端生成一个随机的对称加密密钥，并使用服务器的公钥加密后发送给服务器。

- 5. 建立安全连接：服务器使用自己的私钥解密对称密钥，之后客户端和服务器将使用这个对称密钥进行加密通信。

- 6. 数据加密传输：客户端与服务器之间的通信使用对称加密算法进行加密和解密，确保传输过程中的数据不会被第三方窃听或篡改。


客户端                服务器
   |   → HTTPS 请求   |
   |   ← 数字证书(PubKey) |
   | 生成对称密钥后用公钥加密 |
   |   → Encrypted Key |
   |   ← 解密 & 确认完成握手 |
   | ←→ 加密通信（对称加密） |



## 跨域

### jsonp

JSONP 利用 <script> 标签的特殊性质绕过了浏览器的同源策略限制,适用于早期简单的跨域请求，不需要复杂的配置

缺点:
  - 只支持 GET 请求


JSONP 工作原理：
- 1. 动态创建 <script> 标签：
  - 浏览器对 <script> 标签的 src 属性请求不受同源策略的限制，因此可以请求跨域资源
  - JSONP 的核心思想是将请求数据的格式包装为一个 JavaScript 函数调用
- 2. 服务器响应
  - 客户端在发出请求时，通常会附带一个参数 callback，告诉服务器返回的函数名
  - 服务器会根据客户端提供的 callback 参数生成一个 JavaScript 函数调用，函数的参数就是要返回的数据
  - 浏览器执行返回的 JavaScript 代码，调用该函数，解析数据

```
1. 前端发起请求：

function handleResponse(data) {
    console.log(data); // 处理数据
}

const script = document.createElement('script');
script.src = 'https://example.com/getData?callback=handleResponse';
document.body.appendChild(script);

```

```
服务器返回的内容如下:

handleResponse({
    name: 'John Doe',
    age: 30
});

浏览器执行这段代码，handleResponse 函数被调用，传入的数据被处理。

```


### cors

CORS 是目前跨域请求的标准机制，几乎所有现代浏览器都支持，它解决了同源策略带来的跨域限制问题。

CORS 工作原理：
  - CORS 允许服务器明确告知浏览器哪些来源（origin）可以访问资源，并通过 HTTP 请求头和响应头来控制跨域请求的行为。


CORS 请求分为两种类型:
  - 简单请求:对于简单请求，浏览器会直接发送请求，服务器通过返回的 CORS 响应头来告知浏览器是否允许跨域。
    - 请求方法为 GET、POST、或 HEAD
    - 头部字段只能包括：Accept、Accept-Language、Content-Language、Content-Type（值限定为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain）。
  - 复杂请求：
    - 预检请求： 如果跨域请求不满足简单请求的条件，浏览器会在正式请求之前发送一个 预检请求（使用 OPTIONS 方法）。预检请求的目的是询问服务器是否允许此次跨域操作。

cors 请求头，响应头关键字： 一般以Access-Control开头
  - 请求头关键字：Origin，以及在预检请求中的 Access-Control-Request-*
  - 响应头关键字：Access-Control-Allow-* 系列


- 如何减少预检请求options？
  - 使用缓存： 利用Access-Control-Max-Age 响应头来控制预检请求的缓存时间；
  

### cdn

CDN的主要目的是通过将内容缓存到靠近用户的服务器上，减少网络延迟、提高访问速度、减轻源站服务器负载，提升用户体验

用户的请求通过DNS解析，定位到离用户最近的CDN节点;如果CDN节点上有缓存的资源，直接返回给用户，减少访问源站的时间



## 安全

xss（跨站点脚本）: 是指黑客能够在你的网站当中执行他的代码 

csrf（跨站请求伪造）: 是指恶意利用浏览器会自动发送cookie的功能，由黑客所有网站发起的对于目标网站的恶意请求


## 登录: cookie session jwt


- Cookie：
  - Cookie 是浏览器存储在客户端的一小段文本信息，用来保存用户的状态或数据，并在客户端与服务器之间来回传递。
  - 每次发起请求时，浏览器会自动将 cookie 附带在请求头中发送给服务器
  - 特点：
    - 持久化存储：可以指定过期时间（expires/max-age），存储在客户端，适合长期保存一些小的状态数据。
    - 作用范围：可以通过 domain 和 path 限定 cookie 的作用范围。
    - 安全性：可以设置 HttpOnly（防止 JS 访问）、Secure（仅限 HTTPS 传输）等标志。如果HttpOnly属性设置为true，就不能通过js脚本来获取cookie的值，能有效的防止xss攻击

- Session
  - Session 是服务器端用于保存用户状态的会话机制，它存储在服务器上，并且与客户端的请求关联。通常通过 sessionId 作为唯一标识，服务器根据 sessionId 找到用户的会话信息
  - 客户端通常通过 Cookie 或 URL 来携带 sessionId


- JWT
  - JWT 是一种用于客户端和服务器之间传递加密认证信息的机制，格式为 Header.Payload.Signature。
  - JWT 是自包含的，包含了用户的认证信息（例如用户 ID、权限等），并通过签名保证其真实性和完整性
  - JWT通常存储在 localStorage 或 Cookie 中
  - 验证机制：
    - token 由 header.payload.signature 三部分组成：
      - Header（头部）： 包含 Token 的元信息， 比如使用的签名算法类型
      - Payload（负载） ：存储实际传输的数据，比如用户信息、权限，过期时间等
      - Signature（签名）：用于验证 Token 的真实性，防止 Token 在传输过程中被篡改。签名是通过将 Header 和 Payload 进行编码后，再加上一个密钥进行加密生成的

    - 校验
      - 每次请求的时候带上token, 后端对header 和 payload 再做一次签名，对比签名是否一样


## 页面间通讯

跨标签页，可以使用：

-  1. BroadcastChannel：是为了解决多个标签页之间的通信问题而设计的，它可以在同源（同域名、协议、端口）的不同窗口、标签页、iframe 之间广播消息，并且几乎实时接收广播
   -  实时通信，适合处理需要立即响应的操作，如用户点击事件。
   -  BroadcastChannel 是基于“频道名称”来广播和接收消息的。即使实例不同，只要频道名称相同（比如 my_sync_channel），它们都会互相广播和接收消息
      -  所以发送和接收，可以用同一个实例，也可以是不同实例，只要频道名称相同就能收到信息。
         -  new BroadcastChannel(channelName)
         -  channel.onmessage
         -  channel.postMessage(message)


- 2.  localStorage + Storage 事件：localStorage 可以在多个同源的标签页之间共享数据，并且通过监听 storage 事件来检测 localStorage 的变更，实现通信。
  - 只有修改 localStorage 时才会触发 storage 事件，因此需要有主动的变更触发。
  - 不支持跨域，只能在同源的标签页之间通信。


## Web Storage

Web Storage 主要有两种类型：localStorage 和 sessionStorage

- localStorage ：是用于长期存储数据的，除非用户手动清理浏览器数据，否则数据不会过期。
- 特点： 
  - 持久性：永久存储，想清除只能主动清除
  - 容量限制：每个域名通常可以存储 5~10MB 的数据，具体大小由不同浏览器决定。
  - 访问范围：*同源下*的所有页面都能访问同一个 localStorage 数据
  - 可以监听到storage事件


- sessionStorage： 是用于短期存储数据的，当用户关闭标签页或浏览器时，数据会自动被清除。
  - 特点
    - 会话级存储：数据只在当前标签页会话中有效，关闭标签页或浏览器后数据即被清除。
    - 容量限制：与 localStorage 相似，每个域名通常可以存储 5~10MB 的数据。
    - 访问范围：*仅限当前标签页或窗口*，其他标签页或窗口无法访问同一个 sessionStorage 数据，即便是同源下的页面
      - 每个标签页的 sessionStorage 数据都是隔离的，不同标签页之间不会互相影响
    - 无法监听到storage事件




## 事件环

事件环（Event Loop）是 JavaScript 运行时中的核心机制之一，它允许 JavaScript 在单线程环境下进行异步操作，并处理回调任务

### JS 事件环部分

渲染ui （事件环主要指的是js基准，渲染与渲染引擎有关，可以不算在事件环里）
浏览器中，微任务执行完毕后才会渲染界面

任务队列： 
  - 宏任务队列（Macro Task Queue）：包括 定时器、I/O 操作（如文件读取）、网络请求等
  - 微任务队列（Micro Task Queue）：包括 Promise.then、MutationObserver， process.nextTick（node 中独有的） 等。

JS 是单线程的，通过事件循环机制处理异步任务：
1. 执行主线程同步任务；
2. 清空所有微任务（Promise.then、MutationObserver 等）；
3. 渲染（UI 线程与 JS 线程互斥）；
4. 执行下一个宏任务（如 setTimeout、MessageChannel）；


渲染和微任务： 在浏览器中，微任务的执行优先级非常高，微任务执行完毕后才会渲染界面。也就是说，在当前事件循环中，微任务执行完之后，浏览器才会进行页面的渲染操作。

### Node事件环

Node.js 的事件环包含了多个阶段，每个阶段处理不同类型的任务。Node.js 使用了 libuv 库来管理 I/O 操作，因此事件环分为多个阶段

Node.js 事件环的 6 个主要阶段，一般主要关注其中三个阶段：
- 定时器（Timers）：执行 setTimeout 和 setInterval 设定的回调。
- 轮询（poll）： 检索新的 I/O 事件，执行 I/O 回调。如果检测阶段没有任务，代码逻辑还没执行完，会阻塞在这个阶段，等待定时器到达时间，或者新的i/o操作， 避免不停地循环查找
- 检测（check）： setImmediate 回调函数将在此处执行


执行顺序：

- 1. 主栈同步任务执行完。
- 2. 执行所有微任务（process.nextTick 优先，然后是 Promise 等微任务）。
- 3. 执行不同阶段的宏任务。
- 4. 每个阶段结束后，都会再次清空微任务队列。


node中： *微任务队列中的任务（如 Promise.then 的回调、process.nextTick）是在每个事件循环的阶段结束时执行，而不是在每个宏任务（Macro Task）执行完之后*
  - 事件循环阶段（如 Timers、I/O Callbacks、Poll 等）中可以包含多个宏任务
    - Node.js 的事件循环中的“阶段结束”并不意味着所有属于当前阶段的所有回调都必须执行完毕才会进入下一阶段，比如timers阶段 ，不必等所有定时器都执行完，而是到期的定时器执行完。Node.js 的事件循环阶段主要通过一系列条件来决定是否继续留在当前阶段。
  - 区别： 浏览器环境下，每个宏任务结束后，立即清空微任务，然后才进行下一个宏任务


```
以下谁先执行：

setTimeout(() => {
  console.log('setTimeout');
}, 0);

setImmediate(() => {
  console.log('setImmediate');
});

他们的执行顺序是不确定的，与电脑性能有关。
如果执行代码时定时器时间到了就会执行定时器，如果没到，就行继续走到检测阶段执行setImmediate。


但是如果在i/o操作的回调函数中去写这两个，执行顺序是确定的，因为i/o下一个阶段是检测setImmediate，所以会先执行setImmediate；


```

- setImmediate 的使用场景：
  - 更快执行 I/O 回调：当你想在某个异步 I/O 操作完成之后立即执行回调，而不希望被延迟时，setImmediate 是很好的选择。例如，读取文件或网络请求结束时，你想立即处理回调。
  - 避免阻塞事件循环： 当你有一个长时间运行的同步代码块，需要将其拆分成多个小步骤时，setImmediate 可以用来在每个小步骤之间释放事件循环，让其他异步操作可以继续执行，而不会阻塞事件循环


## esmodule 和 common.js


CommonJS：
- 1. 导出：导出的是值的拷贝，导入后再修改不会影响导出模块的内容。
    - 理解： CommonJS 是“静态”导出，导出时就固定了值， 缓存过就直接去缓存里找了
- 2. 执行时机: 模块会在导入时立即执行，所以模块代码在 require() 时被执行一次。如果一个模块被多次 require，后续的导入将使用缓存的结果（不会重复执行）。

ESModule
- 1. 导出：导出的是引用，导入后修改会影响导出模块的值。
  - 理解： ESModule 是“动态”导出，值是可以更新的。
- 2. 执行时机: ESModule 是在加载时静态分析的，它会先解析所有导入的模块（不立即执行代码），执行顺序是按依赖关系决定的，这个过程被称为静态分析。
  - ESModule 是按模块的依赖关系树进行异步加载。当浏览器遇到 <script type="module"> 标签时，它会并行下载该模块及其所有依赖，但会按依赖关系顺序依次执行。


## 内存泄露

定义： 已经*结束运行的或者不再使用的内存没有被释放*（没有被垃圾回收机制回收），仍然被占用，导致可用内存逐渐减少，严重时可能会导致程序运行缓慢或者崩溃

场景：
- 1. 全局变量未正确清除：显式声明的全局变量在全局作用域内始终存在，不会被垃圾回收机制清除
- 2. 未清理的定时器或回调函数： 如果一个定时器（如setTimeout或setInterval）或者事件监听器（如addEventListener）设置了，但在不需要的时候没有被clear或remove
- 3. 闭包: 在JavaScript中，闭包可能会导致内存泄漏，特别是当闭包内部的变量包含了大量数据或复杂的对象引用时。


## vite

- Vite 的基本原理（核心就是与webpack的区别）
  - 即时启动：Vite 通过 ES Modules 原生支持，在开发时不需要打包整个项目，而是按需加载模块，大大加快了启动速度。（Vite 如何处理依赖预构建）
  - 按需编译：Vite 在开发模式下，基于请求实时编译所需模块，而不是整个应用，这使得大型项目的热更新更加快速。（热模块替换）
  - 生产构建：在生产环境中，Vite 使用 Rollup 进行打包，提供与传统工具相当的优化。


- Vite 如何处理依赖预构建
  - Vite 使用 esbuild 预构建第三方依赖，使得项目启动速度更快。因为大多数第三方库并未以 ES 模块的方式发布，Vite 会将这些依赖转换成 ES 模块供浏览器加载。
  - esbuild 是一个超快速的构建工具，比基于 JavaScript 的打包工具快得多，因此依赖预构建加速了初次加载。

- 热模块替换（HMR）
  - 传统工具需要重新打包并构建整个应用，而 Vite 只需重新编译改动的模块并通过 HMR 注入到页面，速度更快
  - 原理：
    - 文件变更检测：当代码发生变化时，构建工具（如 Vite）会捕捉到这些变化。
    - 重新编译模块：只编译变化的模块，而不是整个应用。
    - 通过 WebSocket 推送更新：服务器通过 WebSocket 将变更推送到浏览器。
    - 替换模块：浏览器接收到更新后，替换旧模块，但不刷新页面，保持应用状态不变。


- 为什么选择 Vite 而不是 Webpack
  - 启动时间更快，开发体验好：Vite 对比 Webpack 等传统工具更快，尤其是大型项目。
  - 热更新速度更快： 热更新速度更快，项目启动时不需要先进行打包
  - 简化配置： Vite 默认使用现代 JavaScript 特性，配置更简单，开发者体验更好。


- 如何在 Vite 中进行环境配置和优化
  - Vite 使用 env 文件来区分不同环境的配置，通过 import.meta.env 访问环境变量
  - 对于生产环境，Vite 使用 Rollup 进行打包，提供代码分割、Tree Shaking 等优化，确保高效的构建性能。


## V8内存回收机制


- 1. 内存分代：V8将内存分为新生代（短期存活对象）和老生代（长期存活对象）。
- 2. 垃圾回收：
- 新生代：采用"Scavenge"算法，将活跃对象复制到另一片空间，非活跃对象会被回收。
  - Scavenge 算法： 将新生代空间分为两个区域：From 和 To。垃圾回收时，将 From 空间中的存活对象复制到 To 空间，然后释放 From 空间。
  - 这种算法效率较高，但浪费了一半的空间（To 空间）。
- 老生代：使用"Mark-Sweep"（标记清除）和"Mark-Compact"（标记整理）算法，标记活跃对象，清除或整理内存。
  - 首先遍历整个堆，标记可达对象。然后清除未标记的对象，释放内存
  - 在标记-清除之后，标记存活的对象并进行内存压缩，减少碎片化的内存
- 增量回收：V8通过增量回收避免应用长时间暂停，提高性能。



## Webpack 的打包流程

Webpack 会以入口文件为起点，逐步解析所有模块和依赖，最终生成一个或多个可以在浏览器中运行的打包文件


1. 初始化参数：从配置文件和 Shell 语句中读取并合并参数,得出最终的配置对象
2. 用上一步得到的参数初始化 Compiler 对象(Compiler 是用来管理编译过程的编译器)
3. 在Compiler 对象上加载所有配置的插件（拿到所有的插件实例，执行他们的apply方法（在插件里订阅相应事件），并传入complier对象作为参数）
4. 执行Compiler 对象的 run 方法开始执行编译
5. 根据配置中的entry找出入口文件
6. 从入口文件出发,调用所有配置的Loader对模块进行编译
7. 再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
8. 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk
9. 再把每个 Chunk 转换成一个单独的文件加入到输出列表
10. 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

> 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果

entry: 模块入口，让源文件加入到构建流程中
output: 配置如何输出
module: 配置各种类型模块的处理规则
plugin: 配置扩展插件
devServer: 实现本地服务，包括 http, 模块热替换，source map等服务

- chunk
  - chunk 是 Webpack 在打包过程中生成的代码块或代码片段。它是模块和其依赖的集合，用于实现代码分割和优化加载
- bundle
  - bundle 是 Webpack 打包后生成的最终文件。通常，一个 bundle 文件对应一个 chunk。bundle 文件包含了被打包和处理过的 JavaScript 代码、CSS、以及其他资源


### loader 原理

1. 输入是加载到的资源内容
2. 输出是加工后的结果: 处理后的结果得是js代码(代码字符串)

如果有多个loader,从后往前执行


### 插件原理

webpack 实现插件机制的大体方式是：
1. 创建 - webpack 在其内部对象上创建各种钩子；
2. 注册 - 插件将自己的方法注册到对应钩子上，交给 webpack；
3. 调用 - webpack 编译过程中，会适时地触发相应钩子，因此也就触发了插件的方法。


总的原理：

插件主要就是实现插件类的apply方法，在apply方法里去监听（tap）某个内置hook（各种时机的hook，使用时需查文档）的插件事件（一般是当前插件本身类名），监听到后，（在某个时机，webpack内部调用call触发插件事件, 并传入相应参数数据，如果是async类还会有回调函数参数），
拿到对应hook传给我们的数据，用数据做一些我们自己的想处理的操作，然后调用传入的回调函数（如果传了，并且需要的话）；可能会在apply里监听多个事件，在各个时机执行对应操作


## 联邦模块 Module Federation

**应用或应用块共享其他其他应用块或者库**， 一种代码共享机制，由webpack插件和webpack共同实现

当我们一个公共模块被多个项目使用时，我们一般会把它打包成npm包，通过发包的方式进行进行组件/方法的复用。 当组件（方法）有一些更新时候，尤其是更改了某些存在的bug，就不得不通知依赖模块进行升版；如果存在多个依赖方，这种“发布npm-> 通知-> 更改多个项目->重新发布多个项目”模式无疑是低效率的；

联邦模块正是解决这种问题的一种方案，只需要更新一个项目，其他项目即可引用最新的模块。


### 联邦模块基本原理

Webpack 会把 ModuleFederationPlugin 选项配置了 expose的组件单独打包出一份chunk； 而如果把这份chunk的URL和filename配置在remote属性下，即表示webpack会帮你去请求这份代码，然后帮你挂载到全局变量，并解析放入你的组件中


## jsBridge

JSBridge 是一种用于 WebView 中 JavaScript 和原生代码之间交互的桥接机制。
它解决了 H5 和原生环境之间通信的问题，让前端页面可以调用原生功能，同时原生也可以调用 H5 页面中的方法。


### JSBridge 的原理

- JavaScript 调用原生:
  - 在 H5 页面中，调用特定的方法并传递参数。
  - WebView 拦截这些调用，通过 URL Scheme 或自定义协议，转发给原生处理。
  - 原生端解析传递的参数并执行对应的逻辑，返回执行结果给 JS

- 原生调用 JavaScript
  - 原生端通过 WebView 的 API 执行一段 JS 代码
  - 常用方法: 
    - Android: evaluateJavascript 或 loadUrl
    - OS: evaluateJavaScript 或 stringByEvaluatingJavaScriptFromString



- JSBridge 的常见原理与实现方式
  - 1. 基于 URL Scheme
    - 原生拦截 window.location.href 的变化，解析 URL 获取方法名和参数，完成调用。
    - 缺点：数据传输容量受限，性能不高。
  - 2. 基于 WebView 提供的接口
    - Android 使用 addJavascriptInterface 暴露原生对象，供 JS 直接调用。
    - iOS 使用 WKWebView 的 messageHandlers 或直接执行 JS。
  - 3. 统一封装的 JSBridge
    - 在前端提供一个 JSBridge 对象，隐藏具体的调用方式。
    - 双方约定好调用方法和数据格式，增强灵活性和易用性


- WebView 是一种嵌入式浏览器组件，允许应用程序在其内部显示 Web 页面内容。它提供了一个容器，可以加载和渲染 HTML、CSS、JavaScript 等 Web 内容，而无需打开独立的浏览器。




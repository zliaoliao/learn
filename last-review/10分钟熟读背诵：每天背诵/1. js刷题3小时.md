## js 刷题【15分钟】

### 容易忘的


- 1. 手写emmiter事件机制: on, once 绑定操作不需要传参，不可能绑定函数的时候就把参数固定了，你只是注册了一个回调函数，并不需要马上传参数。;*emit， wrapper 触发事件时（事件函数执行时）才需要传参*, emit 是“广播”，它广播的数据就是你传递的参数，所有监听这个事件的函数都会接收到这些参数;
  - 注意事项：
    - once 本质是一个on，是一个绑定，不是立即触发的，没有参数params;
    - push 不可以这么写： （this.store[eventName] ||[]).push(item), 因为push返回的是数组长度
- 2. 手写require:  
  - 步骤：
    - 1. 解析绝对路径
    - 2. 读取缓存，如果有就返回缓存结果
    - 3. 更新缓存
    - 4. 加载模块，返回module.exports
  - 注意点:
    - 1. fs 模块中， readFile, *readFileSync， 默认读取文件是buffer，加第二个参加编码，才是字符串*： `const content = fs.readFileSync(id, 'utf8')`
    - 2. 在我们自己实现的require 里是没有__dirname, __filename 等模块默认传入的参数的，不过这不是重点，而且处理起来比较麻烦，一般直接用path.resolve 处理就好,然后注意启动项目的时候再当前目录就好了；
      ```
      // 解析路径
          const id = path.resolve(filePath);
          const __filename = path.basename(id);
          const __dirname = path.dirname(id);

          // 简单实现不处理__filename， 和__dirname 也行
        ```

    - 3. 拼接并执行函数：new Function(arg1, arg2, ..., body) 的参数结构：*前面的参数（如 arg1, arg2）表示生成函数的参数名，以字符串形式提供；最后一个参数 body 是函数的代码体，也是字符串形式。*
      - new Function 构造函数时，形参为字符串形式，body也是字符串；也就是new Function 接受字符串形式的参数；

    ```
    const code = fs.readFileSync(absPath, 'utf-8');
    
    // 使用 new Function 创建隔离的作用域来执行代码
    const compiledFunction = new Function('module', 'exports', 'customRequire', code);
    compiledFunction(module, module.exports, customRequire);


    ```




```

// EventEmitter


class EventEmitter {

  store = {}

  on = (name, fn) =>{
    this.store[name] = this.store[name] || [];
    this.store[name].push(fn);
  }

  off = (name, fn) => {
    if(!this.store[name]) return;
    this.store[name] = this.store[name].filter(listener=>{
      return listener != fn && listener.fn != fn;
    })
  }

  emit = (name, ...params) => {
    if(!this.store[name]) return;
    this.store[name].forEach(listener=>{
      listener(...params)
    })
  }

  once = (name, fn) => {
    const wrapper = (...params) => {
      fn(...params);
      this.off(name, wrapper)
    }
    wrapper.fn = fn;

    this.on(name, wrapper)
  }
}

```


```
// require


const fs = require('fs');
const path = require('path');

const moduleCache = {};

function customRequire(modulePath) {
  const absPath = path.resolve(modulePath);

  if (moduleCache[absPath]) {
    return moduleCache[absPath].exports;
  }

  const module = { exports: {} };
  moduleCache[absPath] = module;

  const code = fs.readFileSync(absPath, 'utf-8');
  
  // 使用 new Function 创建隔离的作用域来执行代码
  const compiledFunction = new Function('module', 'exports', 'customRequire', code);
  compiledFunction(module, module.exports, customRequire);

  return module.exports;
}


```




### 基础

- 1. 区分斜杠： / 就像是一个向右前方走的斜线（“正”向前）。正则的边界，文件路径
反斜杠： \ 则是一个向左后方倾斜的斜线（“反”向后）。转译字符，分割符\n 
  - 用换行符分割字符串：简单常规的用 '\n'就行（mac）， 需要夸windows平台的,需要加上 '\r\n'
  - `csvString.replace(/\r\n/g, '\n').split('\n')`


- 2. 正则：
  - 正则中\1 的妙用，表示第一个捕获组, 匹配重复字符： /(.)\1*/g
  - 千分位处理: 一个数组 被三个数的倍数跟着，*一直到结尾* , 则可加一个 ','
    - /(\d)(?=(\d{3})+$)/g

- 3. 实现reduce: 
  - 1. 关键在于pre的生成与初始值的处理，在循环中调用回调函数: 用arguments.length判断是否原初始值
  - 2. 无初始值，第一项就是初始值, pre=this[0], 从1开始遍历;有初始值pre=init, 从0开始遍历;

- 4. 用reduce实现map: 利用pre收集map的最终结果；map不返回值就相当于forEach,元素的每一项都调用reduce 回调函数，把结果放到pre里，最后返回就好了

- 5. 防抖节流： 返回一个函数，都需要*闭包保存timer变量*，以便下一次点击进来时做处理
   - 防抖, 每次点击取消上一次操作： 每次进来，如果有timer把timer定时器清除掉，重新设置定时器;
   - 节流（throttle）, （固定时间）只有上一次操作执行完才会响应本次操作： 每次进入，如果有timer就不做任何操作，如果没有就设置定时器，操作执行完，再清除定时器；
     - 调用 clearTimeout(timer) 只是取消了定时器的任务，但不会清除 timer 变量本身，它仍然保留着定时器 ID； 写节流时，清定时器同时要把timer置为null; 防抖时，可置null也可以不管，因为不影响；

- 6. 字符串方法：str.match(reg)，返回正则表达式匹配出来的结果数组

- 7. 实现call: call 主要是用于函数执行时，改其this，可以用 context.fn() 的方式（对象 . 的方式）改this； 
  - 1. 提升秀技：可以用Symbol()避免key重复， const fnSymbol = Symbol()； 记得这个属性用完要删掉，恢复原状；
    - 2. 提升秀技： obj没有传时，默认为全局对象, context = context || globalThis， 或者给参数赋默认值*globalThis*;
  - 3. 注意：call的参数为: context 上下文对象， ...params 参数； 它是用. 调用的， 它里面的this 就是那个调用的函数： context[fnSymbol] = this;
  - 4. call 执行也是有结果的，就是原函数执行的结果； 
- 8. 实现bind: 同call, 只不过延迟执行,通过返回一个函数的闭包形式实现延迟执行,内部用call实现就行
  - 先用_this 变量把原来的this记录下来, this 就是要绑定的函数了；
  - 要注意，绑定时可以传初始参数，调用还可以传一次参数；
- 9. apply: 同call, 只不过传的参数是一个数组


- 10. 实现new : _new(fn, ...arg) 
  - 1.  首先创建一个对象，对象的__proto__属性指向构造函数的原型对象: *Object.create(fn.prototype)*, 注意不是指向fn
    - Object.create() 静态方法以一个现有对象作为原型，创建一个新对象
  - 2.  函数执行，让构造函数内部的this指向上面创建的空对象: call
  - 3.  如果构造函数返回一个引用类型的值，则返回这个值，否则上面创建的对象： res instanceof Object


- 12. 判断值为基本类型（非引用类型）： typeof value !== 'object' || value === null
  - 注意这里是 || 的关系， 容易写错

- 13. trim 去除的是： 空白， 包括空格，制表符，换行符；
- 14. *WeakMap 的键必须是对象（Object）*，而不是原始值（如 number 或 string），键是弱引用，这意味着当没有其他引用指向某个键时，该键值对会自动被垃圾回收
- 15. 实现flat
  - 1. 递归： reduce + concat， 收敛到pre
  - 2. 迭代： 栈 + 结果数组, 线变成栈，从栈顶取，是数组则展开重新放入栈，不是则放入结果数组
- sort() 方法用于对数组进行排序，改变原数组：
  - 自定义排序规则： 比较函数有两个参数，a 和 b， a-b 为升序，反之降序；
- 16. concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。

### 实现flat

### 展平数组 flat

- js原生的flat() 方法创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中。

let ary = [1, [2, [3, [4, 5]]], [6, 7, [8, 9, [11, 12]], 10]];

- 处理深度
- 不改变原数组
- 出此题一般想让你用递归或者迭代做法

解法一：concat,递归

- 面试一般写这个就行，这个好写，而且有深度

```
const _flat = (arr, depth=1) => {
    if(depth===0) return arr;
    return arr.reduce((pre, cur)=>{
        return pre.concat(Array.isArray(cur)? _flat(cur, depth-1) : cur)
    }, [])
}

```

解法二：栈, 遍历
- 易错点：
  - push 的参数可以是多个
  - 如果要处理depth 需要，记录每一个元素的depth;
    - 如果判断为数组，重新放入栈中是，每一个元素还需要带上depth，所以还需要map一下；


```
const _flat1 = (arr, depth = 1) => {
    const result = [];
    const stack = arr.map(item => ({ value: item,  depth })); // 初始化栈，每个元素带有剩余深度

    while (stack.length > 0) {
        const { value, depth } = stack.pop();

        if (Array.isArray(value) && depth > 0) {
            // 如果是数组且还有剩余深度，展开并入栈，同时减少剩余深度
            stack.push(...value.map(item => ({ value: item, depth: depth - 1 })));
        } else {
            // 非数组或剩余深度为 0，直接加入结果
            result.unshift(value);
        }
    }

    return result;
};

```


方法三：JSON

let str = JSON.stringify(ary);
ary = str.replace(/(\[|\])/g, '').split(',');

// 对于子元素结构与母元素结构相同的，比如数组类型，一般在遍历元素后，根据数据类型判断是否需要递归处理



### promise 方法

以下所有写法，为保证迭代项是promise, 不是promise的，也要变成promise, 统一用 Promise.resolve()包一下；

- 静态方法： 在Promise 上，类上

- 1. Promise.race() 
  - 接受一个 promise 数组
  - 返回一个 Promise
  - 这个返回的 promise 会随着第一个 promise 的敲定而敲定
  - 一句话，循环里返回第一个promise敲定状态的promise状态： Promise.resolve(p).then(resolve, reject);


- 2. Promise.all()
  - 接受一个 promise 数组
  - 返回一个新的 Promise，它会在所有传入的 Promise 都解决时，*并返回一个包含每个 Promise 解决值的数组*。
  - 如果其中任何一个 Promise 被拒绝，返回的 Promise 会立即拒绝，并返回第一个被拒绝的原因。
  - 一句话： 循环里，计解决次数，并把解决值放在解决结果数组对应位置，有一个失败则失败：
    -  resolvedValues[i] = value

- 3. Promise.allSettled()
  - 返回promise, 会等待所有 Promise 的结果，*无论它们是成功还是失败， 总是会resolve 结果数组*;
    - 结果对象属性：
      - 表示成功或者失败： status： 值为 *"fulfilled"*(注意拼写，不是full) 或 "rejected"
      - 表示成功的值，成功时才有： value 
      - 表示失败的原因，失败时才有： reason
  - 一句话： 循环里，计解决和被拒绝次数， 把结果对象放到结果数组对应位置， 次数集满resolve 结果数组


- 实例方法： 在 Promise.prototype上， 原型上

 
- 1. finally:  无论 Promise 的结果如何，finally 中的回调都会执行
  - finally 返回一个新的 Promise，该 Promise 的*值或拒因与原 Promise 保持一致*，（如果是值返回就好，如果是错误要抛出）： 
    - 值或拒因与原 Promise 保持一致,利用： this.then 拿到原promise 的状态
    - 抛出错误： throw(reason)
  - 难点： 如果回调函数返回一个 Promise，finally 会等待它完成。把它放到Promise.resolve中来完成这个等待
    - 成功的情况： Promise.resolve(callback()).then(()=> value)
    - 失败而情况： *Promise.resolve(callback()).then(()=> {throw(reason)})*




### promise 题目

- 实现promisefy： 返回一个包装函数， 调用这个包装函数会返回promise；主要是将一个回调函数形式的异步操作, 转换成返回 Promise 的形式
  - 在promise 里执行传入函数fn， 在fn的回调函数里，resolve 或者 reject 结果

```
function promisefy(fn) {
    return function(...args) {
        return new Promise((resolve, reject) => {
            // 调用原函数，传入回调函数
            fn(...args, (err, result) => {
                if (err) {
                    reject(err);  // 如果回调中的第一个参数是错误，则 Promise 被拒绝
                } else {
                    resolve(result);  // 否则， Promise 被解析为结果
                }
            });
        });
    };
}

```

- 实现一个 retry，即在一个函数执行失败后重试指定次数
  - retry接受一个异步函数 fn，并在其失败时进行指定次数的重试

```
function retry(fn, retries) {
  return new Promise((resolve, reject) => {
    function attempt(n) {
      
        fn().then(resolve)
        .catch((err) => {
          if (n === 0) {
            reject(err); // 重试次数用完，抛出错误
          } else {
            attempt(n - 1); // 递归重试
          }
        });
    }
    attempt(retries); // 开始尝试
  });
}



```

## 代码执行顺序

- async, await
  - await 的内容是立即执行的
  - await 后的内容（下一行）是异步的，相当于微任务，需要等await结果

```
const e = await b(); // b 立即执行
    console.log(e); // e 等待到b的结果，才会在微任务里打印

```

- gui渲染，是在微任务队列清空后

## 常见题型

- 深克隆: 面试时先不需要处理循环引用，先只写简单版本, 只处理基本类型，对象，和数组; 稳妥一点，对象和数组还可以分开处理；
  - *要避免被人认为是背诵的，所以一开始不能处理循环引用*，面试官要求处理时再处理;
  - 1. 处理简单类型： 直接返回
  - 2. 处理可用构造函数 `value?.constructor` 直接构造的类型：const reference = [Date, RegExp, Set, WeakSet, Map, WeakMap, Error];
  - `if (reference.includes(value?.constructor)){
      return new value.constructor(value)
    }`
  - 3. 处理循环引用：用弱映射， 入参 hash = new WeakMap， 存过此值就直接返回
    - `if (hash.get(value)) {  return v }`
    - 循环引用是对象之间的相互引用，不是对象自己引用自己；
  - 4. 处理对象，和数组， 直接用  new value.constructor(value) 构造一个空的，遍历原来的然后逐个赋值
  - 5. hasOwnProperty,  注意写法，驼峰

```
  let instance = new value.constructor; // new Object / new Array
  hash.set(value, instance); // 将拷贝前的和拷贝后的做一个映射表, 避免循环引用
  for(let key in value){ 
      if (value.hasOwnProperty(key)){ // 不拷贝原型链上的属性
         instance[key] = deepClone(value[key], hash);
      }
  }

```

```
// 简版：

const deepClone = (obj, hash = new WeakMap()) => {
    if (typeof obj !== 'object' || obj === null) {
        // 基本类型直接返回
        return obj;
    }

    // 检查循环引用
    if (hash.has(obj)) {
        return hash.get(obj);
    }

    // 初始化新对象或新数组
    const newObj = Array.isArray(obj) ? [] : {};
    hash.set(obj, newObj);

    // 递归拷贝数组或对象的每一项
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = deepClone(obj[key], hash);
        }
    }

    return newObj;
};



```




- 数组转树
  -  第一次遍历， 把数据存在搞成 id与值 的映射对象里，以便能拿到任意一个父节点
   - 第二次遍历， 把每一个有父亲的放在其父亲的children数组里

```
    parent.children= parent.children || [];
    parent.children.push(item)
```


- 实现compose：f(g(h(x))) 多个函数连续执行的形式转换为 compose(f, g, h)(x) 形式 ; 将多个函数组合成一个函数，这个函数接受一个函数后，将会依次执行内部函数；
  - 1. compose 函数接受多个函数作为参数，并返回一个新的函数： 
  - 2. 新的函数接受一个参数 arg，然后使用 `reduceRight` 方法从右到左依次调用传入的函数，将每次调用的结果作为下一个函数的输入。
  - 3. 核心代码：  `funcs.reduceRight((p, fn) => fn(p), arg)`， acc 第一次为传入参数，后面就是表示之前的函数执行结果


- 函数柯里化: 一个接受多个参数的函数， 转换为一系列接受单一参数的函数的技术，比如实现一个add加法：满足如下预期， add(1, 2, 3)(4) = 10， add(1)(2)(3)(4)(5) = 15;
  - 1. 内部函数，每次调用会收集参数，返回原函数： 

```
const sum = (...moreArgs) => {
        args = args.concat(moreArgs);
        return sum;
};

```
 - 2. 需要输出结果时，只需要把收集的参数综合处理一下：  `sum.toString = () => args.reduce((acc, cur) => acc + cur, 0);`
   - 因为执行sum每次返回的是sum函数，如果想实现 '==' 效果， 就需要涉及到js的隐式转换；使用的时候用 '+', '==' 触发一下隐式转换；
 - 3. 最后返回sum
 - - 隐式转换：在需要将对象转换为原始值时，JavaScript 会首先尝试调用 valueOf，如果结果不是原始值或 valueOf 不存在，就会调用 toString。所以上面toString 换成valueOf 也是一样的; 



- 实现 JSON.stringify： 在面试中实现 JSON.stringify 通常需要你展示对 JavaScript 数据类型和递归的理解，通常需要考虑基本类型，数组，和对象几种情况；（复杂的类型：函数，Symbol， Date等类型可以不用考虑）
  - 基本类型：null、undefined、boolean、number、string， 
    - undefined特殊点，直接返回undefined；
    - string 也特殊点，需要在外层加一层引号
    - 其余 boolean、number， null直接转为字符串
  - 数组类型： 递归处理值，拼接字符串, `[${arr.join(",")}]`
  - 对象类型： 递归处理值， 拼接字符串，
    - Object.keys(value).map(...) 
    - ``"${key}":${keyValueString}`, `{${properties.join(",")}}`
  - 复杂情况的处理： 对于引用类型，需要处理循环引用，只需要判断有没有处理过值即可，所以用new WeakSet()
    - 如果弱集合中有值，说明有循环应用，则抛错，否则把值加入到弱集合里
  
  ```
  if (seen.has(value)) throw new TypeError("circular error");
  seen.add(value);

  ```

 



- 对象key 点. 结构变成层结构（嵌套的对象扁平化）： {a: {b : {e: 11 }}} 转换为 {a.b.e: 11} 这种结构
  - 类似收集多叉树的叶子节点路径，如果节点不是对象则开始收集

- 反过来， 将一个扁平化的对象（键是通过点 . 连接的路径）转换回嵌套的对象结构: {a.b.e: 11} 转换为 {a: {b : {e: 11 }}}
  - 先拆分出key,value
  - 将key按'.',拆分成数组， 然后用reduce收敛，
    - 当前为如果是路径的最后一个部分 `index === keys.length - 1`，赋最终值
    - 否则,如果不是最后一部分，并且`没有被赋值过，则赋值为一个空对象 {}`, 有赋值过，就是处理过的，就不用管


- 并发控制: 任务池用集合方便删除
  - tasks循环开始，（promise）任务逐个放入任务池集合 new Set(): pool.add(taskPromise)
  - 任务执行完毕, 从任务数组移除： pool.delete(taskPromise)
  - 当任务池满了 pool.length === max ，就用 Promise.race等（await）一下



- express 中间件机制：

```
// 核心原型就是dispatch 里的三句，是compose 的固定写法需要记下来, 这就是中间件能够顺序执行的关键
compose = (layers) => {  
    const dispatch = (i) => {
      // 1. 终止条件
      if(i===layers.length) return; 

      // 2. 取出当前函数
      const fn = layers[i].cb;  

      // 3. 执行函数，并传入 下一个函数 作为参数
      return fn(()=>dispatch(i+1)) 
    }
    dispatch(0)
}

```

- require实现简写 

关键点： 

1. *node 中一般路径都用绝对路径*；因为相对路径，相对的是工作目录（执行node指令的位置）
2. fs 模块中， readFile, *readFileSync， 默认读取文件是buffer，加第二个参加编码，才是字符串*
3. new Function(), Function 的最后一个参数才是函数体，之前的参数都是函数的形参（字符串）： ('arg1', 'arg2', ..., functionBody)
4. new Funcion 并不会从上级作用域继承任何东西，它运行在全局作用域中；所以运行函数时，需要拼接字符串将 exports, module.exports 等传入
5. *提前定义好module, 最后返回module.exports 就行*，并不需要res；因为在node中，我们导出的（存储的）是module.exports(引入的也是module.exports), 而不是模块运行的结果，可能我们导出的就是一个函数
6. 由于node模块是运行在独立的作用域中,为提供一个相对隔离的环境（沙箱环境：避免全局变量污染，提高代码安全性，不影响其他代码），*使用的是vm.runInThisContext*, 而不是new Function 实现； 如果要给沙箱环境传入变量需要用vm.createContext()；
7. vm.runInThisContext，用于在当前的全局上下文中执行一段 JavaScript 代码，类似于在当前作用域中直接执行代码，类似eval，但是更安全
  - 1. eval() 直接在当前的词法作用域中执行代码，能够访问和修改作用域中的变量，会有污染
  - 2. vm.runInThisContext() 不能直接访问当前作用域的变量，因为它在一个隔离的执行环境中运行，运行在全局作用域中 ，但你可以通过参数传递的方式让执行的函数访问到你需要的变量
8. 在我们自己写require 里是没有__dirname, __filename 等模块默认传入的参数的，不过这不是重点，而且处理起来比较麻烦，一般直接用path.resolve 处理就好,然后注意启动项目的时候再当前目录就好了；

步骤：
1. 解析绝对路径
2. 读取缓存，如果有就返回缓存结果
3. 更新缓存
4. 加载模块，返回module.exports

```
const path = require('path');
const fs = require('fs');
const vm = require('vm');


const cache = {};
const req = (filePath) => {
  // 解析路径
  const id = path.resolve(filePath);
  const __filename = path.basename(id);
  const __dirname = path.dirname(id);
  
  // 读取缓存
  if(cache[id]){
    return cache[id].exports;
  }

  // 更新缓存
  const module = {
    id,
    exports: {}
  };
  cache[id] = module;

  // 加载模块
  const content = fs.readFileSync(id, 'utf8');
  const fnStr = `(module, exports, require, __dirname, __filename) => {${content}}`;
  const fn = vm.runInThisContext(fnStr);
  fn(module, module.exports, req, __dirname, __filename);
  return module.exports;
}

console.log(req('./test/index.js'));



```

- 手写events:事件触发器
  - 先写基本版， 面试官问，再写特殊场景的处理； 不然显的像是在背题;

1. on 绑定就是push到事件数组;
2. off移除就是把绑定函数从事件数组里过滤掉
3. emit发射就是把事件数组里的绑定函数依次执行，*同时要带上参数*, 触发事件时传参
4. on, once 绑定操作不需要传参，不可能绑定函数的时候就把参数固定了;*emit， wrapper 触发事件时才需要传参*,这样才能保证传参的灵活性;
5. once 绑定的是内部自定义的wrapper, 在*wrapper 直接执行once传入的监听函数就行了*, 执行完后off移除wrapper;
6. *once 绑定后，怎么手动移除，是个难点*； 无法直接移除，因为绑定的是内部自定义的wrapper,不是传入的fn， ,所以要想办法利用传入的fn作为标识移除掉wrapper;
   

```
class EventEmitter {

  store = {}

  on = (name, fn) =>{
    this.store[name] = this.store[name] || [];
    this.store[name].push(fn);
  }

  off = (name, fn) => {
    if(!this.store[name]) return;
    this.store[name] = this.store[name].filter(listener=>{
      return listener != fn && listener.fn != fn;
    })
  }

  emit = (name, ...params) => {
    if(!this.store[name]) return;
    this.store[name].forEach(listener=>{
      listener(...params)
    })
  }

  once = (name, fn) => {
    const wrapper = (...params) => {
      fn(...params);
      this.off(name, wrapper)
    }
    wrapper.fn = fn; // 这是处理是秀技操作，处理特殊场景，可以先不写，等面试官问到再写；

    this.on(name, wrapper)
  }
}

```

## 封装

### 如何封装axios, 主要关注哪些方面


- 封装axios： 从axios实例的基础配置，请求拦截器，响应拦截器 ，三块去想；许多成熟的 axios 封装库会侧重于请求拦截、错误处理等通用功能， 而 loading 通常会交给业务逻辑去实现，因为它是一个 UI 逻辑
  - 统一基础配置： 先创建一个axios 实例`axios.create({...})`，然后做一些基础配置
    - 超时时间timeout： 设置请求超时时间
    - 基本路径baseURL： 根据项目环境（环境变量，开发、测试、生产）设置请求基本路径
    - 请求头headers：配置一些基本请求头,如 `'Content-Type': 'application/json'`
  - 特殊配置：基于基础配置封装一个特殊的请求，比如cancelRequest， 创建一个可取消的请求函数
    - 取消请求：维护取消请求token, 在页面切换时通过导航守卫，可以取消上一个页面中正在发送的请求
      - axios.CancelToken, 可以取消请求， 底层调用的是xhr.abort() 中断请求; 它的回调会传一个取消请求的函数，拿到这个函数导出，用户再需要的时候，执行就行了；
  - 请求拦截器 ： *用户登录和退出前后，token 会更新，所以不能放在基础配置里，基础配置是静态的*；
    - 设置请求拦截，统一添加token
      - 可以从 localStorage 或 cookie 中读取token，统一加在 Authorization 中
  - 响应拦截器
    - 设置响应拦截
      - 处理 HTTP 状态码：根据业务约定，处理不同状态码逻辑（如 401 未授权跳转登录）
      - 封装统一响应数据格式：将后端数据格式化为前端易用的格式，减少业务代码重复
      - 全局错误提示：在错误情况下显示提示信息
  - 封装时错误捕获的处理，业务组件里需要处理错误么? 
   -  1. 所有 HTTP 层面的错误，这些通常在 Axios 的响应拦截器中进行统一处理
   -  2. 统一在 Axios 层面处理业务错误： 前后端约定好统一业务错误标识字段标识，比如 code，xios 拦截器解析 code，如果 code !== 0，认为是业务错误，统一进行处理或抛出
   -  3. 业务代码专注于正常结果的处理：业务代码默认只处理 code === 0 的场景，而不用担心其他问题
  

```

// 创建一个可取消的请求函数
const createCancelableRequest = () => {
  let cancel;

  const request = (url, config = {}) => {
    if (cancel) cancel('Request canceled by the user.');
    return axios({
      ...config,
      url,
      cancelToken: new axios.CancelToken((c) => {
        cancel = c;
      }),
    });
  };

  const cancelRequest = (message = 'Request canceled.') => {
    if (cancel) cancel(message);
  };

  return { request, cancelRequest };
};

// 使用封装的函数
const { request, cancelRequest } = createCancelableRequest();

// 发起请求
request('/search', { params: { q: 'apple' } })
  .then((response) => console.log('Search results:', response.data))
  .catch((error) => {
    if (axios.isCancel(error)) {
      console.log('Request canceled:', error.message);
    } else {
      console.error('Request failed:', error);
    }
  });

// 用户主动取消请求
setTimeout(() => {
  cancelRequest('Search aborted by user.');
}, 2000);


```

## 如何进行组件封装

从目标，要点，示例，三个方面去说：

- 目标： 封装组件的目标是提高 *复用性、灵活性 和 可维护性*，并确保组件*易用且性能良好*

- 要点： 封装组件的关键要点
  - 1. 复用性，和灵活性：
    - 灵活性：通过 灵活的props，事件回调，合理的默认值 保证灵活性，通过 如插槽或 children 保证持扩展性， 让组件可以适应不同场景
  - 2. 可维护性： 
    - 1. 单一职责：组件只完成一个功能，避免过多职责耦合。
      - 这样做能让你更容易地对某一部分进行修改、调试和优化，而不需要担心影响到其他部分。
    - 2. 清晰的 API 和文档：为组件提供易懂的 API 说明，并保持一致的命名规范，方便团队成员维护和扩展
    - 3. 样式隔离：使用模块化的 CSS 或动态类名，避免样式污染。
  - 3. 性能优化： 避免不必要的渲染（如 React.memo 或 computed）


## 实践类

- 图片懒加载：
  - 在用户实际需要显示图片时才加载图片，以减少页面初始加载时间，原理：
    - 初始状态：页面加载时，图片不会立即加载，而是使用占位符（如空的 src 或低分辨率图片）代替真实图片。
    - 检测图片位置：当用户滚动页面时，检测图片是否即将进入视口 
    - 加载图片： 一旦检测到图片即将进入视口，立即加载真实图片，将图片的 src 属性设置为实际图片的 URL。
  - 常见方法： IntersectionObserver、loading="lazy" 属性、滚动事件监听等
    - IntersectionObserver： 一个现代浏览器 API，允许你检测元素是否在视口中，从而实现懒加载。
    - loading="lazy"： HTML5 提供了原生的 loading="lazy" 属性，可以直接在 img 标签上使用，实现懒加载。
    - 滚动事件监听： 滚动事件频繁触发,性能相对较差 （具体js盒子，不常用，忘了，就不用说）


- 设计一个Modal组件，要求与解法：
  - 1. 默认渲染在body下，保持单例
  -  1. ReactDOM.createPortal 用于将 Modal 渲染到 body 下
     - createPortal(children, domNode, key?); createPortal 允许你将 JSX 作为 children 渲染至 DOM 的不同部分。
  -  2. 为了实现单例模式，可以使用一个全局的管理器（例如使用一个闭包或单例类）来管理 Modal 的实例。每次调用创建 Modal 时，检查是否已有实例，如果有则返回已有实例
 - 2. 实现遮罩效果，点击遮罩能够触发onCancel方法 
  - 1. 定位absolute，或者fixed
  - 2. 通过 stopPropagation 阻止事件冒泡, 防止点击 Modal 内部关闭 Modal

    
  ```
    // 核心结构
    <div className="遮罩层" onClick={onClose}>
      <div className="弹窗" onClick={(e) => e.stopPropagation()}>
        {children}
      </div>
    </div>

  ```

 ```
  // 遮罩样式， 半透明，覆盖全屏，高层级
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5); /* 半透明黑色 */
    z-index: 1000; /* 确保遮罩在前 */
  }

  // 弹窗
  .modal-content {
    正常样式
  }

 ```



 - 3. 窗口居中，面板大小不固定; 
   - 居中样式处理
- 4. 可以自定义header和footer；  
   -  怎么在footer内获取，model内部content表单数据；
     - 1. refs： 在 React 中，你可以使用 useRef 或者 React.createRef() 来获取表单组件的引用，然后在 footer 内的按钮点击事件中通过这个 ref 获取表单的数据。
     - 2. 通过状态提升： 可以把表单的状态提升到 Modal 组件的父组件中，然后通过 props 把状态和操作函数传递给 footer


- 实现虚拟滚动列表：10万条数据
  - 1. 使用 虚拟列表（Virtual List） 技术，仅渲染可视区域内的 DOM 节点，其余数据通过占位符模拟
    - 动态渲染数据：监听滚动事件，根据滚动位置计算当前需要渲染的条目范围，并更新 DOM。
      - 在虚拟列表中，list 需要通过 translateY 来模拟完整列表的滚动效果，从而让用户感知到滚动条和显示内容是同步的
        - const scrollTop = container.scrollTop： 计算滚动容器已经滚动距离（获取当前滚动条滚动的偏移量，用于计算当前可见的数据范围）
        - startIndex = Math.floor(scrollTop / itemHeight); // 计算当前显示数据的起始索引， itemHeight为单条数据高度（确定当前滚动位置对应的可视区域数据起点）
        - startOffset = startIndex * itemHeight; // 当前起始偏移量
        - list.style.transform = `translateY(${startOffset}px)`  // 设置渲染区域的偏移
        - renderList(startIndex); // 渲染可视区域内的数据
  - 2. 如何滚动条滚动效果的和真实有十万条数据时一样
    - 使用占位容器：设置总高度为 10万条 * 单条高度，以确保滚动条长度和真实数据一致。

  ```
  // html 结构

  <div id="container">
    <div id="spacer"></div>
    <div id="list"></div>
  </div>


  // 解释： 
  1. container定高的容器，也就是渲染的可是区域，内容超出可以滚动； overflow-y: auto;
  2. spacer （10万条数据）内容的实际高度占位，给一个相对定位： relative
  3. 实际渲染的数据（比如10条数据），绝对定位到spacer 上；

  ```


## 纪要

- 2024：

8.8 一面刷题，复习完一遍
9.3： 过了第二遍，并且收录到必背内容里，短期内无需复习
11.14： 3天时间（没有用全力），手写，仔细过了第三遍，下一遍复习，如果需要的话，可在两个月后，也是1月后
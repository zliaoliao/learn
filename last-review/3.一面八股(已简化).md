
一二面基础知识八股

## 自我介绍话术稿


## 看源码的思路

1. 源码先看广度，核心逻辑（先看整体流程，而不是冲着一个方法都看完）
2. 掌握整体流程后，再去看感兴趣的方法或者功能


## ajax

onreadystatechange 事件：每当 readyState 改变时，就会触发 onreadystatechange 事件。

readyState 属性存有 XMLHttpRequest 的状态信息。 （0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪）

```
let xhr = new XMLHttpRequest();//=>创建AJAX实例
xhr.open('GET', 'json/product.json', false);
xhr.onreadystatechange = () => {
    if (xhr.readyState === 4 && xhr.status === 200) {
        productData = xhr.responseText;
    }
};
xhr.send(null);

xhr.open ://=>打开一个请求的地址(一般地址都是服务器提供好的,会给我们一个API接口文档),最后一个参数是设置同步还是异步(FALSE:同步 TRUE:异步),真实项目中最常使用的是异步,我们今天为了简单使用同步  [地址是相对于html文件的地址]

```


## http


#### GET VS POST

1.  \[传递给服务器信息的方式不一样]

get 是基于url地址问号传参的方式把信息传递给服务器， POST是基于“请求主体”把信息传递给服务器

2.【GET不安全，POST相对安全】

因为GET是基于‘问号传参’把 信息传递给服务器的，容易被骇客进行url劫持，POST是基于请求主体传递的，相对来说，不好被劫持：所以登录、注册等涉及安全性的交互操作，我们都应该用POST请求

3.【GET会产生不可控制的缓存，POST不会】

不可控：不是想要就要 ，想不要就不要，这是浏览器自主记忆的缓存，我们无法基于JS控制，真实项目中我们都会把这个缓存干掉

GET请求产生缓存是因为： 连续多次向相同的地址（并且传递的参数也是相同的）发送请求，浏览器会把之前获取的数据从缓存中拿到返回，导致无法获取服务器最新数据（POST不会）

解决方案：

> xhr.open('GET', `/temp/list?lx=1000&=_${Math.random()`);//保证每次请求的地址不完全一致：在每次请求的末尾追加一个随机数即可（使用\_作为属性名，就是不想和其他的属性名冲突


### http 请求数据格式

一般来说，前端在进行Post请求的时候会根据场景发送不同类型的数据，该Post请求头的Content-Type字段必须声明相应的数据类型，比如说application/x-www-form-urlencoded、application/json、multipart/form-data等，根据实际应用，有时候会需要请求时来手动设置，不过大部分情况下浏览器会根据Body中的数据来自发的设置相应的请求头。

表单提交类数据格式：

表单只包含基于文本的输入组件（例如输入框、单选框等），浏览器会将这些数据以 key=value 的形式组织，使用一种被称为 application/x-www-form-urlencoded 的 Content-Type 传输。

如果表单中包含文件或图片等不能被编码成文本的元素，浏览器就会使用 multipart/form-data 向服务器传输数据。


#### HTTP网络状态码（status)\$

根据状态码能够清楚的反映出当前交互的结果及原因

200   0k    成功

301 Moved Permanently 永久转移（永久重定向）
用于： 域名更改，访问原始域名重定向到新的域名

302 临时转移（临时重定向 => 307)
> 302一般用做服务器负载均衡，当一台服务器达到最大并发数的时候，会把后续访问的用户临时转移到其它的服务器机组上处理
> 偶尔真实项目中会把所有的图片放到单独的服务器上‘图片处理服务器’，这样减少主服务器的压力，当用户向主服务器访问图片的时候，主服务器都把它转移到图片服务器上处理
307用于：网站现在是基于https协议运作的，如果访问的是HTTP协议，会基于307重定向到HTTPS协议上


304  Not Modified   设置缓存

对于不经常更新的资源文件，例如： CSS、JS/HTML/IMG等，服务器会结合客户端设置304缓存，第一次加载过的这些资源就缓存到客户端了，下次在获取的时候，是从缓存中获取： 如果资源更新了，服务器会通过最后修改时候来强制让客户端从服务器重新拉取，基于ctrl+f5,强制刷新，304的缓存就没用了

400 Bad Request  请求参数错误
401 Unauthorized  未登录
403 无权限
404 Not Found  找不到资源（地址不存在）
405 请求方法不允许
413 Request  Entity  Too large 和服务器交互的内容资源超过了服务器最大限制

500 Internal Serval Error 未知的服务器错误
503 Service Unavailable  服务器超负荷

#### HTTP 报文

起始行 ： 请求起始行、响应起始行 首部（头）： 请求头、响应头、通用头 主体： 请求主体、响应主体

General 通用头

Request URL: <http://www.zhufengpeixun.cn/?ref=qipaoxian>  请求地址
Request Method: GET   请求方式
Status Code: 304 Not Modified  状态码
Remote Address: 162.159.211.54:80
Referrer Policy: unsafe-url
Request Header 请求头 【客户端设置，服务器接收】

GET /?ref=qipaoxian HTTP/1.1   => 起始行（描述当前请求的一些基本信息:用的是1.1版本协议传输的
Host: [www.zhufengpeixun.cn](http://www.zhufengpeixun.cn)
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Referer: <http://bzclk.baidu.com/adrc.php?t=06KL00c00f7t5k_04Jku0AWEC6j230PU000000wC97b00000x2UCX1.THLylUx-kXjwVfK85yF9pywd0ZnqrHfduyPhuyRsnj0zmhwBr0Kd5RcdPYmvrRn1PDRkPDRsfWTLnRD3fHwjfRwjrRcsnRwj0ADqI1YhUyPGujY1njTsnW0zrj6LFMKzUvwGujYzn0K-5y9YIZ0lQzqLILT8Xh9duhN8uLK-pg9dUB4WUBtOThNh5g7GTA7EXA-9U6KWThnqnWTYPWb&tpl=tpl_10729_14918_9833&l=1501849604&ie=utf-8&f=8&tn=baidu&wd=%E7%8F%A0%E5%B3%B0%E5%9F%B9%E8%AE%AD&oq=%25E5%25A4%25A9%25E7%258C%25AB&rqlang=cn&inputT=5095>
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: \_\_root\_domain\_v=.zhufengpeixun.cn; \_qddaz=QD.iic5qg.6qqooy.jf9po4f1; pgv\_pvi=5645880320; tencentSig=7489029120; AUI\_EC=%7B%22SA%22%3A%2216619913396%22%7D; Hm\_lvt\_5ca1e1efc366a109d783a085499d59d9=1525448900; \_\_cfduid=ddd5304498715d659191a950b0a6e6e741526980814; Hm\_lvt\_418b1c90fa35dc210dd5d2284d9f9f29=1525448900,1526980818; Hm\_lpvt\_418b1c90fa35dc210dd5d2284d9f9f29=1526980818; \_qdda=3-1.17zv7v; \_qddab=3-r1khsq.jhhgycbn; IESESSION=alive; \_qddamta\_2852156370=3-0; pgv\_si=s4585888768; \_qddamta\_4001806960=3-0
If-Modified-Since: Sun, 06 May 2018 10:02:42 GMT
Response Headers 响应头【服务器端设置，客户端获取】

HTTP/1.1 101 Switching Protocols  => 响应起始行（http状态码）
Date: Tue, 22 May 2018 09:20:39 GMT  => 服务器响应内容时候的’服务器端事件’（客户端获取这个时间的时候已经和真实的时间产生误差了，因为服务器返回内容到客户端接收到，也是需要时间的），并且这个时间是格林尼治时间（比北京时间慢8小时，北京时间是GMT+0800）
Connection: upgrade
Server: tws   // => 管理web服务的工具
Upgrade: websocket
Sec-WebSocket-Accept: yjVxiZDTk3+wKYra6xhoQpxIj2E=
Sec-WebSocket-Extensions: permessage-deflate
Response Payload / Form Data \[响应主体]


##  性能优化

性能优化，简单来说就是要够快，够流畅，页面打开快，交互响应快，流畅无卡顿。当然也不是说单一指标就能衡量的，是多方面的贴合性能模型才比较好。

### 如何进行性能优化？

1. 首先需要了解性能指标，多快算快
2. 使用专业的工具可量化的评估出网站或者应用的性能表现
3. 然后立足于网站页面响应的性能周期，分析出造成较差性能表现的原因
4. 最后进行技术改造，可行性分析等具体的优化实施
5. 迭代优化

多快算快？

性能指标很多，有一些关键指标，业界有不少性能模型：

比如google 提出来的rail性能模型；
还有基于用户体验的具体的指标方案，也是google提出的；

rail性能模型: 就是response, animation, idle, load, 模型。 

响应：希望100ms内响应用户输入（不一定立即要结果，要有及时的交互提示）；
动画：展示动画的时候每一帧在16ms以内进行渲染，避免卡顿（也就是每秒60帧）；
空闲：空闲的时间留多一点，每个代码片段控制在50ms以内执行完，这样就可以及时释放js主线程，以进行用户交互；
加载： 应该控制在1s之内（网络好的时候，3g慢网下5s内）完成网站的加载，并可以进行用户交互


基于用户体验的具体的指标方案（一些比较重要的指标）： 

FCP(first content paint，也就是通俗说的白屏时间)： 浏览器首次绘制来自dom的内容的时间，内容包括文本，图片，canvas, 等；白屏时间控制在2s以内；（2s内好，2s到4s中等，4s上差）；【这时候内容不一定是完整的，第一次有内容】

LCP(Largest Contentful Paint): 可视区域最大元素呈现在屏幕上，用以估算页面主要内容对用户可见时间，一般是图片啥的（应该控制在2.5s内）【页面最终加载出来时，整个页面的最大内容，视觉上的最大内容】（2.5s内好， 2.5到4中等， 超过4慢）


FID(First Input Delay): 首次输入延迟，从用户第一次与页面交互（如点击链接，按钮，常见表单元素）到浏览器时间能够响应该交互的时间（也就是从看到可交互的东西到真正可交互的时间）。输入延迟是因为浏览器主线程正在忙于做其他事情（比如，解析和执行应用程序加载的大量计算的js）,所以不能响应用户。（100ms内好， 100ms到300ms中等， 300ms上差）
> 第一次输入延迟通常发生在第一次内容绘制（FCP）和可持续交互时间（TTI）之间，因为页面已经呈现了一些内容，但还不能可靠地交互。

TTI(Time to Interactive) 表示网页第一次完全达到可交互状态的时间点（可流畅交互，持续交互）。完全达到可交互状态的时间点是在最后一个长任务（long task， 需要50ms以上才能完成的任务）完成的时间,并且在随后5s内网络和主线程式空闲的。（3.8s内好，3.9到7.3中等，7.3以上差）

TBT(Total Block Time)总阻塞时间，度量了FCP到TTI之间的总时间，在改时间范围内，主线程被阻塞足够长的时间以防止输入响应。只要存在长任务，该主线程就会被视为阻塞，浏览器就无法中断正在进行中的任务，因此，用户如在在长任务时间范围内与页面交互，则浏览器必须等待任务完成才能响应。页面总阻塞时间，是FCP到TTI之间发生的每个长任务的阻塞时间的总和（每个长任务超出50ms那一部分的总和）。（300ms内好， 300到600中等，600ms以上差）

CLS(Cumulative Layout Shift): 累计布局偏移，CLS会测量整个页面生命周期中，发生的每个意外的布局移位，得到所有布局移位的分数总和（比如开始出现按钮的位置，突然出现别的元素，布局抖动，比如你想点一个链接手指落下的瞬间链接移动了，你点到别的元素），它是一种保证页面视觉稳定性从而提升用户体验的指标方案。（布局偏移，通常是由于异步加载资源或将dom元素动态添加到现有内容的上方时发生的，罪魁祸首可能是尺寸未知的图片，视频，字体等）（抖动时间再0.1s以内是好的，0.1到0.25中等，超过0.25 慢）


上面的指标有些都了，google 为了降低学习成本，提出web vitals, 为网站体验提供了一组统一的质量衡量指标，其中包括加载体验，交互性，视觉稳定性，把上面指标简化提取为， LCP, FID, CLS, 也就是说把这三个指标做好了，网站性能相对就可以了；


性能工具可选择：

1. 浏览器DevTools调试工具里的网络监控分析，性能监控分析。（主要是performance 测试运行中的性能, 也可以测首屏，可以结合network，不过最终是需要自己去分析的，没有建议）

2. lighthouse(灯塔):网站整体质量评估并给出优化建议， 会基于上面的FCP, LCP等指标，打分，还会诊断报告和一些参考建议， 就可以针对性去优化（这个已经内置到浏览器DevTools里，一般测首屏比较合适）

3. webPageTest: 多测试地点（比如香港，北京），全面的性能报告，是一种在线的云端测试，输入网址网址







性能优化从两个层面来说：

1.  代码层面 + 有利于扩展维护
2.  http层面

### 代码层面

1. 减少回流（reflow）和重绘（repaint）， vue,react， 它们的使用虚拟dom，也有效的减少了重绘和回流（类似一种分离读写）
2. 尽量使用CSS3动画代替JS动画，因为CSS3的动画或者变形都开启硬件加速，性能比JS动画好
3. 编写JS代码的时候尽可能使用设计模式来构建体系，方便后期的维护，也提高了扩充性等
4. 事件委托： 在做DOM事件绑定的时候，尽量避免一个个的事件绑定，而是采用性能更高的事件委托来实现（减少dom的频繁操作，其中包括给每一个dom元素做事件绑定）

### http 层面

减少HTTP请求的次数或者减少请求数据的大小

> 页面中每发送一次HTTP请求，都需要完成请求+响应这个完整的HTTP事务，会消耗一些时间，也可能会导致HTTP链接通道的堵塞，为了提高页面加载速度和运行的性能，我们应该减少HTTP的请求次数和减少请求内容的大小（请求的内容越大，消耗的时间越长）

1. 采用CSS雪碧图(CSS Sprit/CSS图片精灵)技术，把一些小图合并在一张图上，使用的时候通过背景图片定位，定位到具体的某一张小图上,使用字体图标代替一些页面中的位图（图片），这样不仅做适配的时候方便，而且更加轻量级，而且减少了HTTP请求次数（类似于雪碧图）
2. 把CSS或者JS文件进行合并压缩；尤其是在移动端开发的时候，如果CSS或者JS内容不是很多，我们可以采取内嵌式，以此减少HTTP请求的次数，加快页面加载速度;
> 1. CSS合并成一个，JS也最好合并成一个
> 2. 通过一些工具（例如：webpack）把合并后的CSS或者JS压缩成xxx.min.js，减少文件大小
3. 采用图片懒加载技术，在页面开始加载的时候，不请求真实的图片地址，而且是用默认图占位，当页面加载完成后，在根据相关的条件依次加载真实图片（减少页面首次加载HTTP请求的次数）
> 真实项目中，我们开始图片都不加载，页面首次加载完成，先把第一屏幕中可以看到的图片进行加载，随着页面滚动，在把下面区域中能够呈现出来的图片进行加载
> 根据图片懒加载技术，我们还可以扩充出，数据的懒加载
> 1）开始加载页面的时候，我们只把首屏或者前两屏的数据从服务器端进行请求（很多大网站（例如： 京东、淘宝）首屏内容都是基于服务器端渲染的，客户端获取xml数据后直接呈现，增加页面第一次打开速度，而剩下屏中的内容都是基于ajax获取数据，在客户端进行数据拼接渲染的...）
> 2）当页面下拉，滚动到哪个区域，在把这个区域需要的数据进行请求（请求回来做数据绑定或者以及图片延迟加载等）
> 3）分页展示技术采用的也是数据的懒加载思想实现的：如果我们请求获取的数据是很多的数据，我们最好分批请求，开始只请求第一页的数据，当用户点击第二页（微博是下拉到一定距离后，再请求第二页数据...）的时候在请求第二页数据...

4. 对于不经常更新的数据，最好采用浏览器的304缓存做处理（主要由服务器端处理）
> 把一些不经常更新的静态资源文件做缓存处理（例如： JS\CSS、静态图片等可以做缓存） 例如： 第一次请求CSS和JS下来，浏览器会把请求的内容缓存起来，如果做了304处理，用户再次请求CSS和JS，直接从缓存中读取，不需要再去服务器获取了（减少了HTTP请求大小）
> 当用户强制刷新页面（CTRL+F5）或者当前缓存的CSS或者JS发生了变动，都会从新从服务器端拉取
> ... 对于客户端来讲，我们还可以基于localStorage来做一些本地存储，例如：第一次请求的数据或者不经常更新的CSS和JS，我们都可以把内容存储在本地，下一次页面加载，我们从本地中获取即可，我们设定一定的期限或者一些标识，可以控制在某个阶段重新从服务器获取

5. 如果当前页面中出现了AUDIO或者VIDEO标签，我们最好设置它们的preload=none:页面加载的时候，音视频不进行加载，播放的时候在开始加载（减少页面首次加载HTTP请求的次数）
> preload=auto：页面首次加载的时候就把音视频资源进行加载了 preload-metadata：页面首次加载的时候只把音视频资源的头部信息进行加载 ...

7. 采用CDN加速(重量级加速，烧钱机器)
> 地域式服务器分布，在热门地域附近设置服务器组，附近的用户访问的都是离其最近的机组（提高访问速度）

## 缓存

### 强缓存

实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200

```
Expires: Wed, 22 Oct 2018 08:41:00 GMT

```

Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

```
Cache-control: max-age=30
```
Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。

### 协商缓存

如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。

协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式:

1. Last-Modified 和 If-Modified-Since

Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。

2. ETag 和 If-None-Match

ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高

### 选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

> 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
> 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
> 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。


## 跨域

### jsonp

JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。

script标签不受浏览器同源策略的影响，可以通过src属性，请求非同源的js脚本数据。


```

1. 前端定义一个函数。

<script>
	function success(data){
        console.log("获取到数据");
        console.log(data)
    }
</script>

2. 通过script标签，请求接口数据。

<script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=silly&sge=20"></script>

3. 后端返回 函数字符串，把数据当参数传给函数， 前端请求拿到函数，会自动自行，就能获取数据


```

- jsonp 应用场景
  - webpack 中的懒加载场景原理就是jsonp, array push

### cors

CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败.浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息,因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

浏览器将CORS请求分成两类：简单请求和非简单请求。

只要同时满足以下两大条件，就属于简单请求。

```
（1） 请求方法是以下三种方法之一：
  HEAD
  GET
  POST

（2）HTTP的头信息不超出以下几种字段：

  Accept
  Accept-Language
  Content-Language
  Last-Event-ID
  Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

```

凡是不同时满足上面两个条件，就属于非简单请求。

1. 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。

GET /cors HTTP/1.1

Origin: http://api.bob.com

上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了.如果Origin指定的域名在许可范围内，服务器返回的响应

如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

Access-Control-Allow-Origin: 它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。

Access-Control-Allow-Credentials: 它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。


```
withCredentials 属性:

上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器, 需要

1. 要服务器同意，指定Access-Control-Allow-Credentials字段。
Access-Control-Allow-Credentials: true

2. 开发者必须在AJAX请求中打开withCredentials属性

var xhr = new XMLHttpRequest(); xhr.withCredentials = true;


否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。


```

2. 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。

除了Origin字段，"预检"请求的头信息包括两个特殊字段。

（1）Access-Control-Request-Method

该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。

（2）Access-Control-Request-Headers

该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。


## 如何减少预检请求options

- 使用缓存： 利用Access-Control-Max-Age 响应头来控制预检请求的缓存时间；

## async, await  原理


#### 浏览器事件环

js是主线程是单线程的，在执行环境中执行是从升到下的执行， 如果遇到异步任务（比如定时器，事件，请求），会另外开启对应线程。

定时器会等时间到了后把定时任务放到队列里，主栈代码执行完毕后会把队列里的任务依次拿到主栈中执行；微任务也类似。

常见的宏任务： js渲染，ui渲染

代码第一次执行，肯定是宏任务先执行，因为script脚本是个宏任务， 执行过程中产生的宏任务会放进宏任务队列（宏任务成功后再放入宏任务队列，不是立刻放入），微任务会放进微任务队列（微任务立即放入微任务队列），主栈代码执行完后，先清空一遍微任务（清空微任务过程中产生的微任务会放进当前微任务队列）再执行一个宏任务（也就是执行下一个宏任务之前会先清空微任务队列，也可以说执行完一个宏任务清空微任务队列）。

微任务清空后会看一下，有没有达到页面的刷新时间，如果达到了会做一个gui界面的渲染（如果需要的话），整个过程是由事件触发线程用事件循环机制控制的， 然后再取下一个宏任务，如此循环。
> gui渲染并不属于事件环的一部分，只不过渲染的时机和事件环有一些联系

事件环可以理解为是死循环的，不停的去扫描

浏览器常见线程：

GUI 渲染线程

JavaScript 引擎线程
> js引擎线程和渲染线程 是互斥的， js线程优先

定时触发器线程(定时器就用这个计时的)

事件触发线程

异步 http 请求线程

#### node 事件环

1. 我们写的js代码交给v8引擎进行处理
2. 代码中可能会调用node api, node 会交给libuv库处理
3. libuv通过阻塞i/o和多线程实现异步i/o
   > 阻塞i/o，比如读文件，读完文件再返回
   > 多线程实现异步i/o, 比如同时读多个文件， 也就是说底层是通过多线程，来实现异步
4. 通过事件驱动方式，将结果放到事件队列里，最终交给我们的应用

node 11 后， node事件环表现形式就和浏览器一致了，执行过程有一些区别。

主栈代码执行完后，会有这么6个阶段（队列）：主要关注 定时器， 轮询，和 检测阶段的三个队列

- 定时器（timer）： 里面放setTimeout和setInterval的定时任务
> - 待定回调： 上一轮循环没执行完的i/o回调 (我们无法操作)
> - idle, prepare: 仅系统内部调用(我们无法操作)

- 轮询（poll）： 放i/o操作(放与i/o相关的回调，比如文件读写操作的回调函数，也包括数据库相关操作的回调)
> 如果检测阶段没有任务，代码逻辑还没执行完，会阻塞在这个阶段，等待定时器到达时间，或者新的i/o操作， 避免不停地循环查找。

- 检测（check）： setImmediate 回调函数将在此处执行
> 关闭回调函数： 一些准备关闭的回调函数，如： socket.on('close', ...)

在主模块中，先写一个0毫秒的定时器，setTimeout再写setImmediate，他们的执行顺序是不确定的，与电脑性能有关，
如果执行代码是定时器时间到了就会执行定时器，如果没到，就行继续走到检测阶段执行setImmediate。

但是如果在i/o操作的回调函数中去写这两个，执行顺序是确定的，因为i/o下一个阶段是检测setImmediate，所以会先执行setImmediate；


*如果有大量计算型的任务，它就不适合放在主线程执行，会阻塞主线程，可以通过setImmediate将其放在事件循环的checkeck阶段，因为代码在这个阶段既不会阻塞主线程，也不会阻塞循环。*

其余的大体执行顺序和浏览器差不多， 主栈代码执行完，便会清空微任务(微任务先执行)，然后取下一个宏任务，然后清空微任务，再继续。（定时器，轮询，检测阶段执行的都是宏任务）

*process.nextTick 是node自己实现用来替代promise的，是微任务，比promise 快，优先级高，就是会先执行process.nextTick，然后清空微任务队列*,希望任务不会阻塞主线程，又得尽快执行可以用这个。








## webpack的原理，webpack中如何实现事件的发布订阅的，如何开发一个webpack plugin or loader

## 用户权限

权限组合，组合后没有歧义; 读取 4， 写入 2, 执行 1； chmod -r 777
100
 10
  1
111  // 按位或，一个为1，就是1， 转换为10进制就是，7（也就是4+2+1），最高权限，可读可写可操作（权限的值是使用八进制进行计算）
权限组： 用户自己的权限，用户所在组的权限，其他人的权限， 比如0o666 表示三类用户都有读写权限（0开头是8进制）


## http

## 秘钥

秘钥是一种在加密和解密过程中使用的一段参数，用于改变加密算法的行为

对称加密：
- 对称加密使用的是同一把秘钥进行数据的加密和解密
- 优点：是加密和解密速度快，适合大量数据的加密和解密
- 问题：是秘钥的传播和管理，因为加密和解密使用的是同一把秘钥，这就需要在通信双方之间安全地分发这个秘钥。

非对称加密：
- 非对称加密使用一对秘钥，一把是公钥，一把是私钥。公钥进行加密的数据，只有配对的私钥才能解密。反过来，使用私钥加密的数据，只有公钥才能解密。
- 公钥是公开的，任何人都可以使用公钥进行加密。
- 非对称加密的优点是可以解决秘钥分发的问题，缺点是加密和解密的速度相比对称加密慢。
  
在实际的使用中，通常会将对称加密和非对称加密结合起来使用：
- 使用非对称加密来安全地传送对称加密的密钥
- 然后使用对称加密来进行数据的加密和解密
- 这样就既解决了密钥的分发问题，又能快速地加密和解密大量的数据。
- 这个确定对称秘钥的过程，也就是ssl握手的过程


### https

简单理解：https主要是要协商出一个对称加密的秘钥；

  
- 1. 服务端找第三方用私钥加密信息：服务端先将自己的公钥，域名，第三方机构名等信息发送给第三方（CA）机构，第三方用自己的私钥把这些数据加密，和明文放在一起（形成tsl证书），返回给服务端；（因为拿到公钥也没有用，因此可以用明文，只是防篡改）
- 2. 客服端找第三方用公钥解密信息：客户端收到信息先验证，用内置的公开的公钥对证书的密文进行解密，如果解密的结果和证书的明文一致，则通过验证。
- 3. 生成对称加密的传输秘钥： 浏览器生成一个随机数据，用服务器的公钥进行加密再发送给服务器，服务器用自己的私钥解密，如此双方就能得到一个同样的随机数据。如此，双方协商出对称加密的秘钥。
- 4. 用这个秘钥对信息进行加密传输

> 第三方用私钥加密，公钥解密
> 服务端用公钥加密，私钥解密
> 其实大概意思就是，传给别人的给公钥，自己留着私钥（留着更隐私的那个）；


详细过程如下：

- 前情历史：

在http访问的时候，数据在用户和网站之间流转，会经过很多个路由节点，很难保证不会出现窃听或者篡改数据的攻击者。

- 对称加密：最开始浏览器想到对数据加密再传输

  > 所以浏览器和服务器如何确定出一个同样的秘钥呢？如果有一方生成，再先以明文的方式传递过去，中间的攻击者自然也能轻松的拦截下来；后续加密也没有意义。

- 非对称加密： 于是人们想到了非对称加密， 用非对称加密传输对称加密的秘钥

- SSL 握手
  - 服务器先将自己的公钥发送给浏览器
  - 浏览器生成一个随机数据，用服务器的公钥进行加密再发送给服务器，服务器用自己的私钥解密
  - 如此双方就能得到一个同样的随机数据。这个随机数据便可以作为对称加密的秘钥，对真正要传输的数据进行加密传输。

> 在这个过程中即便攻击者拦截到服务器的公钥也没用，因为公钥无法解密由它自己加密的数据。

  *使用非对称加密协商出一个相同的秘钥，然后用这个秘钥进行对称加密传输正式数据。这就是https中s实现的大致原理* 

你会发现这是独立与http的流程，也被称之为安全套接字层SSL， 这个秘钥协商的过程也被称之为SSL握手。

- CA证书

为了避免攻击者在服务器传递给浏览器自己公钥的过程中把它拦截，并替换成自己的公钥再发送给浏览器。 
浏览器收到后，他无法知道这是被篡改过的，仍然用它来加密作为后续对称加密公钥的随机数据。
攻击者收到收到后，因为是被自己公钥加密的数据，所以自然可以用自己的似钥解密，得到明文，然后用服务器的公钥对其加密，再发送给服务器，
服务器用自己私钥的解密。
攻击者就想一个黑中介一样，两头骗，这样虽然通信双方协商出了对称加密的秘钥，但是攻击者也知道了，所以接下来的加密变的没有意义。

问题的根本在于，公钥并不能标明自己属于谁，所以解决的方式是让其具有表明自己身份的能力；

这需要引入一个第三方的角色，现在服务器除了自己的公钥之外，还把自己的域名，组织名，以及所申请的第三方机构名等信息放在一起，形成一个数据集合，然后拿着这份数据去找这个第三方机构，该机构也有一个公私钥对，用自己的私钥对这些数据进行加密，得到一个密文， 这被称之为签名，然后把签名数据和原始明文放在放在一起，发送给服务器的管理员，这就是所谓的TSL证书， 这个第三方机构也被称之为CA。

现在服务器传递给浏览器的不再是自己的公钥，而是这个能够表明自己身份的证书，浏览器拿到这个证书后，需要先进行验证而不是直接选择相信。方法也很简单，公开的公钥对证书的密文进行解密，如果解密的结果和证书的明文一致，则通过验证。然后从证书中提取出服务器的公钥，加密随机数据发送，双方协商出对称加密的秘钥。如果结果不一致则认为证书不合法。风险提示页面就该出现了。
> 这个过程和jwt优点像，加密后可防止内容被篡改

如此，原则上来说，中间的攻击者就再也没可能欺骗了。攻击者拦截并篡改的目的， 是为了让浏览器在秘钥协商时用自己的公钥，所以现在如果攻击者拦截到目标服务器的证书后，把其中的公钥改成自己的，那么浏览器收到后，解密签名结果中的公钥部分和篡改后的对不上，其中必有诈。

再比如攻击者在CA机构也申请一个证书，并在拦截之后将其替换为自己的证书，这样自己签名的结果和明文部分对的上是对的上，但是显然证书中的域名和浏览器正在访问的地址又对不上，其中也必然有诈。

于是再次使用非对称加密的证书机制，巧妙的解决了中间攻击者偷天换日的把戏。

> 这里CA机构就很关键，证书不能发错嘞，所以CA向申请者颁发证书时，需要仔细甄别申请者的身份，以避免把某个域名的证书发给了错误的人，办理人员通过比如官方邮箱，营业执照，域名登记信息等线上线下手段进行综合判断，所以目前很多CA机构颁发证书都是收费的，因为他们要为此付出 一定的精力，成为CA机构是一个门槛较高的事情，一般是有一定行业影响力的权威机构才堪当此任， 比如微软，谷歌，中国互联网信息网络中心等等，还有一些专门从事数据安全业务的公司。 这些机构原则上没有颁发非法或者错误证书的动机，这会给自己商业信誉带来巨大的负面影响。

但浏览器但浏览器怎么知道该信任哪些CA机构的证书呢，很简单： 内置；只有这些被系统或者浏览器内置的CA机构颁发的证书才能通过浏览器的验证，浏览器在内置这些CA机构的时候，也是经过慎重考察的。

到此，事情大约是得到了解决，但是你会发现CA机构责任过于重大的同时，权利也有点过于集中，以至于这种建立在信任上的安全显得十分脆弱。

> 证书的颁发依靠的是人的判断，也就是CA机构的办事员，只要是人就有失误的可能，也难保不会出现腐败。

> 只要CA机构想要窃听用户隐私就能做到。

> 后来人们提出了证书透明的方案，CT机制， 这个机制比较复杂，就是用上面类似的机制又加了一个日志机构， 但是，CA机构能颁发错误的证书，日志机构就不能篡改错误的日志么？这就是CT机制要解决的核心问题，答案就是去中心化。区块链技术给人们带来的启示就是，任何中心化的节点都是不可信任的，不论它如何权威，只有将信任分配到每个利益相关方手中，相互监督才能打破困境。日志服务采用了区块链中常用的 MerKle Tree 来防止篡改，记录每个节点的哈希值，相邻的两个节点两个哈希值组合在一起形成新的数据，然后对这个数据进行哈希计算，然后再把相邻的两个哈希值组合在一起，如此这般，直至最后，得到一个根哈希值，只要大家监督这个根哈希值，就能保证数据无法被私自篡改。

> 日志服务是一个只能添加的账本系统，而且它的数据完全公开，所有人都可以查询和验证，

### 文件传输格式

前端传输数据给后端主要有以下几种格式：
JSON: application/json
Form Data: application/x-www-form-urlencoded
Multipart Form Data:  multipart/form-data

需要上传文件，最好还是使用 multipart/form-data 格式。如果你需要同时发送文件数据和其他类型的数据，你可以考虑将其他数据作为 multipart/form-data 的一部分一起发送,或者在文件上传完成后，再单独发送一个 JSON 请求。


## cdn 

cdn就是内容分发网络,让离你最近的服务器，给你发送你想要的数据，这样不管你在哪里访问网站，网站打开的速度都会很快。

原理：

当我们输入某个网址,浏览器会进行dns解析，解析出ip地址返回给浏览器，然后去ip地址对应的服务器上获取相应的网站文件，cdn就是在这个dns解析过程中起作用。

当你给一个域名开通了cdn, 要先给这个域名的dns解析设置的后台添加一条cdn专用的解析记录，这条解析记录会让域名被解析后，指向一个cdn网络专用的，处理dns请求的服务器。


这个专门的dns服务器，返回一个ip地址，指向一台专门用来给各个请求分配适合的cdn服务器（负载均衡服务器），你的浏览器就会去访问这台负载均衡服务器，负载均衡服务器会根据你的浏览器网络地址，会在cdn网络中找一台比较适合你的服务器，比如说离你比较近，被分配的访问任务又不多的某台服务器，负载均衡服务器会把这台服务器的ip地址放回给你的浏览器。

浏览器根据这个ip去访问对应cdn服务器，请求文件资源，如果服务器发现并没有相关的网站文件，他就会去cdn网络中上层缓存服务器中找，如果上一层还没有，会继续向上找，最后会找到源站去拉取网站文件，拉取之后会在每一层刚才查找不到的cdn服务器上都做个缓存（这个第一次从cdn拉取文件，会找不到，一直找到源站的过程叫回源），最后你访问的cdn服务器会发送文件给你的浏览器。

> 可以通过响应头信息判断是否发生过回源，类似x-cache, 当它为tcp-miss时意思是未命中缓存导致cnd回源。当它为tcp-memory-hit时就是命中缓存，不过不同云产品这个响应头不一样，不过意思类似。
> 触发回源的时候，相当于在原来的流程还多了一层cdn调用流程，比直接访问服务器会慢一些
> cdn里不存在文件，或者文件缓存失效，都会触发回源
> 一般不需要特殊处理，不过对于大版本更新，上线后,预计大部分cdn都会触发回源时，这是可以将热点数据筛选出来，利用工具（一般云产品会有这个功能，比如一个按钮：刷新预热，本质是提前回源吧）预先请求一波，让cdn加载上热点数据的缓存

除了能让用户的打开网站，cdn 还能cdn还能避免原始服务器因为宕机，而导致的服务瘫痪（因为它有缓存机制一个服务器挂了，还有其他服务器可以工作）。同时还有减少费用的作用（节省带宽）

对于网页图片，视频，音频，这类文件对象，都适合用cdn加速；

cdn和源站文件不一致的处理：

1. 有些业务功能，同路径下的图片文档会覆盖更新，那么就要有业务去触发刷新预热，但是要控制好频率等等。
2. 有些业务场景，就不应该覆盖更新，新的文档和图片都加上时间戳或者uuid就好了。然后还可以定期清除oss中时间戳太早的数据。


## 页面间通讯

同源之间： 

广播模式，一个页面将消息通知给中心站，再由中心站通知给各个页面：

BroadcastChannel： 它允许同源的不同浏览器窗口，Tab 页，frame 或者 iframe 下的不同文档之间相互通信


频道实例分别用postMessage发送消息，用message 监听。


```

// new BroadcastChannel 时只要传参相同就对应同一个频道


let CHANNEL_CODE = 'test1'
let listenChannel = new BroadcastChannel(CHANNEL_CODE);

// 监听
listenChannel.addEventListener('message', (res) => {
    console.log(res);
});


new BroadcastChannel(CHANNEL_CODE).postMessage(data);


// 关闭
var listenChannel = new BroadcastChannel(CHANNEL_CODE);
listenChannel.close();


```



LocalStorage 和 监听storage事件， storage里内容变化则触发对应事件(内容改变才会触发)， 可以判断对storage设置的key作一些处理

- sessionStorage 是互相独立的，一个页面对 sessionStorage 的更改无法触发其他页面的 storage 事件。所以，当我们需要在不同的页面间进行数据通信时，一般会选择使用 localStorage。
- 触发 storage 事件的页面本身并不会接收到这个事件


共享存储加轮询模式：...


口口相传模式： window.open + window.opener, 当使用window.open 打开新页面时，会返回被打开页面的引用。window.opener 就是打开当前页面的页面（父页面）；

打开的时候把打开的窗口收集起来，因为作为信息的发起方你需要同时通知它打开的页面（可以提前存好引用）与打开它的页面（window.opener）【可以根据实际场景去选择具体处理】；
可以用window.closed属性过滤掉已经关闭的页面；

可以让消息流转起来，每个页面收到消息都通知到所有他知道的页面，当然，给他传消息的页面要过滤掉。这就是口口相传。

```
发消息：

页面引用.postMessage('xxx')

window.opener.postMessage('xxx')

然后去监听message时间：


window.addEventLister('message', function(){})


```


非同源页面间通讯：


window.postMessage() 方法可以安全地实现跨源通信。一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个 MessageEvent 消息。接收消息的窗口可以根据需要自由处理此事件 (en-US)
> 谁用点引用就给谁发消息

```
otherWindow.postMessage(message, targetOrigin, [transfer]);


otherWindow其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames (en-US)。

message: 将要发送到其他 window 的数据


targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个 URI

```


不知道下面的这个场景用在哪里：

postMessage， 关键点在于要拿到打开的window对象才能通讯，直接在window打开就拿不到。

那就可以用iframe作为桥，由于iframe与父页面可以通过指定origin来忽略同源限制，因此可以在每个页面嵌入一个iframe(这些iframe使用同一个url,因此属于同源页面)，就可以复用上面的同源策略。


> 所以说window.postMessage 其实既可以做同源页面的通讯，也可以做非同源页面的通讯；



## dom

- 如何获取一个元素的位置

相对于文档的位置：用事件对象上的 pageX, pageY
相对于视口的位置： Element.getBoundingClientRect() , 方法返回一个 DOMRect 对象，其提供了元素的大小及其相对于视口的位置。
> 如果你需要获得边界矩形相对于整个网页(也就是文档)左上角的位置，则可以将当前的滚动位置（可通过 window.scrollX 和 window.scrollY 获得）添加到 top 和 left 属性上
相对于父级参照物的位置： offsetLeft/Top 距离其父参照物（一般父参照物都是body, 如果给元素增加一个定位属性， 会让它的子孙元素父参照物指向当前元素）的左偏移， 上偏移（从边框外沿开始算）

## css

元素长宽成比例
可视区域

## 常见移动端兼容问题

- 1. 当设置样式overflow:scroll/auto 时，ios上会卡顿

```
-webkit-overflow-scrolling: touch;

```

- 2. 在安卓环境下placeholder文字设置行高时会偏上

```
input 在有placeholder属性时不要设置行高

```

- 3. 移动端字体小于12px时异常显示

```
应该先整体放大一倍， 然后再用transform缩小

```

- 4. 移动端怎么适配顶部跟底部的安全区域

通常来说，IOS 设备在页面顶部和底部都会预留出一定的安全区域(那是他的状态栏)，底部安全区域的高度和设备尺寸、系统版本等相关，一般在 34~44px 之间。而 Android 设备在页面顶部通常不需要预留出安全区域，但在底部有导航栏时需要预留出相应的安全区域。

```
1. 使用 viewport meta 标签, 重点 在viewport-fit=cover

在 HTML 的 head 标签中添加 viewport meta 标签，以适配不同设备的屏幕大小，并启用安全区域填充模式。

<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

viewport-fit=cover 表示页面会填充整个屏幕，包含不同设备的安全区域。

2. 为了兼容不支持 CSS 变量的浏览器，可以使用 fallback 方案，例如：

body {
  padding-top: constant(safe-area-inset-top);  /* iOS */
  padding-top: env(safe-area-inset-top);        /* Android */
  padding-bottom: constant(safe-area-inset-bottom); /* iOS */
  padding-bottom: env(safe-area-inset-bottom);       /* Android */
}

其中，constant 表示兼容 iOS 设备，而 env 表示兼容 Android 设备。而env()和constant()函数有个必要的使用前提，H5网页设置viewport-fit=cover的时候才生效，小程序里的viewport-fit默认是cover。

env()和constant()，是IOS11新增特性，Webkit的css函数，用于设定安全区域与边界的距离，有4个预定义变量
```



原理： 手写实现events, 见设计模式章节


### cookie

因为HTTP本身是不保存任何用户的状态信息的，所以*HTTP是无状态的协议*, 一个服务器是不清楚是不是同一个浏览器在访问他

cookie的有效期：

Max-Age，是以秒为单位的，Max-Age为正数时，cookie会在Max-Age秒之后，被删除，当Max-Age为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失，当Max-Age为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效。

HttpOnly：

这个属性是面试的时候常考的，如果这个属性设置为true，就不能通过js脚本来获取cookie的值，能有效的防止xss攻击

关于js操作cookie：

```
//读取浏览器中的cookie
console.log(document.cookie);
//写入cookie
document.cookie='myname=laihuamin;path=/;domain=.baidu.com';

```

node服务端创建Cookie:

```
Cookie cookie = new Cookie("cookieSessionId","qwertyuiop");
cookie.setDomain(".baidu.com");             // 设置域名
cookie.setPath("/");                        // 设置路径
cookie.setMaxAge(Integer.MAX_VALUE);        // 设置有效期为永久
response.addCookie(cookie);                 // 回写到客户端


服务端就是通过setCookie来设置cookie的，注意点，要设置多个cookie时，得多写几个setCookie

```

### cookie , session ,jwt

起初：cookie 

注册后，后台将用户名密码存到数据库，下次登录时，后台根据用户名和密码，和数据库存的做对比

如果不想让已经登录的用户，重新输入密码，就得保存用户登录状态

- http 是无状态的
- 需要客户端存储状态，然后每次请求都带上，于是cookie出现了，但是把用户名和密码存在cookie里不安全；

发展： cookie 配合 session ===> cookie 配合 session, sessionId 进数据库；

所以，session 出现了，网站对于每一个会话都设了一个sessionId, 和会话结束时间，然后设置cookie 把 sessionId cookie里，把会话结束时间 设置为cookie的有效期，浏览器拿到cookie后进行保存， 也就是说*cookie 实际放的值是sessionId*, 而且服务器再发送cookie 之前会对这个含有sessionId 的cookie做一个签名，别人修改了，就验证不通过了；

*session是保存在服务端的*, 用户多了之后，如果还使用cookie，session, 服务器可能需要存储大量session Id 在服务器里，如果有多台服务器，一台服务器存储了sessionId， 还要面临分享sessionId给其他服务器的问题，因为可能出现这台服务器超载，需要分配一些用户给其他服务器的情况， 因此可以把session Id存到数据库，但是数据库如果奔溃了，又会影响服务器获取sessionId； 

 - 服务器对于每一个会话都设了一个sessionId, 和会话结束时间，然后设置cookie 把 sessionId cookie里，把会话结束时间 设置为cookie的有效期
   - 可以把session Id存到数据库
 - 服务器再发送cookie 之前会对这个含有sessionId 的cookie做一个签名，别人修改了，就验证不通过了
 - 浏览器拿到cookie后进行保存， *cookie 实际放的值是sessionId*


结局：jwt

用户第一次登录网页后，服务器就生成一个jwt, *服务器不需要保存jwt, 只需要保存jwt签名的秘钥*，把jwt发送给浏览器， *浏览器用cookie或者storage 的形式存储token*
  - 主要是存储上面，相对于session,有很多改善
  - 安全上面主要体现在后端不能泄露加密秘钥secret, 也没有比session更安全

token 由 header.payload.signature 三部分组成：
 - header声明签名算法 
 - payload 是一些特定数据，比如有效期之类的 
 - header 和payload两部分会由base64编码， 再用服务器保存的jwt签名秘钥，对这个内容进行签名，生成signature， 这样一个完整的jwt就可以放给客户端了

- 校验
  - 每次请求的时候带上token, 后端对header 和 payload 再做一次签名，对比签名是否一样


### 安全

xss（跨站点脚本）: 是指黑客能够在你的网站当中执行他的代码 

csrf（跨站请求伪造）: 是指恶意利用浏览器会自动发送cookie的功能，由黑客所有网站发起的对于目标网站的恶意请求

## 面试向简记
## webstorage 

localStorage和sessionStorage：*本质是创建一个Storage对象*，  *提供了访问特定域名下的会话存储或本地存储的功能*，对于每个源 sessionStorage 和 localStorage 使用不同的 Storage 对象——独立运行和控制
- 存储大小均为5M左右
- 都有同源策略限制
- 仅在客户端中保存，不参与和服务器的通信

- 1. sessionStorage: 会话存储， 为每一个给定的源（origin）维持一个独立的存储区域
  - 生命周期： 页面会话在浏览器打开期间一直保持，并且*重新加载或恢复页面仍会保持*原来的页面会话。仅为会话存储数据，这意味着数据将一直存储到浏览器（或选项卡）关闭。
  - 作用域： 同一浏览器，同一个tab页，同源文档，*打开多个相同的 URL 的 Tabs 页面，会创建各自的 sessionStorage。*
    - 同一个tab页中，有两个同源的iframe元素的话，这两个iframe的 sessionStorage 是可以互通的。

- 2. localStorage： 永久存储
  - 生命周期： 没有过期时间，想清除只能主动清除
  - 作用域：同一浏览器，同源文档，*打开多个相同的 URL 的 Tabs 页面，使用的是同一个localStorage*
  - localStorage在浏览器的隐私窗口、隐身模式下面localStorage 存储 API 仍然可用且功能齐全，但是当隐私浏览器窗口关闭时，所有存储在隐私窗口中的数据都会被删除。


- 3. storage事件机制：*当前页面使用的 storage 被其他页面修改时会触发 StorageEvent 事件。*
  - 可用于浏览器多个页面间通信， 一般用localStorage 去触发，因为不同tab页的sessionStorage 是不同的，不能触发这个事件
  - 即创建/更新/删除数据项时，重复设置相同的键值不会触发该事件，Storage.clear() 方法至多触发一次该事件
  - 在同一个页面内发生的改变不会起作用——在相同域名下的其他页面（如一个新标签或 iframe）发生的改变才会起作用。

  ```
  window.addEventListener("storage", function (e) {
    document.querySelector(".my-storage").textContent = e.storageArea;
  });

  ```

  ```
  使用：

  - Storage.getItem() ： `getItem(keyName)`当传递一个键名时，将返回该键的值,如果该键名不存在，则返回 null。
  - Storage.setItem()： `setItem(keyName, keyValue)`当传递了一个键名和值时，将会把键名添加到给定的 Storage 对象中，如果键名已存在，则更新其对应的值。
  - removeItem() : `removeItem(keyName)`当传递一个键名时，将从给定的 Storage 对象中删除该键
  - Storage.length： Storage 对象中的数据项的数量，可以用来测试存储对象是否为空。


  ```


  cookie：
  - 1. 同源限制：
    - 默认不可以跨域
    - 不过可以配置Domain，则他的子域名，也可以访问使用cookie
  - 2. 大小：
    - 它的大小限制为4KB左右
  - 3. 生命周期：两种定义方式
    - 1. 会话期 Cookie 
      - 在浏览器端生成Cookie，默认是关闭浏览器后删除
    - 2. 持久性 Cookie 
      - 一般由服务器生成，可设置失效时间（Expires： 客户端时间的一个绝对时间，与服务器时间无关； Max-Age：相对时间）。
    - 每次都会携带在HTTP头中，会带来额外的性能开销
  - 4. 作用
    - 网站经常使用这个技术来识别用户是否登陆等功能。？ 登录不是用jwt么
    - 如果你的站点对用户进行身份验证，则每当用户进行身份验证时，它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie，此技术有助于防止会话固定攻击（session fixation attacks） (en-US)，在该攻击中第三方可以重用用户的会话。
  - 5. cookie安全策略： Secure 属性和 HttpOnly
    - 标记为 Secure 的 Cookie, 用https协议发送
      - 1. 这个cookie只能用https协议发送给服务器，用http协议是不发送的
      - 2. 这意味着中间人攻击者无法轻松访问它
    - 带有 HttpOnly 属性的 cookie， 无法被js脚本读取
      - 1. 持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性
      - 2. 此预防措施有助于缓解跨站点脚本（XSS） (en-US)攻击。
  - 6. cookie 的SameSite 属性： 同站请求，默认为Lax
    - SameSite 属性允许服务器指定： 是否/何时通过跨站点请求发送， 它采用三个可能的值：Strict、Lax 和 None。
      - 使用 Strict，cookie 仅发送到它来源的站点
      - Lax 与 Strict 相似，只是在用户导航到 cookie 的源站点时发送 cookie。 ？
        - 通过点击来自外部站点的链接
      - None 指定浏览器会在同站请求和跨站请求下继续发送 cookie，SameSite=None 的 cookie 还必须指定 Secure 属性（它们需要安全上下文）。


ps: cookie 和 webstorage 的联系： Cookie 曾一度用于客户端数据的存储，因当时并没有其他合适的存储办法而作为唯一的存储手段，但现在推荐使用现代存储 API， 也就是webstorage 和 IndexDB

## http

### 在浏览器地址栏输入一个url, 到页面返回展示，这中间发生了什么

- DNS解析
  - *查dns缓存*： 依次检查浏览器缓存，操作系统缓存，路由器缓存，如果都没找到会递归查询DNS服务器，最后返回ip 
  - *递归查询*: 类似一个树状结构，一级一级缩小范围，如查找www.example.com，  从根域名服务器（.com），到顶级域名服务器(example.com)， 到权威域名服务器(www.example.com). 
- *建立TCP连接*
  - 获取到IP地址后，浏览器会与服务器建立一个TCP连接, 通过“三次握手”完成:
    - 客户端发送SYN包: 客户端向服务器发送一个SYN（同步序列编号）包，请求建立连接.
    - 服务器回应SYN-ACK包: 服务器收到SYN包后，回应一个SYN-ACK包（同步-确认）。
    - 客户端发送ACK包： 客户端收到SYN-ACK包后，回应一个ACK（确认）包，连接建立
- *检查http缓存*
  - 强缓存：（不需要与服务器通信）浏览器检查强缓存，如果资源未过期，直接从缓存中加载
    - 浏览器首先会检查本地缓存（内存缓存和磁盘缓存）中是否有该资源，如果有，则检查其缓存头（如Cache-Control和Expires） 
  - 协商缓存：（又叫条件请求）如果资源过期或不存在，发送HTTP请求到服务器。
    - 当资源未命中强缓存但仍可能有效时，浏览器会发送条件请求
      - If-Modified-Since： ：基于资源的最后修改时间
      - If-None-Match： 基于资源的ETag（实体标签）
- 发送HTTP请求
- 服务器处理请求并响应
  - 如果响应状态码是200（OK），浏览器接收新的资源并更新缓存。
  - 如果状态码是304（Not Modified），表示资源未修改，浏览器使用缓存中的资源。
- 浏览器解析响应并渲染页面
  - 解析HTML并构建DOM树: 浏览器从上到下顺序解析 HTML，构建 DOM 树
  - CSS 加载和解析,构建CSSOM树: *CSS 的加载是异步进行的，默认不会阻塞 HTML 解析*
    - 浏览器会继续解析 HTML，构建 DOM 树，同时并行加载 CSS 文件
    - 浏览器必须等待所有 CSS 文件加载和解析完成后，才能构建完整的渲染树并开始渲染页面。
  - JavaScript 加载和执行: 当浏览器遇到 <script> 标签时
    - *如果没有 async 或 defer 属性，浏览器会暂停 HTML 解析，加载并执行 JavaScript*。
    - 由于 JavaScript 可能会修改 DOM 和 CSSOM，浏览器必须等待 JavaScript 执行完成后，才能继续解析 HTML。
  - 构建渲染树: 将DOM树和CSSOM树结合，生成渲染树
  - *布局（Reflow）*: 计算渲染树节点的几何信息
  - *绘制（Repaint）*: 将渲染树节点转换为实际像素，并绘制到屏幕上
  - 执行JavaScript
    - JavaScript代码可能会修改DOM树和CSSOM树，触发重新布局和重绘。
  - 关键点： *CSS 文件加载不会阻塞 HTML 解析, CSS 加载会阻止 JavaScript 执行*
    - CSS 文件的加载不会阻塞 HTML 的解析，但 *CSS 文件的加载和解析确实会阻止 JavaScript 文件的执行*。这是因为浏览器需要确保所有样式已经被应用，以便 JavaScript 可以正确操作 DOM 元素及其样式。也就是说，*HTML 解析和 CSS 加载的有并行性，CSS 加载与 JavaScript 执行有互斥性*，因为JavaScript 可能会依赖于 CSS 的计算结果,例如，读取元素的尺寸和样式;
 


ps: 因为接受的html是字节数据，并不会等整个文档就位才开始构建，浏览器收到一部分数据就开始自上而下构建了dom树了，这样可以加快构建过程

- defer：脚本异步下载，不会阻塞 HTML 的解析，HTML 解析完成后按顺序执行（多个defer）。
- async：脚本异步下载，不会阻塞 HTML 的解析，下载完成后立即执行，顺序不定(多个async)。


- 提高css加载速度
  - cdn
  - css压缩： 打包工具压缩； 设置gzip压缩；
  - 合理使用缓存
  - 减少http请求数： css合并；或者写成内联样式（缺点不能缓存）



### tcp, udp 待整理

### https

简单理解：https主要是*要协商出一个对称加密的秘钥*；

- 1. *服务端找第三方用私钥加密信息*：服务端先将自己的公钥，域名，第三方机构名等信息发送给第三方（CA）机构，第三方用自己的私钥把这些数据加密，和明文放在一起（形成tsl证书），返回给客户端；（因为拿到服务端公钥也没有用，因此可以用明文，只是防篡改）
- 2. 客服端找第三方用公钥解密信息：*客户端收到信息先验证*，用内置的公开的公钥对证书的密文进行解密，如果解密的结果和证书的明文一致，则通过验证。
- 3. 生成对称加密的传输秘钥： *浏览器生成一个随机数据，用服务器的公钥进行加密再发送给服务器，服务器用自己的私钥解密，如此双方就能得到一个同样的随机数据*。如此，双方协商出对称加密的秘钥。
- 4. 用这个秘钥对信息进行加密传输

> 第三方用私钥加密，公钥解密
> 客户用服务端公钥加密，服务端用私钥解密
> 其实大概意思就是，暴露的（传给别人的）是公钥，自己留着私钥（留着更隐私的那个）；

### http2

HTTP/2 是 HTTP 协议的第二个主要版本，旨在解决 HTTP/1.1 中存在的一些性能问题，提高网页加载速度和效率。
- 概括的来讲，*http2 最核心的就是解决了http1的（http层面）队头阻塞问题*
  - 但是http(应用层)下面还有个传输层tcp， http2 并没有解决tcp层面的队头阻塞问题
- http2 2015年推出，2019年 http3 就出了
  - http3 就是为了解决tcp层面的队头阻塞问题， 传输层用了udp，然后再udp上又加了一个层quic

建立链接原理：
  - HTTP/2 使用 TCP 作为传输层协议，可以通过 HTTPS（TLS）或 HTTP 直接连接。
  - 通过 ALPN（应用层协议协商）扩展确定使用 HTTP/2。


关键特性和改进点
- 二进制分帧
  - HTTP/2 将所有通信转换为二进制格式，而不是文本格式。*消息（请求和响应）被分割成更小的二进制帧，这些帧可以独立传输*，并可以通过不同的流传输。这些帧具有头部帧（原首部）、数据帧（原实体）和控制帧等类型
  - *帧通过流（stream）标识符来标识*，每个流都有唯一的标识符。这个流标识符可以信息在接收端能按顺序重新组合完整的依据。
  - 帧还可以设置优先级，来标注流的权重
- 多路复用
  - 允许*同时通过单一的 TCP 连接发送多个请求和响应，而不会互相阻塞*。在单个 TCP 连接上可以同时处理多个流，流中的帧可以交错传输，消息在接收端重组为完整的请求和响应。
  - *消除 HTTP/1.1 中的“队头阻塞”问题*，使得请求可以并行处理，显著提高传输效率。
- 头部压缩
  - 使用 HPACK 算法压缩 HTTP 头部，减少头部的大小，从而减小传输的数据量。（很多固定首部占空间）
  - 通过静态和动态表来实现头部字段的压缩，提高传输效率。
- 服务器推送
  - 服务器可以在客户端请求之前主动推送资源到客户端缓存，以减少客户端的请求延迟。
  - 适用于推送 CSS、JavaScript 文件等静态资源，提高页面加载速度。
  - 原理：
    - 服务器可以在收到客户端的请求后，主动推送相关资源到客户端。
    - 通过 PUSH_PROMISE 帧通知客户端即将推送的资源。

优点：
  -  提高性能： 多路复用和头部压缩显著减少了数据传输的开销和延迟，提高了网页加载速度。
  -  减少延迟： 服务器推送和流优先级使得资源的传输更加高效，进一步减少了延迟。
  -  简化连接管理： 单个 TCP 连接处理多个请求和响应，减少了连接管理的复杂性。

- 解决问题: http1.1 要做的，http2 不用做了
  - 因为可以多路复用，和二进制分帧，我想发多少请求都可以，不需要减少请求次数了
    - 减少请求次数: http1.1 时间我们要用精灵图来减少请求次数，
    - 用域名分片来增加并发请求数

额外解释：

- 流和帧的关系: 帧是 HTTP/2 中传输数据的最小单元。流是 HTTP/2 中传输数据的基本单元。
  - 组合： *一个流由多个帧组成*。一个流代表一个双向的、有序的字节流，可以承载一个完整的 HTTP 请求或响应。
  - 交错传输: 在 HTTP/2 中，*不同流的帧可以交错传输*。例如，流1的帧和流3的帧可以交替传输，而不会互相阻塞。


- 头部压缩HPACK 算法： 静态和动态表
  - 静态表： 是一个预定义的表，包含了常用的 HTTP 头部字段。每个字段都有一个唯一的索引。
  - 动态表： 动态表是一个运行时更新的表，用于存储在当前连接中出现的头部字段。
    - 在连接过程中，当遇到新的头部字段时，可以将这些字段加入动态表。客户端和服务器都维护自己的动态表。
  - 压缩过程：
    - 在发送头部字段时，首先检查该字段是否在静态表或动态表中。如果匹配上了，可以直接*使用该字段的索引*。
    - *使用索引表示头部字段可以显著减少传输的数据量*，因为索引通常比原始字段要小得多。
      - 因为索引通常是数字，把字符串用一个数字表示当然传输量就小了啊
    - 如果头部字段不在静态表和动态表中，则将其添加到动态表中。动态表的大小是有限的，可以通过设置表的最大大小来控制内存使用。



#### http的队头阻塞

队头阻塞是 HTTP/1.1 中一个显著的性能问题，主要是由于 *HTTP 协议在单个 TCP 连接上按顺序处理请求和响应的机制引起的*。

队头阻塞的原因：
- HTTP/1.1 的连接管理
   - 1. HTTP/1.1 引入了持久连接（Persistent Connections），允许在同一个 TCP 连接上发送多个请求和响应
   - 2. 在同一个tcp连接上，HTTP/1.1 采用串行的方式处理请求和响应。也就是说，必须等待前一个请求完成后才能处理下一个请求。
- 浏览器的连接限制
  - 为了避免过多的并发连接占用网络资源和服务器资源，浏览器通常限制每个域名的并发连接数，一般是 6 个。如果一个页面需要加载大量资源（如图像、CSS 文件、JavaScript 文件等），这些资源请求会分布在这 6 个连接上

### 内存泄露

定义： 已经*结束运行的或者不再使用的内存没有被释放*（没有被垃圾回收机制回收），仍然被占用，导致可用内存逐渐减少，严重时可能会导致程序运行缓慢或者崩溃

场景：
- 1. 全局变量未正确清除：显式声明的全局变量在全局作用域内始终存在，不会被垃圾回收机制清除
- 2. 未清理的定时器或回调函数： 如果一个定时器（如setTimeout或setInterval）或者事件监听器（如addEventListener）设置了，但在不需要的时候没有被clear或remove
- 3. 闭包: 在JavaScript中，闭包可能会导致内存泄漏，特别是当闭包内部的变量包含了大量数据或复杂的对象引用时。







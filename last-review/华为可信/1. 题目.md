- 目前可信发现三类题型：一般是第一或者第二题
  - 设计类
    - 设计系统类：设计关键实体，是核心，可能是三层的对象结构，中间有一个关键对象或数组结构
      - 设计到多个实体的关联关系，以及状态更新，*需要从操作出发，观察各操作都涉及到的实体，或与其他实体都有直接关系的实体，作为关键实体，来重点设计*，作为一个各种操作之间的中间桥梁
    - 模拟时间运行类： 如定时器，核酸排队，最关键是*定义下一个完成(到达)时间（或数组）*
  - 算法类：
    - 滑动窗口： 查找子串
      - 固定窗可以暴力解，包括数量有限的多个长度的固定窗，比如固定窗长度范围为[6,12]
      - 难一点的可能要加上对象计数
    - 最短子序列： 双指针
    - 排列组合： 决策选择，负载均衡都属于排列组合类问题，可以暴力所有解
      - 难一点的会加一个回溯
  - 另外记得先打印数据结构，特别是题目给出二维数据的，有可能实际数据结构是对象
  

todo: 2.16， 基本复习一遍主要再将14题看看就行

2.18 只看思路不看题了，看上面的思路，以及 之前的算法思路； 试着用借来的电脑做一道题


- 常考题型总结：
- 滑动窗口类:变体总结
  - 窗口内计数: 满足xx条件，简单的可以直接计数，复杂的需要一些技巧
    - 1. 对于需要去重的，还要移动删减的，有技巧的记录值：增加一个对象计数，值减到0再，把key移除
      - 例子： 电流采样匹配
    - 2. 对于需要考虑顺序的：则不用滑动窗口，用双指针回溯或者动态规划
      


- 1. 磁盘io合并于拆分：  2.13 做了一遍， 后面只需要看，不需要再做了

是说一个磁头读取时，是一个区间一个区间 读取的，可能有重复的。 比如[[1,30], [25, 40], [28, 50]], 类似这种， 磁盘里有划分片区，每个片区的范围是 [size, size*(n+1)-1],  size 从0开始的； 

你能返回读取后，拆分的结果么，比如让size=32

我理解是要做区间的合并与拆分，合并我有点思路，但是拆分，尤其是这种可能有多个拆分节点的拆分，我就不知道怎么拆了； 

- 合并： 用两个数组，先排序，然后比较，合并结果放到新数组的尾部
- 拆分： 遍历合并后的数组，拆分点的开始在 区间start 的左边， 拆分点的结束，取end与下一个拆分点之间的最小值
  - 简单说就是： 用0*size, 1*size, 去这些节点区分割区间
  -  也就是： partitionStart = Math.floor(start / size) * size;
  -  partitionEnd = Math.min((partitionStart+1)*size - 1, end);
  -  通过整除获得的 n 就是当前区间所在的片区编号， 也就是片区的起始位置

```
function mergeIntervals(intervals) {
    // 首先对区间按照起始位置进行排序
    intervals.sort((a, b) => a[0] - b[0]);

    let merged = [];
    for (let interval of intervals) {
        // 如果merged为空，或者当前区间和merged的最后一个区间没有重叠
        if (merged.length === 0 || merged[merged.length - 1][1] < interval[0]) {
            merged.push(interval);
        } else {
            // 否则合并当前区间
            merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], interval[1]);
        }
    }

    return merged;
}

function splitDiskIOIntervals(intervals, size) {
    // 先合并所有区间
    let mergedIntervals = mergeIntervals(intervals);
    let result = [];

    // 拆分每一个合并后的区间
    for (let [start, end] of mergedIntervals) {
        let subIntervals = [];
        // 拆分当前区间
        while (start <= end) {
            let partitionStart = Math.floor(start / size) * size;
            let partitionEnd = Math.min((partitionStart+1)*size - 1, end);
            subIntervals.push([partitionStart, partitionEnd]);
            start = partitionEnd + 1;
        }
        result = result.concat(subIntervals);
    }

    return result;
}

// 测试用例
let intervals = [[1, 30], [25, 40], [28, 50]];
let size = 32;
let splitResult = splitDiskIOIntervals(intervals, size);

console.log(splitResult);




```


- 5. 电流采样匹配

设备采样电流序列sampling
先验样板pattern
温控表temperature
他们按某种规则匹配，用于指导设备降温

pattern固定为[3,7,11,17,23,29,37,47]
现在给定温控表temperature元素各不相同，需从sampling中找到满足以下规则的一段连续子序列data

1.data中元素出现于pattern中的个数小于等于mask个，重复的也算
2.data长度最多比temperature的长度大num
3.选择的data要使其元素出现于temperature中，去重后的个数最多，如果这样的data有多个，选最短的

请选出data

- 这几个条件还挺奇怪的，不想是常规的条件
  - 条件一，基本都能满足啊， 超过就左缩？
  - 条件二，也是
  - 但是看条件三，是一个最短模版啊
    - 但是题解却是用了一最长模版： 因为优先选择个数最多的，最多的有多个，才选最短的，所以是先用最长模版是前提

有函数：m（temperature，sampling，num，mask）

输入：
[1,2,4,7]
[2,1,2,3,3,4,7]
3,
2
输出5

- 题意理解： 
  - 我们需要在 sampling 中找到一个连续子序列 data，满足一定条件：
    - 右扩：data 中出现在 temperature 的元素去重后的个数最多， 如果有多个满足条件的 data，选择最短的子序列。
    - 左缩： data 中元素出现在 pattern 中的个数小于等于 mask。data 的长度最多比 temperature 的长度多 num。
  - 滑动窗口 ==> 不固定长度 ==> 最长的子序列 ===> 右扩，不满足条件，左缩
    - 1. pattern 条件： pattern 做映射对象，计数
    - 2. length条件： 固定比较
    - 3. temperature 条件： temperature 做对象映射，计数
  - 难点： 去重后个数最多, 这个去重不是不好处理；
    - 用对象计数， 计数为0时，再删除
    - 不是很理解这个条件： 先急着吧，record[sampling[left]] >1

```
function m(temperature,sampling,num,mask){
  let count = 0;
  let res = [];
  let left= 0, right = 0;
  let record = {}
  let maxLen = 0;
  let bestLength = Infinity;
  const pattern = [3,7,11,17,23,29,37,47]
  while(right<sampling.length){
    // 匹配次数
    if(pattern.includes(sampling[right])){
      count++;
    }

    if(temperature.includes(sampling[right])){
      record[sampling[right]] = record[sampling[right]] || 0;
      record[sampling[right]]++;
    }

    while(count>mask || right-left+1 > temperature+num || record[sampling[left]] >1){
      if(pattern.includes(sampling[left])){
        count--;
      }

      if(record[sampling[left]]){
        record[sampling[left]]--;
        if(record[sampling[left]] === 0){
          delete record[sampling[left]]
        }
      }

      left++;
    }

    // 走完不满足条件，就是满足条件，更新结果
    const len = Object.keys(record).length
    if(len > maxLen || (len === maxLen && right-left+1 < bestLength)){
      maxLen = len;
      bestLength = right-left+1
    }

    right++
  }

  return bestLength
}

// 测试用例
console.log(m([1, 2, 4, 7], [2, 1, 2, 3, 3, 4, 7], 3, 2)); // 输出: 5


```


- 6. 有一个题，我理解大意是求，最短连续子序列 : 2.15 做一遍， 后面只需看
m（p，c）， 从p中找到包含c的最短子序列

比如：p为[4,8,4,3,6,6,8]  ，c为[4,6,8]得到 ，m(p,c) 得到 [4,3,6,6,8]， 

如果仅仅是包含我知道怎么处理，用滑动窗口，对象存储就好，这个似乎还有顺序，有序得咋处理？

- 匹配进度cIndex：既表示位置，也表示进度个数
  - cIndex 的值范围是 [0, c.length]。
  - 它表示当前滑动窗口已经成功匹配到 c 的前 cIndex 个元素，且这些元素是按照 c 的顺序匹配的。

- 收缩左边界时： 
  - 如果移除窗口左端的元素是 c 的起点（c[0]），可能会破坏当前的匹配
  - *左边界移动后，要判断是否依然能满足条件，重新从当前窗口寻找是否还有完整的 c*；（难点，比较难想）

```
function minWindowSubsequence(source, target) {
  let minLen = Infinity;
  let start = -1;
  
  let sIdx = 0, tIdx = 0;
  
  while (sIdx < source.length) {
    if (source[sIdx] === target[tIdx]) tIdx++;
    
    if (tIdx === target.length) {
      let end = sIdx;
      tIdx--;
      
      // 向左回溯确定最短起点
      while (tIdx >= 0) {
        if (source[sIdx] === target[tIdx]) tIdx--;
        sIdx--;
      }
      
      sIdx++;  // 修正左边界
      tIdx = 0; // 重置tIdx
      
      if (end - sIdx + 1 < minLen) {
        minLen = end - sIdx + 1;
        start = sIdx;
      }
    }
    
    sIdx++;
  }
  
  return start === -1 ? "" : source.substring(start, start + minLen);
}

console.log(minWindowSubsequence("abcdebdde", "bde")); // "bcde"


// 测试用例
console.log(m([4, 8, 4, 3, 6, 6, 8], [4, 6, 8])); // 输出: [4, 3, 6, 6, 8]
console.log(m([1, 2, 3, 4, 5], [2, 4])); // 输出: [2, 3, 4]
console.log(m([1, 2, 2, 3, 4], [2, 3])); // 输出: [2, 3]


```


- 7. 软件配置: 2.16 做一遍，后面只需看
  
config表示网管的初始配置:config[i]=[id1,id2]
表示端口id1和id2之间存在一条专线，两个端口被占用。端口是双向的，无序

reqs表示网管侧发起的一系列配置请求,reqs[i]=[type,id1,id2]

type为a表示新建id1和id2的专线，如果两个端口都没占用，则可成功;
为d表示删除两个端口之间的专线，并且释放端口。

对reqs做处理，变成最终简化数据给设备。要求命令尽可能少。

请返回命令列表：删除命令在前，所有命令按d1升序,id1要小于id2



理解： 用两个集合去顺着题意做就行了，一个记占用端口，一个记最终命令，注意先新增,后删除可以抵消；
  

- 这种应用题，需要结合给出的例子一步步提炼清楚规则, 规则写清楚了，也就做出来了
-  // 规则1：
  // - 新建
  //   - 没有端口占用，则可新建，加到结果
  //   - 占用则失败，不管
  // - 删除
  //   - 有对应没有成对端口 1. 初始化里有，则加到结果里  2. 之前有新建的则抵消
  //   - 没有对应成对端口， 无效


  ```
  const simplifyConfig = (configs, reqs) => {
  const  allConfig = new Set(); // 记录所有建立，和删除的专线
  const used = new Set(); // 记录已经使用过的端口

  configs.forEach(config=>{
    allConfig.add(config.sort().join(''))
    used.add(config[0])
    used.add(config[1])
  })

  for(let val of reqs){
    const [type, id1, id2] = val;
    const str = [id1, id2].sort().join('')
    if(type === 'a'){
      if(used.has(id1)|| used.has(id2)){
        continue;
      }else{
        used.add(id1)
        used.add(id2)
        allConfig.add('a'+str)
      }
    }else if(type === 'd'){
      if(allConfig.has(str)){
        used.delete(id1)
        used.delete(id2)
        allConfig.add('d'+str)
      }else if(allConfig.has('a'+str)){ // 删除抵消添加命令
        allConfig.delete('a'+str)
        used.delete(id1)
        used.delete(id2)
      }
    }
  }

  let allConfigArr = [...allConfig].filter(item=>item.length===3);
  allConfigArr.sort((a,b)=>{
    if(a[0] !== b[0]){
      return a[0] === 'd'? -1: 1;
    }
    return a[1] -b[1]

  })

  return allConfigArr;
}

const config = [[2, 3], [4, 5]];
const reqs = [ 
  ['a', 0, 1],  // 成功
  ['a', 5, 6],  // 失败，占用
  ['d', 0, 1],  // 有则，抵消之前新建，删除，释放 0,1
  ['d', 1, 2],  //  没有这个端口，不管，失败
  ['a', 0, 6], // 成功
  ['d', 4, 5],  // 成功, 有，但是不用抵消
  ['a', 1, 4]  // 新建：成功 
];

console.log(simplifyConfig(config, reqs));
// 输出: ['d45', 'a06', 'a14']


```

  
```


- 8. 寻找相同权重的数字: 2.16 简单，看一下就行了

定义一个数字的二进制表示中,1的个数为该数字得权重。

如8，二进制为1000，权重1;7权重3

给定一个区间min，max，左闭右开，和目标权重，请找出区间内等于目标权重的数字有多少


如：
输入
3
10
2
得到4

理解：
    - 关键是num.toString(2) 转2进制，其余就是两个遍历，或者第二个遍历用字符串匹配match代替；

```
function getWeight(num) {
  // 方法1：使用 toString(2) 转为二进制字符串，再统计 '1' 的个数
  return (num.toString(2).match(/1/g) || []).length;
}

function countNumbersWithTargetWeight(min, max, targetWeight) {
  let count = 0;
  for (let i = min; i < max; i++) {
    if (getWeight(i) === targetWeight) {
      count++;
    }
  }
  return count;
}

// 测试用例
const min = 3;
const max = 10;
const targetWeight = 2;
console.log(countNumbersWithTargetWeight(min, max, targetWeight));  // 输出：4

```

- 9.故障自检通知 : 2.16

某网络有若干节点构成，该网络有一套互相通知及自检模型。

有关键节点和普通节点。节点如果发生故障就是故障源，故障源会通知到下游所有节点

满足以下规则就会触发自检:
1.故障源一定需要自检，若是故障源为关键节点，则会要求其上游所有节点自检
2.收到异常信息的关键节点要自检，这些关键节点也会要求其上游所有节点自检

现在给出一些节点，及其上下游关系，和唯一故障源，请找出所有需要自检的节点，并且以节点编号升序输出

第一个参数是节点及其上下游关系:nodes[i]=[节点id，[下游节点id]]
第二个参数为关键节点列表keynodes
第三个参数为故障源节点


参数1: [
  [20, [10]],
  [10, []],
  [30, [10, 20]],
  [60, [20]],
  [40, [80, 30]],
  [50, [30]],
  [80, []]
]
参数2: [30，10，80]
参数3: 60

输出:[10，20，30，40，50，60]

例如：

输入
参数1： [
  [5, [3]],
  [1, []],
  [2, [5]],
  [3, [1, 2, 4]],
  [4, [5]]
];
参数2： [3]
参数3：3

节点关系描述:
3指向1，2，4
2指向5，
5指向3
4指向5
3为关键节点
也是故障源

输出[2，3，4，5]

- 理解：
    - 注意是：关键节点，极其上游自检，只是通知到下游，*下游节点不一定自检*
        - 故障源必自检；若故障源是关键节点，其上游也自检。
        - 故障源下游如果出现关键节点，则这些关键节点会触发其上游所有节点自检。
- 解法：
    - 利用参数1*构造正向图（存子节点）和反向图（存父节点）*。
    - 从故障源出发，沿正向图遍历，得到所有被通知的节点集合，及关键节点集合。
    - 遍历关键节点，沿反向图做 DFS 上游遍历，把上游节点加入自检集合。
        - 这时使用 visitedUp 来避免重复遍历或无限循环。
- 注意；
    - 构造正向图,反向图： id: [下游节点]，简单的对象映射，id，与下游或者上游id直接对应，不要想复杂了
    - 正向递归，反向递归： 只需要记录当前方向上已经走过的节点，避免死循环就行了。

```

const find = (nodesArr, keyNodes, faultSource) => {
  const newKeyNodes = new Set(keyNodes)
  const graph = {};
  const reverseGraph = {};
  const res = [ faultSource ];

  nodesArr.forEach(([id, arr])=>{
    graph[id] = graph[id] || new Set();
    arr.forEach(nodeId=>{
      graph[id].add(nodeId)
      reverseGraph[nodeId] = reverseGraph[nodeId] || new Set();
      reverseGraph[nodeId].add(id)
    })
  })

  const needReturnkeys = [];
  // 因为是图所以走过的要标记，避免往回走
  const notifiedSet = new Set();
  // 从正向图开始
  const dfs = (rootId) =>{
    if(!rootId) return;
    if(notifiedSet.has(rootId)) return;
    notifiedSet.add(rootId)
    graph[rootId].forEach(id=>{
      if(newKeyNodes.has(id)){
        res.push(id);
        needReturnkeys.push(id)
      }
      dfs(id);
    })
  }

  dfs(faultSource)

  const visitedUp = new Set();
  // 反向图查找,反向图查找时，会不会遇到关键节点呢，会也没关系，反正都在往上游查找的路上嘞
  const dfsRverse = (rootId) => {
    if(!rootId || !reverseGraph[rootId]) return;
    if(visitedUp.has(rootId)) return;
    visitedUp.add(rootId);
    reverseGraph[rootId].forEach(id=>{
      res.push(id);
      dfsRverse(id);
    })
  }
  // console.log(needReturnkeys, reverseGraph, graph)
  needReturnkeys.forEach(id=>{
    return dfsRverse(id)
  })

  return [...new Set(res)].sort((a, b)=>a-b)

}

const nodesArr = [
  [20, [10]],
  [10, []],
  [30, [10, 20]],
  [60, [20]],
  [40, [80, 30]],
  [50, [30]],
  [80, []]
];
// 参数2：关键节点列表
const keyNodes = [30, 10, 80];
// 参数3：故障源
const faultSource = 60;

const nodesArr1 =  [
  [5, [3]],
  [1, []],
  [2, [5]],
  [3, [1, 2, 4]],
  [4, [5]]
];
const keyNodes1 =  [3]
const faultSource1 = 3

console.log(find(nodesArr, keyNodes, faultSource));
console.log(find(nodesArr1, keyNodes1, faultSource1));




```

- 10. 核酸检测耗时： 这题可以多看看，思路一开始没想到  2.16 做完一遍
有函数：g（cost，max，min，target）
参数的含义如下：
cost[i]表示队伍检测一个人的耗时
max，min表队伍最大与最小长度，队伍长度小了，就从等候区进人
target表示人员编号

求target啥时候做完检测

// 疑问，怎么模拟时间推进？

简化思路:

- 找到*下一个完成时间*是解这一题的关键, 怎么模拟时间走动，以及各队伍出人加人,也是一个难点

- 初始化各队伍，从人员编号1开始，往各队伍里放人
- finishTimes 是一个各队伍下一个完成时间的数组，初始值与cost数组相同，那么索引值也就表示队伍编号
- 模拟时间走动，与队伍进出
    - while(true) 循环中：下一个完成时间，就是finishTimes中，最小的；
        - 关键难点： 找到队伍找下一次最小时间后，新当前时间为最小时间，*并且更新该队伍的下一次完成时间*， 以便于下一次循环找到个队伍中的最小时间;
    - 完成队首人员检测并移除
    - 队伍人数不足，则补充

```
function g(cost, max, min, target) {
  const n = cost.length;
  // 初始化各队伍队列，每个队伍补满 max 人
  const queues = Array.from({ length: n }, () => []);
  let nextPerson = 1;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < max; j++) {
      queues[i].push(nextPerson++);
    }
  }
  
  // 初始化各队伍的下一个完成时间，队伍 i 首个完成时间为 cost[i]
  const finishTimes = cost.slice();  // 复制 cost 数组
  
  let currentTime = 0;
  while (true) {
    // 找出下一个完成检测的队伍，及其完成时间
    let team = -1, nextTime = Infinity;
    for (let i = 0; i < n; i++) {
      if (finishTimes[i] < nextTime) {
        nextTime = finishTimes[i];
        team = i;
      }
    }
    // 更新当前时间为最早完成时间
    currentTime = nextTime;
    // 队伍 team 完成队首人员检测
    const finishedPerson = queues[team].shift();
    if (finishedPerson === target) return currentTime;
    
    // 如果队伍人数不足 min，则从等候区补充人员直至队列达到 max
    while (queues[team].length < min) {
      queues[team].push(nextPerson++);
    }
    
    // 更新该队伍下一个完成时间：当前时间 + cost[team]（队伍永远是按 FIFO 处理）
    // 关键代码
    finishTimes[team] = queues[team].length > 0 ? currentTime + cost[team] : Infinity;
  }
}

// 测试示例
// 示例：cost = [3, 5, 7]，max = 2, min = 1, target = 4
// 初始分配（队伍0：1,2；队伍1：3,4；队伍2：5,6）
// 最终函数会返回目标人员 4 检测完成的时间
console.log(g([3, 5, 7], 2, 1, 4));

```


- 11. 请你设计一个内存系统，有以下接口要实现：【第三题】

Memory：系统初始化，blockmem[i]=[size,cnt]表示一种规格的内存信息，系统内存中从内存地址0开始，单位byte，依次且连续划分。每种规格有cnt个大小均为size（单位kb）的内存块。

Alloc(size)：按以下规则尝试在有一个内存块分配size大小的内存：

1.从低地址到高地址依次尝试每个内存块：在内存块内部，不能跨块，从低地址到高地址找到第一个大于等于size大小的连续空闲空间，从该空间的首地址分配size大小的内存。返回本次内存分配的首地址

2.如果遍历完所有没有找到，则返回-1

Free(addr):如果addr是某次已经分配且尚未释放的内存首地址，则释放该内存，并返回true.否则返回false.

Query(size)：查询指定规格为size单位kb的内存块，并且依次返回每个内存块中的空闲空间大小，单位byte，


用例：

输入：
Memory([[2,3]，[4,4]，[5,1]])
Alloc(8)
Alloc(128)

Free(0)
Free(0)

Alloc(120)
Query(2)
Query(5)

输出：
Null
0
8

True
False

136
[1800，2048，2048]
[5120]


思路：

- 内存初始化

    - 根据输入的规格数组（每个规格 size 表示 KB），从地址 0 开始依次划分连续内存块（块大小 = size × 1024 字节）。
    内存块管理
    - 每个内存块维护一个“空闲区间列表”，初始为整个块的区间。

- 内存分配 (Alloc)

 - 按全局地址从低到高扫描内存块，在单个块中寻找满足申请字节数（不跨块）的连续空闲区间，分配后更新空闲区间并记录分配信息。
内存释放 (Free)
 - 根据分配记录定位对应内存块，将释放的区间插入空闲列表，并合并相邻的空闲区间。
查询 (Query)

- 对于指定规格（单位 KB）的内存块，计算每块剩余的空闲字节数，按顺序返回一个数组。

- 关键在于理解内存的释放：把释放的区间插入到按地址排序的空闲列表中，然后扫描整个列表，检查相邻区间是否可以合并成一个更大的空闲区间。

- 内部有小结构：合并相邻区间


```
// 合并区间的辅助函数：对一个区间数组先排序再合并相邻或重叠的区间
function mergeIntervals(intervals) {
  if (intervals.length === 0) return [];
  // 先按起始位置排序
  intervals.sort((a, b) => a[0] - b[0]);
  const merged = [intervals[0]];
  for (let i = 1; i < intervals.length; i++) {
    const last = merged[merged.length - 1];
    const current = intervals[i];
    if (last[1] >= current[0]) {
      // 合并：更新最后区间的结束位置
      last[1] = Math.max(last[1], current[1]);
    } else {
      merged.push(current);
    }
  }
  return merged;
}

// 内存块类，管理单个内存块内部的分配情况
class MemoryBlock {
  /**
   * @param {number} base - 内存块在全局内存中的起始地址（单位 byte）
   * @param {number} size - 内存块大小（单位 byte）
   */
  constructor(base, size) {
    this.base = base;
    this.size = size;
    // freeList：空闲区间列表，每个区间以 [start, end) 表示
    // 初始时整个内存块都是空闲的
    this.freeList = [[base, base + size]];
  }

  /**
   * 在本内存块中分配 total 字节连续空间
   * @param {number} total - 要分配的字节数
   * @return {number} 分配成功返回起始地址，否则返回 -1
   */
  alloc(total) {
    for (let i = 0; i < this.freeList.length; i++) {
      const [s, e] = this.freeList[i];
      if (e - s >= total) {
        const addr = s;
        this.freeList[i][0] = s + total;
        if (this.freeList[i][0] === e) {
          // 此区间用完，移除之
          this.freeList.splice(i, 1);
        }
        return addr;
      }
    }
    return -1;
  }

  /**
   * 释放本内存块中从 addr 开始、长度为 total 的区域
   * 采用先插入区间，再调用 mergeIntervals 合并所有空闲区间的方式
   */
  release(addr, total) {
    // 插入待释放区间到 freeList 中
    this.freeList.push([addr, addr + total]);
    // 合并所有区间
    this.freeList = mergeIntervals(this.freeList);
  }

  /**
   * 返回本内存块当前所有空闲空间总和（单位 byte）
   */
  freeSpace() {
    return this.freeList.reduce((sum, seg) => sum + (seg[1] - seg[0]), 0);
  }
}

// 内存系统类，实现 Memory、Alloc、Free、Query 接口
class MemorySystem {
  /**
   * @param {Array} blockmem - 每个元素 [size, cnt]
   * 其中 size 表示规格（单位 KB），cnt 表示该规格内存块数量
   */
  constructor(blockmem) {
    this.blocks = [];
    let base = 0;
    // 对每种规格，内存块大小 = size * 1024 字节，从地址 0 连续划分
    for (const [size, cnt] of blockmem) {
      const blockSize = size * 1024;
      for (let i = 0; i < cnt; i++) {
        this.blocks.push(new MemoryBlock(base, blockSize));
        base += blockSize;
      }
    }
    // 分配记录：key 为分配返回的首地址，value 为 { blockIndex, total }
    this.allocations = new Map();
  }

  /**
   * Alloc(size)：分配 size 字节内存
   * 从全局内存（按地址从低到高）扫描各内存块，在单个块中寻找连续空闲区间，
   * 成功则记录分配信息并返回分配首地址，找不到返回 -1
   */
  alloc(size) {
    // 此处没有固定开销，实际分配空间 = size
    const total = size;
    for (let i = 0; i < this.blocks.length; i++) {
      const addr = this.blocks[i].alloc(total);
      if (addr !== -1) {
        this.allocations.set(addr, { blockIndex: i, total });
        return addr;
      }
    }
    return -1;
  }


  free(addr) {
    if (!this.allocations.has(addr)) return false;
    const { blockIndex, total } = this.allocations.get(addr);
    this.blocks[blockIndex].release(addr, total);
    this.allocations.delete(addr);
    return true;
  }

 // Query(spec)：查询所有规格为 spec 的内存块当前空闲空间
  query(spec) {
    const targetSize = spec * 1024;
    const res = [];
    for (const block of this.blocks) {
      if (block.size === targetSize) {
        res.push(block.freeSpace());
      }
    }
    return res;
  }
}

// 对外接口示例：
// Memory(blockmem) —— 初始化内存系统
// Alloc(size) —— 分配内存，返回首地址（如果成功）
// Free(addr) —— 释放内存，返回 true 或 false
// Query(spec) —— 查询指定规格内存块空闲空间

// 示例用例（与题目示例对应）：
function testMemorySystem() {
  // Memory([[2,3],[4,4],[5,1]])
  // 表示 3 个 2KB 块、4 个 4KB 块、1 个 5KB 块
  const memsys = new MemorySystem([[2, 3], [4, 4], [5, 1]]);
  console.log("Memory:", null);
  
  // Alloc(8) —— 申请 8 字节内存，预期返回 0
  let ret = memsys.alloc(8);
  console.log("Alloc(8):", ret); // 输出：0
  
  // Alloc(128) —— 申请 128 字节内存，预期返回 8
  ret = memsys.alloc(128);
  console.log("Alloc(128):", ret); // 输出：8
  
  // Free(0) —— 释放地址 0 的分配，预期返回 true
  ret = memsys.free(0);
  console.log("Free(0):", ret); // 输出：true
  
  // Free(0) 再次释放 —— 预期返回 false
  ret = memsys.free(0);
  console.log("Free(0):", ret); // 输出：false
  
  // Alloc(120) —— 申请 120 字节内存，预期返回 136
  ret = memsys.alloc(120);
  console.log("Alloc(120):", ret); // 输出：136
  
  // Query(2) —— 查询规格为 2KB 的内存块空闲空间，预期返回 [1800, 2048, 2048]
  ret = memsys.query(2);
  console.log("Query(2):", ret); // 输出示例：[1800, 2048, 2048]
  
  // Query(5) —— 查询规格为 5KB 的内存块空闲空间，预期返回 [5120]
  ret = memsys.query(5);
  console.log("Query(5):", ret); // 输出示例：[5120]
}

testMemorySystem();

```


- 12. 用定时器系统：一个定时器启动后，每经过一个周期产生一个超时，直到被停止 【2.11 已做一遍】

Sys([])表示初始化定时器系统，所创建的定时器记录在timers里,timer[i]表示定时器编号i，值为timer[i]


Sys([8,4,11]):初始化周期为，8，4，11的3个定时器，返回null
Run(2):截止时刻2没有任何定时器启动返回[]
Start(1):定时器1开始启动，定时器存在，返回true，如果不存在则返回false
Start(4):返回false
Run(8):返回[[6，1]]，表示到时刻8，开始处理所有定时器的超时,1号定时器在时刻6超时
Start(0):true
Start(2):true
Start(1):true
Run(20):[[12，1]，[16,0]，[16,1]，[19,2]，[20,1]]：优先按time升序，同一时刻多个定时器超时，超时记录按定时器编号升序
Stop(1):true，表示停止定时器，不存在则返回false，存在则true
Run(30):[[24,0]，[30,2]]


关键： 
    - 定时器记录元素结构的设计： { period: p, running: false, next: null }
        - period：表示定时器的周期，即每经过多少时间产生一次超时。
        - running：标记定时器是否处于启动状态，只有启动的定时器才会产生超时事件。
        - next：表示定时器下次超时的具体时刻。
            当定时器启动时，将 next 设置为当前时间加上其周期。
            在运行过程中，每当超时事件产生后，就将 next 加上周期，从而得到下一个超时时刻。


```

// 全局变量：系统当前时刻
let currentTime = 0;

// 定时器数组，保存各定时器信息：{ period, running, next }
let timers = [];

// 初始化定时器系统。关键点：
function Sys(periods) {
  currentTime = 0;
  timers = periods.map(p => ({ period: p, running: false, next: null }));
  return null;
}


function Run(t) {
  let events = [];
  // 对于每个定时器，若它正在运行，则依次模拟其超时事件
  for (let i = 0; i < timers.length; i++) {
    let timer = timers[i];
    if (timer.running) {
      // 如果定时器的下次超时时刻 next 还没有设置（说明刚启动），则应已经由 Start 设置
      // 模拟：只要 timer.next <= t 就不断添加超时记录，并将 next 加周期
      while (timer.next !== null && timer.next <= t) {
        events.push([timer.next, i]);
        timer.next += timer.period;
      }
    }
  }
  // 按事件时间、再按定时器编号排序： 如果为 0，说明第一个条件相等，这时 || 运算符会返回后面的值
  // 多个条件的排序： 这种写法会先比较 a[0] 和 b[0] 的大小，如果不相等就返回差值；只有当 a[0] === b[0] 时，才会比较第二个条件 a[1] 和 b[1]。
  events.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
  currentTime = t;
  return events;
}


function Start(i) {
  if (i < 0 || i >= timers.length) return false;
  timers[i].running = true;
  timers[i].next = currentTime + timers[i].period;
  return true;
}


function Stop(i) {
  if (i < 0 || i >= timers.length) return false;
  if (!timers[i].running) return false;
  timers[i].running = false;
  timers[i].next = null;
  return true;
}


// 以下是一个测试调用示例
function testTimerSystem() {
  console.log("Sys([8,4,11]):", Sys([8, 4, 11]));  // 输出 null
  
  console.log("Run(2):", Run(2));  // 应输出 []
  
  console.log("Start(1):", Start(1));  // 输出 true
  console.log("Start(4):", Start(4));  // 输出 false
  
  console.log("Run(8):", Run(8));  // 应输出 [[6,1]]
  
  console.log("Start(0):", Start(0));  // 输出 true
  console.log("Start(2):", Start(2));  // 输出 true
  console.log("Start(1):", Start(1));  // 输出 true （重新启动定时器1）
  
  console.log("Run(20):", Run(20));  // 输出 [[12,1],[16,0],[16,1],[19,2],[20,1]]
  
  console.log("Stop(1):", Stop(1));  // 输出 true
  
  console.log("Run(30):", Run(30));  // 输出 [[24,0],[30,2]]
}

testTimerSystem();



```

- 13. 连接负载均衡： 主要是思路，代码好写，看看记记就行 2.16

两地之间有fibernum条光纤，一条光纤允许多个连接。两地需要若干个连接，每个连接可以建立在任何一条光纤上

每条光纤宽带容量固定为100，给定所需建立的连接及所需宽带，记录于数组connects中，connect[i]表示一个连接所需的宽带，请计算一种分配方案，所有连接分配后使得光纤上的负载尽量均衡：

使用 宽带利用差  来衡量宽带使用的均衡度，宽带利用差=所有光纤中被消耗带宽的最大值-所有光纤中被消耗宽带的最小值

请计算并输出 宽带利用差 最小值，如果宽带无法容纳这些连接，返回-1

输入： 
 2
[15，25，15，20，20]

输出：5

输入：
2
[50，60，60]

输出：-1

输入：
3
[15，25]

输出：25

思路：
    - 如果问题要求对多个决策（或选择）进行组合安排、分配或排列，且每个决策都有几个有限的选项，那么它通常属于组合枚举/排列组合或决策树搜索类问题。


```
function balanceLoad(fibernum, connects) {
  const m = fibernum;           // 光纤数
  const n = connects.length;    // 连接数
  let minDiff = Infinity;
  
  // loads 数组记录每条光纤当前的负载（单位：带宽），初始均为 0
  let loads = Array(m).fill(0);
  
  // 递归函数：处理第 i 个连接
  function dfs(i) {
    // 当所有连接均已分配，检查当前方案的利用差
    if (i === n) {
      let currentMax = Math.max(...loads);
      let currentMin = Math.min(...loads);
      minDiff = Math.min(minDiff, currentMax - currentMin);
      return;
    }
    // 尝试将第 i 个连接分配到每条光纤上
    for (let j = 0; j < m; j++) {
      // 检查分配后该光纤的负载不超过 100
      if (loads[j] + connects[i] <= 100) {
        loads[j] += connects[i];
        dfs(i + 1);
        loads[j] -= connects[i];  // 回溯
      }
    }
  }
  
  dfs(0);
  return (minDiff === Infinity) ? -1 : minDiff;
}

// 测试用例
// 示例 1：
console.log(balanceLoad(2, [15, 25, 15, 20, 20]));  // 输出：5

// 示例 2：
console.log(balanceLoad(2, [50, 60, 60]));  // 输出：-1

// 示例 3：
console.log(balanceLoad(3, [15, 25]));  // 输出：25



```


- 14. 贵重仪表租借： 2.17 看了一遍思路

某些实验室有些贵重仪表，需要进行租借管理，请实现：

Sys(labs):系统初始化，labs为所有实验室的仪表信息，labs[i]=[labid,type]表示labid实验室有一台类型为type的仪表。每种类型的仪表可能有多个，但一个实验室最多只有一个

Rent(user，labid，type)：用户user向实验室labid租借类型位type的仪表

 若用户已经借有该仪表（包括借了但是还没借到），或者已经在任一个实验室此类型仪表的 租借等待队列中，或者该实验室没有该仪表，返回-1

如果该实验室有该仪表，但是已经被借出，则user加到该实验室仪表的租借等待队列末尾，返回0

如果该实验室有该仪表，且尚未被借出，返回1

back(user，type):用户user讲类型为type的仪表返还给仪表所属实验室

如果user已经借有该类型仪表，则返还成功，并返回仪表所属实验室id

如果此仪表的 租借等待队列不为空，则队列中第一个用户借到该仪表，并自动移出队列

否则，返回-1

Report(user):查询用户user当前已经借到的所有仪表type列表，升序返回。如果没有返回空数组

输入：
Sys([[2，2]，[1，1]，[2，1])
Rent(8,2,1)
Report(8)
Rent(11,2,1)
Rebt(11,1,1)
Back(8,1)
Report(8)
Report(11)

输出：
Null
1
[1]
0
-1
2
[]
[1]



- 思路：
    - 做这种题数据结构要定义清楚，不然写着写着容易忘，容易混乱
    - 设计到多个实体的关联关系，以及状态更新，*需要从操作出发，观察各操作都涉及到的实体，或与其他实体都有直接关系的实体，作为关键实体，来重点设计*，重点设计包含多个状态的对象作为中介实体（如 仪器状态、用户状态），这个实体的属性通常关联着其他实体，作为一个各种操作之间的中间桥梁，然后根据需要再补充一些其他简单数据结构，如对象存储等
    - 核心数据结构：

        instruments 数组：存储所有仪器的状态，每个元素包含：
            lab：实验室 id。
            type：仪器类型。
            rentedBy：当前借用者（如果仪表被借出，否则为 null）。可以同时表示是否被借出
            waiting：等待该仪器的用户队列（先进先出）。
        userRentals 映射：记录每个用户当前租借的仪器类型，使用 Set 存储，避免重复租借。
        userWaitings 映射：记录每个用户正在等待的仪器类型，使用 Set 存储，避免重复加入等待



        Rent(user, labid, type)：
            检查用户是否已经借用该类型仪器，或是否在任何实验室的等待队列中。
            查找指定实验室是否有该仪器，如果有且未被租出，则直接借给用户并更新状态。
            如果仪器已租出，则将用户加入该仪器的等待队列。
        Back(user, type)：
            查找用户是否持有该类型仪器，如果有则返还仪器，并从用户租借记录中删除。
            如果仪器的等待队列不为空，则自动将队列中的第一个用户借出该仪器，更新相关状态。
        Report(user)：
            查询用户已租借的所有仪器类型，按升序返回。

```



// 全局数据结构
let instruments = [];       // 所有仪表，数组中每个元素形如 { lab, type, rentedBy, waiting }
let userRentals = new Map();  // key: user id, value: Set of instrument types已租借
let userWaitings = new Map(); // key: user id, value: Set of instrument types已在等待

// 初始化系统，labs 数组中每个元素形如 [labid, type]
function Sys(labs) {
  instruments = [];
  userRentals.clear();
  userWaitings.clear();
  for (let [labid, type] of labs) {
    instruments.push({
      lab: labid,
      type: type,
      rentedBy: null,
      waiting: []  // 队列：先进先出
    });
  }
  return null;
}

// 辅助：规范化端口顺序，返回 [p,q] 使 p <= q
function normalize(a, b) {
  return (a <= b) ? [a, b] : [b, a];
}

// 用户租借仪表
// Rent(user, labid, type)
function Rent(user, labid, type) {
  // 检查用户是否已租借此类型仪表
  if (userRentals.has(user) && userRentals.get(user).has(type)) return -1;
  // 检查用户是否已在等待该类型仪表的队列中（在任何仪表中）
  if (userWaitings.has(user) && userWaitings.get(user).has(type)) return -1;
  
  // 查找指定实验室是否有该类型仪表
  let instrument = instruments.find(inst => inst.lab === labid && inst.type === type);
  if (!instrument) return -1;
  
  if (instrument.rentedBy === null) {
    // 仪表可租，直接分配给用户
    instrument.rentedBy = user;
    if (!userRentals.has(user)) userRentals.set(user, new Set());
    userRentals.get(user).add(type);
    return 1;
  } else {
    // 仪表已租，将用户加入等待队列
    instrument.waiting.push(user);
    if (!userWaitings.has(user)) userWaitings.set(user, new Set());
    userWaitings.get(user).add(type);
    return 0;
  }
}

// 用户归还仪表
// Back(user, type)
function Back(user, type) {
  // 查找用户是否租借了该类型仪表
  let instrument = instruments.find(inst => inst.type === type && inst.rentedBy === user);
  if (!instrument) return -1;
  
  // 记下所属实验室
  let labid = instrument.lab;
  // 用户归还，将仪表置为未租借，并更新用户租借记录
  instrument.rentedBy = null;
  if (userRentals.has(user)) {
    userRentals.get(user).delete(type);
    if (userRentals.get(user).size === 0) {
      userRentals.delete(user);
    }
  }
  
  // 如果等待队列不为空，则自动分配给等待队列中的第一个用户
  if (instrument.waiting.length > 0) {
    let nextUser = instrument.waiting.shift();
    instrument.rentedBy = nextUser;
    // 从等待记录中移除
    if (userWaitings.has(nextUser)) {
      userWaitings.get(nextUser).delete(type);
      if (userWaitings.get(nextUser).size === 0) {
        userWaitings.delete(nextUser);
      }
    }
    // 更新租借记录
    if (!userRentals.has(nextUser)) userRentals.set(nextUser, new Set());
    userRentals.get(nextUser).add(type);
  }
  
  return labid;
}

// 查询用户已租仪表类型，Report(user)
function Report(user) {
  if (!userRentals.has(user)) return [];
  let arr = Array.from(userRentals.get(user));
  arr.sort((a, b) => a - b);
  return arr;
}

/* ------------- 测试用例 ------------- */
// 示例 1：
const config1 = [[2,2],[1,1],[2,1]];
// 表示：实验室2有一台类型2的仪表，实验室1有一台类型1的仪表，实验室2有一台类型1的仪表
const reqs1 = [
  ['a', 2, 1],  // Rent(8,2,1)：用户8向实验室2租借类型1仪表 → 应返回1（仪表可租）
  // 但为了和样例完全对应，我们假设后续调用分别调用 Report、Rent 等
];
console.log(Sys(config1));        // 输出：Null
console.log(Rent(8, 2, 1));         // 输出：1
console.log(Report(8));           // 输出：[1]
console.log(Rent(11, 2, 1));        // 输出：0  (用户11进入等待队列)
console.log(Rent(11, 1, 1));        // 输出：-1 (用户11已在等待某类型1仪表)
console.log(Back(8, 1));          // 输出：2 (用户8归还仪表，仪表所属实验室为2；用户11自动借到)
console.log(Report(8));           // 输出：[]
console.log(Report(11));  // 输出：[1]




```

- 15. 安全的密码

给定一个用户名user名和字符串pwd，需要从pwd中找出一个子串作为安全的密码，密码必须满足以下条件：

至少包含一个大写字母
至少包含一个小写字母或者数字
至少包含一个特殊字符.!@#$％
6<=密码长度<=12
密码中任意一个子串不能与给定的用户名相同(大小写敏感)

如果有多个满足条件，选择字典序最小的.不存在则返回empty

参数一： 长度在3到5

输入：
John
abcABC@dd

输出：ABC@dd

输入：
John
John@huawei.com

输出:empty

- 思路：
    - *滑动窗口通常用于寻找满足条件的最小或最大窗口，或者在窗口大小可变的情况下寻找最优解*，而这里窗口大小是固定且离散的（6,7,…,12），直接枚举每个可能的长度更简单。
    - 固定窗口大小区间，多重条件判断，不是求最优解的子串，可以有限考虑遍历，而不是滑动窗口
- 特殊点：
    - 字典序为啥不用localeCompare
        - 对字符串数组调用 sort() 会按照 UTF-16 编码顺序进行排序，对于纯 ASCII 字符（如题目中的字母、数字和常用符号）来说，这通常就等同于字典序排序。
        - 使用 localeCompare 的优点在于它可以根据特定区域设置（locale）进行排序，从而处理国际化字符、语言特定的排序规则等情况

- 理解：遍历窗口的长度范围是关键

```

function securePassword(user, pwd) {
  const upperRegex = /[A-Z]/;
  const lowerOrDigitRegex = /[a-z0-9]/;
  const specialRegex = /[.!@#$%]/;
  let valid = [];
  let n = pwd.length;
  
  // 枚举所有长度在6到12的子串
  for (let len = 6; len <= 12; len++) {
    for (let i = 0; i <= n - len; i++) {
      let sub = pwd.substring(i, i + len);
      
      // 检查条件
      if (!upperRegex.test(sub)) continue;           // 至少有一个大写字母
      if (!lowerOrDigitRegex.test(sub)) continue;      // 至少有一个小写字母或数字
      if (!specialRegex.test(sub)) continue;           // 至少有一个特殊字符
      if (sub.indexOf(user) !== -1) continue;            // 子串中不能出现用户名
      
      valid.push(sub);
    }
  }
  
  if (valid.length === 0) return "empty";
  
  // 按字典序排序并返回第一个
  valid.sort();
  return valid[0];
}

// 测试用例

// 示例 1：
let user1 = "John";
let pwd1 = "abcABC@dd";
console.log(securePassword(user1, pwd1));  // 预期输出："ABC@dd"

// 示例 2：
let user2 = "John";
let pwd2 = "John@huawei.com";
console.log(securePassword(user2, pwd2));  // 预期输出："empty"


```

- 16. Cache管理： 【第三题】， 感觉这一题很麻烦，理解题意都得20分钟，代码还多，就算弄懂了没一个半小时也拿不下来
    - 题目较难，放后面做；


要访问(读写)一个内存数据时，首先从cache找，找到就立即读写，没找到，就从mem(内存)读取，并把这个数据调入cache

请实现缓存方案：

缓存由4个group级联组成，编号0-3，每个group固定有8个line，编号0-7，每个line固定128byte

Line有两种状态：占用used和空闲idle，初始为idle
Line有一个属性：命中次数hitcnt，初始为0

内存按byte编址，从地址0开始以128Byte对齐方式，分为一个一个的映射内存块，地址范围为[128*i，128*（i+1）)

现在给定一批操作op，op[i]=[opcode，memaddr，memlen]，分别表示操作码，内存地址，内存长度，依次处理每个命令：

首先，根据内存范围[memaddr，memaddr+memlen]，确定涉及的内存映射块：与该范围重叠的所有内存块：

如范围[0x4A000082，0x4A000182]所涉及的映射内存块有三块，映射内存块首地址分别为：0x4A000080,0x4A000100,0x4A000180

然后按照opcode操作，取值仅以下2种：

opcode==1，为读或者写操作，对涉及的映射内存地址块从低地址开始，按照映射规则逐块处理：

先映射到某个group：取映射内存块首地址的高4bit值，假设为val，val%4所得值即为映射的group编号

再找该group内的line：

如果已经映射到某line，则命中，对应hitcnt加1
否则，从编号0顺序查找第一个idle的line，若与idle，则找到最久未被读或写的line，解除原映射。再将映射内存块与找到的line建立新映射，并将该line置为used，hitcnt置为1

Opcode为3时，对涉及的内存块解除映射，并将对应已经映射的line置为idle，hitcnt置为0


完成所有操作后，返回所有used状态的line信息，列表，格式为[映射内存块首地址,hitcnt]，优先按group升序，其次在group内按line升序

Memaddr为0x开头的16进制字符串。

输入：
[[1，0x20000000,1024],[1，0x20000200，512],[1，0x20000200,318],[1，0x20000000,512],[1，0x20012000,256]]

输出：
输出也是二维数组，为了书写方便，省略中括号[]，以下内容对外数组中。
[]
0x20000000,2
0x20000080,2
0x20000100,2
0x20000180,2
0x20012080,1
0x20000280,3
0x20000300,3
0x20012000,1


思路：
- 这道题比较复杂，主要难点在于如何将内存映射块映射到对应的 cache 组和行，并在读写（opcode==1）和删除（opcode==3）操作中正确更新每一行的状态（used/idle）以及 hitcnt。
- 映射块计算：根据给定的内存范围，按 128 字节对齐求得所有映射块（即 [128i, 128(i+1)) 与范围重叠的块）。
Cache 分组与行：Cache 分为 4 个组，每组 8 行，每行记录映射块的 tag、hitcnt 以及状态（used/idle）。
- 映射规则：
    - 对于读/写操作（opcode==1），按映射块从低到高顺序处理：
        - 计算组号：用 (mappingBlock/128) % 4（即利用映射块编号模 4）；
        - 检查该组中是否已有行映射到此块（命中则 hitcnt 加1）；否则，选择一空闲行（或若无空闲则选 hitcnt 最低的）进行替换，建立新映射，hitcnt 置1。
    - 对于删除操作（opcode==3），在对应组中找到映射行并将其状态重置为 idle，hitcnt 置 0。
- 最终输出：遍历 cache 中所有 used 行，按组号和行号排序，输出 [映射块起始地址（16进制字符串）, hitcnt]。
- 这种设计思想侧重于从映射块出发，将其映射到全局 cache 中的相应组和行，并通过 hitcnt 记录访问情况。整个方案虽然细节较多，但分步骤实现后比较清晰。这种解法思路与实现在考试中可以作为一个模板，关键在于把“映射块”、“组”、“行”以及各自状态维护清楚，再根据操作更新状态。

```
// 辅助函数：将 16 进制字符串转换为整数
function hexToInt(hexStr) {
  return parseInt(hexStr, 16);
}

// 辅助函数：将整数转换为 0x 开头的 8 位 16 进制字符串
function intToHex(num) {
  return "0x" + num.toString(16).toUpperCase().padStart(8, "0");
}

// 辅助函数：计算映射块起始地址（128 字节对齐）
function getMappingBlock(addr) {
  return Math.floor(addr / 128) * 128;
}

// 根据内存范围 [memaddr, memaddr+memlen) 计算所有重叠的映射块（按地址升序）
function getMappingBlocks(memaddr, memlen) {
  let addr = hexToInt(memaddr);
  let end = addr + memlen;
  let blocks = [];
  for (let start = getMappingBlock(addr); start < end; start += 128) {
    blocks.push(start);
  }
  return blocks;
}

// 计算组号：用映射块地址除以128后取模4
function getGroupId(mappingBlock) {
  return (mappingBlock / 128) % 4;
}

// 初始化 cache：4 个组，每组 8 行
let cache = [];
function initCache() {
  cache = [];
  for (let g = 0; g < 4; g++) {
    let group = [];
    for (let l = 0; l < 8; l++) {
      group.push({ tag: null, hitcnt: 0, state: "idle" });
    }
    cache.push(group);
  }
}

// 处理 opcode==1 操作：读/写操作
function processMappingBlock(mappingBlock) {
  let groupId = getGroupId(mappingBlock);
  let group = cache[groupId];
  // 查找是否已有该映射
  for (let line of group) {
    if (line.tag === mappingBlock) {
      line.hitcnt += 1;
      return;
    }
  }
  // 未命中：在该组中寻找空闲行（从编号0顺序查找）
  let candidate = null;
  for (let i = 0; i < group.length; i++) {
    if (group[i].state === "idle") {
      candidate = { line: group[i], index: i };
      break;
    }
  }
  // 如果没有空闲行，则选择 hitcnt 最小的行（如果有多个，则按行号较小的）
  if (!candidate) {
    let minHit = Infinity;
    let chosenIndex = -1;
    for (let i = 0; i < group.length; i++) {
      if (group[i].hitcnt < minHit) {
        minHit = group[i].hitcnt;
        chosenIndex = i;
      }
    }
    candidate = { line: group[chosenIndex], index: chosenIndex };
  }
  // 将 candidate 行原有映射解除（直接覆盖），建立新映射
  candidate.line.tag = mappingBlock;
  candidate.line.hitcnt = 1;
  candidate.line.state = "used";
}

// 处理 opcode==3 操作：删除映射
function removeMapping(mappingBlock) {
  let groupId = getGroupId(mappingBlock);
  let group = cache[groupId];
  for (let line of group) {
    if (line.tag === mappingBlock) {
      line.tag = null;
      line.hitcnt = 0;
      line.state = "idle";
      return;
    }
  }
}

// 主函数：处理一批操作，op 格式为 [opcode, memaddr, memlen]
function processOps(ops) {
  // 初始化 cache
  initCache();
  // 对每个操作依次处理
  for (let op of ops) {
    let [opcode, memaddr, memlen] = op;
    let blocks = getMappingBlocks(memaddr, memlen);
    if (opcode === 1) {
      // 读/写操作：对涉及的映射块按升序依次处理
      for (let block of blocks) {
        processMappingBlock(block);
      }
    } else if (opcode === 3) {
      // 删除操作：解除映射
      for (let block of blocks) {
        removeMapping(block);
      }
    }
  }
  // 生成最终输出：遍历所有 cache 组和行，取出 state 为 "used" 的行
  let results = [];
  for (let g = 0; g < cache.length; g++) {
    for (let l = 0; l < cache[g].length; l++) {
      let line = cache[g][l];
      if (line.state === "used") {
        results.push({ group: g, line: l, tag: line.tag, hitcnt: line.hitcnt });
      }
    }
  }
  // 按组升序，再按行升序
  results.sort((a, b) => a.group - b.group || a.line - b.line);
  // 将结果转换为二维数组 [tag (hex string), hitcnt]
  return results.map(r => [intToHex(r.tag), r.hitcnt]);
}

//
// 测试用例
//

function testCache() {
  // 示例输入操作：
  // [[opcode, memaddr, memlen], ...]
  let ops = [
    [1, "0x20000000", 1024],
    [1, "0x20000200", 512],
    [1, "0x20000200", 318],
    [1, "0x20000000", 512],
    [1, "0x20012000", 256]
  ];
  
  let res = processOps(ops);
  console.log("最终输出：", res);
}

testCache();



```

- 17. 电动汽车行驶问题 【第三题】二维动态规划，挺难理解的: 脑子清醒的时候可以看估计得个把小时，才能完全理解

一辆电动汽车从工作地回家，车的最大充电容量是maxEnergy，路上有一个或者多个充电站，首站在工作地，编号为0，charges[i]表示充电站i每充一个单位的电量需要的时长，costs[i]表示从充电站i到下一站需要的电量，最后一个表示末站到家消耗的电量。假设汽车初始电量为0，请计算从工作地到家全程需要的最短充电时间，如果无法到家返回-1

输入
第一个参数表示，电动车最大充电量，在1到1000之间
第二个参数表示charges数组，长度小于等于100，值也小于等于100
第三个参数是costs数组，长度与charges相同，值也小于等于100


例子1:
输入：
6
[3，2，5，4，9，1]
[3，3，2，3，4，1]

输出：51


例子2:
1
[1，2，3，4]
[2，2，3，4]

输出:-1
要求圈复杂度小于20，小于10为佳，嵌套深度小于8

理解： 
    - 这道题可以理解为一个最短路径问题，实际上可以将问题抽象成一个图的遍历问题，其中每个充电站就是图中的一个节点，每个节点的边代表从一个充电站到下一个充电站所需的电量和充电时间。目标是从工作地出发，最终到达家，找出最短的充电时间路径。
    - 这类最短路径问题通常可以通过动态规划来解。每个充电站的状态不仅仅是站点，还包含当前的电量，电量的上限为最大充电容量 maxEnergy。
    - 状态表示
        - 定义 f[i][j] 代表在第 i 个充电站，电量为 j 时的最短充电时间。（注意i表示第几，不是表示索引，比索引大1）
        - 起始状态为 f[1][0] = 0 表示从工作地出发时，电量为 0 时的充电时间为 0。
        - 2. 不充电的状态转移：
            - preCost 计算前一个充电站的电量状态，加上到达下一个充电站所需的电量 costs[i-2]，得到新的电量状态。
            - 使用 f[i][j] = Math.min(f[i][j], f[i-1][preCost]) 来更新当前充电站的状态。
        - 3. 充电的状态转移：
            - 对于每个电量状态 j，尝试充电到 k，并通过 f[i][k] = Math.min(f[i][k], f[i][j] + (k - j) * charges[i-1]) 来更新充电时间。
        - 4.  最后的状态计算：最后，我们通过遍历 f[charges.length][t] 来找到最短的充电时间。如果找不到有效的路径，返回 -1。
，

```

function minChargingTime(maxEnergy, charges, costs) {
  const INF = 2e8;  // 一个非常大的值，用于初始化不可达的状态
  let f = Array(101).fill().map(() => Array(1001).fill(INF));  // 初始化DP数组
  
  f[1][0] = 0;  // 初始状态，电量为0时，充电时间为0
  
  // 遍历所有充电站
  for (let i = 1; i <= charges.length; i++) {
    for (let j = 0; j <= maxEnergy; j++) {
      // 处理不充电的情况：检查前一个充电站的状态是否能转移到当前充电站
      if (i > 1) {
        const preCost = j + (costs[i - 2] || 0);  // 计算到达下一站的电量
        if (preCost <= 1000) {
          f[i][j] = Math.min(f[i][j], f[i - 1][preCost]);  // 转移前一个充电站的状态
        }
      }

      // 处理充电的情况：尝试给当前电量充电
      for (let k = j + 1; k <= maxEnergy; k++) {
        f[i][k] = Math.min(f[i][k], f[i][j] + (k - j) * charges[i - 1]);  // 更新充电时间
      }
    }
  }

  // 获取最短的充电时间
  let t = costs[costs.length - 1] || 0;  // 最后一个充电站到家的电量消耗
  let ans = f[charges.length][t];  // 获取最后充电站的最短充电时间
  
  return ans === INF ? -1 : ans;  // 如果没有有效路径，返回 -1
}


// 测试用例
console.log(minChargingTime(6, [3, 2, 5, 4, 9, 1], [3, 3, 2, 3, 4, 1]));  // 输出：51
console.log(minChargingTime(1, [1, 2, 3, 4], [2, 2, 3, 4]));  // 输出：-1







```







- 18. 页面置换：


操作系统在分页内存管理机制下，把进程使用的虚拟内存划分成大小相等的若干页，每页有个编号，物理内存也按同样的大小分为num个页框，进程访问某页数据时，需要把该页数据缓存存入物理内存的一个页框进行访问。已经缓存的页需要记录两个属性：访问次数，访问时间

某段时间内，进程先后访问虚拟内存中页的信息，记录于pages，pages[i]表示要访问页的编号，请计算依次访问完成后发生的页置换的次数。访问规则：

若访问页已缓存在某页框，则该页的访问次数加1，并更新访问时间为最新

若访问的页面没缓存在某个页框，则产生缺页中断，此时：

如果有空闲页框，则选择其中一个用于缓存该页，设置该页的访问次数为1，访问时间为最新。

如果没有空闲页框，则发生一次页置换，，置换出一页用于缓存。设置新缓存页的访问次数为1，访问时间为最新。

置换策略:

1.首先，将页框中缓存的页按访问时间先后，选择前size个页作为过期候选
2.从这些过期候选中优先选择访问次数最少的，如果有多个，则选择最久未访问的

输入：
Num
Size
Pages

输出：
置换次数

样例1：
输入：
3
2
[51，52，53，54，54，51，52，53，54]

输出：4

样例2:
4
3
[1，1，30，20，5，6，5，20，5，20，1，6，7，6]

输出:2

圈复杂度小于10，嵌套深度小于8



```

function pageReplacement(num, size, pages) {
  let cache = [];  // 用于缓存页面，存储 {页号, 访问次数, 访问时间}
  let replaceCount = 0;  // 记录置换次数
  let time = 0;  // 访问时间（模拟时间）

  for (let page of pages) {
    time++;
    
    // 检查页面是否已经在缓存中
    let cachedPage = cache.find(entry => entry.page === page);
    if (cachedPage) {
      // 页面已缓存，更新访问次数和访问时间
      cachedPage.accessCount++;
      cachedPage.accessTime = time;
    } else {
      // 页面不在缓存中，发生缺页中断
      if (cache.length < num) {
        // 有空闲页框，直接加入
        cache.push({ page, accessCount: 1, accessTime: time });
      } else {
        // 没有空闲页框，发生置换
        // 选择前 size 个候选页，按访问时间先后排序
        let candidates = cache.sort((a, b) => a.accessTime - b.accessTime).slice(0, size);
        // 从这 `size` 个候选中选择访问次数最少的
        candidates.sort((a, b) => a.accessCount - b.accessCount || a.accessTime - b.accessTime);
        // 置换最少访问次数的页面
        let pageToReplace = candidates[0];
        // 更新缓存，置换出该页面
        let index = cache.indexOf(pageToReplace);
        cache[index] = { page, accessCount: 1, accessTime: time };
        replaceCount++;
      }
    }
  }
  
  return replaceCount;
}

// 测试用例
console.log(pageReplacement(3, 2, [51, 52, 53, 54, 54, 51, 52, 53, 54]));  // 输出：4
console.log(pageReplacement(4, 3, [1, 1, 30, 20, 5, 6, 5, 20, 5, 20, 1, 6, 7, 6]));  // 输出：2




```

- 19. 模拟编辑器

模拟编辑器

+：换行，把光标后的作为新行
～：删左边字符，如果在行首，将当前行拼接到上一行（如果存在）行尾
-：删除右边字符，当光标在行尾，下一行如果存在，拼接到当前行行尾
a到z：在光标位置输入一个字符
@：切换大小写
^*<>分别表示上下左右方向键：
左右移动时：
当光标在行首，左移时会移到上一行行尾(如果存在)
当光标在行尾，右移时会移到下一行（如果存在）行首
上下移动时：

在首行上移，尾行下移无效

相邻行：如果目标行长度小于光标所在列位置，则光标移动到目标行行尾。


输入：

za+b+cd^*e^^～*～>>～

得到：

["abced"]



```

class Editor {
  constructor() {
    this.lines = ['']; // 初始时只有一个空行
    this.cursorRow = 0; // 光标初始行
    this.cursorCol = 0; // 光标初始列
  }

  // 移动光标到上一行
  moveCursorUp() {
    if (this.cursorRow > 0) {
      this.cursorRow--;
      this.cursorCol = Math.min(this.cursorCol, this.lines[this.cursorRow].length);
    }
  }

  // 移动光标到下一行
  moveCursorDown() {
    if (this.cursorRow < this.lines.length - 1) {
      this.cursorRow++;
      this.cursorCol = Math.min(this.cursorCol, this.lines[this.cursorRow].length);
    }
  }

  // 移动光标到左边
  moveCursorLeft() {
    if (this.cursorCol > 0) {
      this.cursorCol--;
    } else if (this.cursorRow > 0) {
      this.cursorRow--;
      this.cursorCol = this.lines[this.cursorRow].length;
    }
  }

  // 移动光标到右边
  moveCursorRight() {
    if (this.cursorCol < this.lines[this.cursorRow].length) {
      this.cursorCol++;
    } else if (this.cursorRow < this.lines.length - 1) {
      this.cursorRow++;
      this.cursorCol = 0;
    }
  }

  // 切换大小写
  toggleCase() {
    let char = this.lines[this.cursorRow][this.cursorCol];
    if (char === char.toUpperCase()) {
      this.lines[this.cursorRow] = this.lines[this.cursorRow].slice(0, this.cursorCol) + char.toLowerCase() + this.lines[this.cursorRow].slice(this.cursorCol + 1);
    } else {
      this.lines[this.cursorRow] = this.lines[this.cursorRow].slice(0, this.cursorCol) + char.toUpperCase() + this.lines[this.cursorRow].slice(this.cursorCol + 1);
    }
  }

  // 在光标位置插入字符
  insertChar(char) {
    this.lines[this.cursorRow] = this.lines[this.cursorRow].slice(0, this.cursorCol) + char + this.lines[this.cursorRow].slice(this.cursorCol);
    this.cursorCol++;
  }

  // 删除光标左边的字符
  deleteLeftChar() {
    if (this.cursorCol > 0) {
      this.lines[this.cursorRow] = this.lines[this.cursorRow].slice(0, this.cursorCol - 1) + this.lines[this.cursorRow].slice(this.cursorCol);
      this.cursorCol--;
    } else if (this.cursorRow > 0) {
      this.cursorCol = this.lines[this.cursorRow - 1].length;
      this.lines[this.cursorRow - 1] += this.lines[this.cursorRow];
      this.lines.splice(this.cursorRow, 1);
      this.cursorRow--;
    }
  }

  // 删除光标右边的字符
  deleteRightChar() {
    if (this.cursorCol < this.lines[this.cursorRow].length) {
      this.lines[this.cursorRow] = this.lines[this.cursorRow].slice(0, this.cursorCol) + this.lines[this.cursorRow].slice(this.cursorCol + 1);
    } else if (this.cursorRow < this.lines.length - 1) {
      this.lines[this.cursorRow] += this.lines[this.cursorRow + 1];
      this.lines.splice(this.cursorRow + 1, 1);
    }
  }

  // 换行
  newLine() {
    let line = this.lines[this.cursorRow].slice(this.cursorCol);
    this.lines[this.cursorRow] = this.lines[this.cursorRow].slice(0, this.cursorCol);
    this.lines.splice(this.cursorRow + 1, 0, line);
    this.cursorRow++;
    this.cursorCol = 0;
  }

  // 执行命令
  executeCommand(command) {
    if (command === '+') {
      this.newLine();
    } else if (command === '～') {
      this.deleteLeftChar();
    } else if (command === '-') {
      this.deleteRightChar();
    } else if (command === '@') {
      this.toggleCase();
    } else if (command === '^') {
      this.moveCursorUp();
    } else if (command === '*') {
      this.moveCursorDown();
    } else if (command === '<') {
      this.moveCursorLeft();
    } else if (command === '>') {
      this.moveCursorRight();
    } else {
      this.insertChar(command); // 输入字符
    }
  }

  // 返回当前的文本内容
  getResult() {
    return this.lines;
  }
}

function simulateEditor(commands) {
  const editor = new Editor();

  for (let command of commands) {
    editor.executeCommand(command);
  }

  return editor.getResult();
}

// 测试用例
console.log(simulateEditor(['z', 'a', '+', 'b', '+', 'c', 'd', '^', '*', 'e', '^', '^', '～', '*', '～', '>', '>', '～']));  // ["abced"]




```
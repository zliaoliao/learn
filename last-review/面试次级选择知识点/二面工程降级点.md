ps： 本篇记录二面工程，不一定会问的但是有时间可以了解的知识点



# 登录

暂时可以不看，没人问过，复杂且偏，知道cookie,session, jwt就行了

## 单系统登录

- 1. 注册APP时，你填写用户名和密码
- 2. 后台肯定需要“存储你的用户名和密码”，为后面的登录验证做准备。

但是，不能让黑客看见密码，要从技术上禁止，所以要加密， 而且是不可拟的加密（后台也不能知道用户密码是多少）

所以可以考虑*对密码进行哈希变换后存储， 因为哈希函数不可逆， 把密码盗走也没用*；

但是*黑客可以用彩虹表攻击， 黑客对一些常用密码进行哈希，形成一张很大的资料表*， 一旦黑客盗走数据库中的密码哈希值，就可以在资料表中进行查找。

总之：
- 1. 密码直接哈希存储；
  - 无法对抗彩虹表攻击， 基本无人使用
  -  多次hash,万一黑客拿到你多次哈希的程序代码的，也是可以用彩虹表破解的；
- 2. 固定盐值哈希存储
  -  `P = hash(user + hash(password)) `, 在攻击一些重要user时，黑客可能感觉值得尝试一下，也是能分分钟进行破解的。所以，用固定盐还是存在较大风险。
  -  不过似乎一些简单的系统可用
- 3. 随机盐值哈希存储
  - *黑客要想破解盐值哈希存储，得： 1. 拿到盐值秘钥 2. 根据秘钥建立彩虹表* 
  - 要抗彩虹表攻击， 可以加随机盐， 盐值就很难拿到，再根据随机盐值去建表，黑客只能“望盐兴叹”。APP和APP后台需要使用相同的随机盐， 那么APP是怎样获取APP后台的随机盐呢？这又涉及到一系列的加密算法和秘钥管理问题，在实际系统中，有些公司就是这么做的。
  - 流程机制比较繁琐
- 4. *bcrypt存储*
  - 终极做法
  - bcrypt是一个带随机盐的哈希函数，在哈希值中，又携带了盐的信息。
  - 在APP后台，就能从哈希值中解析出APP端使用的随机盐值，该随机盐不需要被APP后台数据库存储，减少了盐值泄露的风险
  - *除了加盐来抵御rainbow table 攻击之外，bcrypt的一个非常重要的特征就是自适应性，可以保证加密的速度在一个特定的范围内，即使计算机的运算能力非常高，可以通过增加迭代次数的方式，使得加密速度变慢，从而可以抵御暴力搜索攻击。*
  - 原理：
    - 用户注册后，将用密码用bcrypt哈希处理， 后台存的密码是这个带有随机盐的bcrypt哈希值
    - 用户登录的时候，

...待补充，感觉有点偏后端了，优先级可以降低一些。

### 单点登录

步骤流程过多，而且比较偏，下面写的感觉还是有点问题,了解大概就行：

在*多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录*。比如： 淘宝和天猫

方案：

- 将登陆功能抽取为一个系统（SSO），其他系统请求SSO进行登录：（解决了Session不能共享的问题）
  - 一个子系统登录时, SSO系统生成一个token，并将用户信息存到Redis中，并设置过期时间
  - 其他系统请求SSO系统进行登录，得到SSO返回的token，写到Cookie中
  - 每次请求时，Cookie都会带上，拦截器得到token，判断是否已经登录
- cookie 跨域问题: 由于域名不同，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。有下面三种方案：
  - 1. 将Token保存在Stroage中, 请求的时候添加到请求头里（不依赖Cookie就没有跨域的问题了）
  - 2. 多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。
  - 3. 服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了？ 不太懂这个


cas (中央认证服务): 比较流行的一种单点登录解决方案  （类似的还有OAuth2 + JWT）
- 三个重要的概念：
  - TGT(Ticket Granting Ticket)： 类似于session, 用户的基本信息，如用户名、登录有效期等信息，都将存储在此。
  - TGC(Ticket Granting Cookie): 类似于sessionId 以 Cookie 的形式保存在浏览器中
  - ST(Service Ticket): 给用户发放的一张票据, 用户在访问其他服务时，发现没有 Cookie 或者 ST, ，那么就会 302 到 CAS Server 获取 ST, 然后会携带着 ST 302 回来，，CAS Client(微服务) 则通过 ST 去 CAS Server 上获取用户的登录状态。
- 整体流程：比如有A.com, B.com 两个系统， 以及www.sso.com
  - 1. 首先，用户想要访问系统A
  - 2. A发现用户并没有登录, 于是重定向请求到sso认证中心, 并将自己的地址作为参数。请求的地址是：www.sso.com?service=A.com
  - 3. sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（（生成一份Token，写到Cookie中，保存在浏览器上）
  - 4. 认证中心重定向回系统A，并把Token携带过去给系统A，重定向的地址如下：A.com?token=xxxxxxx
  - 5. 接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（创建Session）。到此，系统A和用户已经是登录状态了。
  - 6. 用户想要访问系统B.com， B.com, 发现用户并没有登录,于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址是：www.sso.com?service=B.com
  - 7. 因为之前用户与认证中心www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心www.sso.com是可以带上Cookie的？
  - 8. 认证中心根据带过来的Cookie发现已经与用户建立了全局会话了，认证中心重定向回系统B，并把Token携带过去给系统B，重定向的地址如下B.com?token=xxxxxxx
  - 9. 接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（创建Session）。到此，系统B和用户已经是登录状态了。